// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18449
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.TestSuite {
    using System;
    using System.Collections.Generic;
    using System.Text;
    using System.Reflection;
    using Microsoft.SpecExplorer.Runtime.Testing;
    using Microsoft.Protocols.TestTools;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Spec Explorer", "3.5.3146.0")]
    [Microsoft.VisualStudio.TestTools.UnitTesting.TestClassAttribute()]
    public partial class ResilientHandleBasicTestCase : PtfTestClassBase {
        
        public ResilientHandleBasicTestCase() {
            this.SetSwitch("ProceedControlTimeout", "100");
            this.SetSwitch("QuiescenceTimeout", "30000");
        }
        
        #region Expect Delegates
        public delegate void ReadConfigDelegate1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config);
        
        public delegate void ReEstablishResilientOpenResponseDelegate1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status);
        
        public delegate void PreConstraintDelegate1();
        
        public delegate void IoCtlResiliencyResponseDelegate1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c);
        
        public delegate void DisconnectDelegate1();
        #endregion
        
        #region Event Metadata
        static System.Reflection.MethodBase ReadConfigInfo = TestManagerHelpers.GetMethodInfo(typeof(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IResilientHandleAdapter), "ReadConfig", typeof(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig).MakeByRefType());
        
        static System.Reflection.EventInfo IoCtlResiliencyResponseInfo = TestManagerHelpers.GetEventInfo(typeof(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IResilientHandleAdapter), "IoCtlResiliencyResponse");
        
        static System.Reflection.EventInfo ReEstablishResilientOpenResponseInfo = TestManagerHelpers.GetEventInfo(typeof(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IResilientHandleAdapter), "ReEstablishResilientOpenResponse");
        
        static System.Reflection.MethodBase DisconnectInfo = TestManagerHelpers.GetMethodInfo(typeof(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IResilientHandleAdapter), "Disconnect");
        #endregion
        
        #region Adapter Instances
        private Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IResilientHandleAdapter IResilientHandleAdapterInstance;
        #endregion
        
        #region Variables
        private IVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig> c;
        
        private IVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig> c1;
        
        private IVariable<int> status;
        
        private IVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig> v;
        
        private IVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig> v1;
        
        private IVariable<int> v2;
        #endregion
        
        #region Class Initialization and Cleanup
        [Microsoft.VisualStudio.TestTools.UnitTesting.ClassInitializeAttribute()]
        public static void ClassInitialize(Microsoft.VisualStudio.TestTools.UnitTesting.TestContext context) {
            PtfTestClassBase.Initialize(context);
        }
        
        [Microsoft.VisualStudio.TestTools.UnitTesting.ClassCleanupAttribute()]
        public static void ClassCleanup() {
            PtfTestClassBase.Cleanup();
        }
        #endregion
        
        #region Test Initialization and Cleanup
        protected override void TestInitialize() {
            this.InitializeTestManager();
            this.IResilientHandleAdapterInstance = ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IResilientHandleAdapter)(this.Manager.GetAdapter(typeof(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IResilientHandleAdapter))));
            this.Manager.Subscribe(IoCtlResiliencyResponseInfo, this.IResilientHandleAdapterInstance);
            this.Manager.Subscribe(ReEstablishResilientOpenResponseInfo, this.IResilientHandleAdapterInstance);
            this.c = this.Manager.CreateVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>("c");
            this.c1 = this.Manager.CreateVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>("c1");
            this.status = this.Manager.CreateVariable<int>("status");
            this.v = this.Manager.CreateVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>("v");
            this.v1 = this.Manager.CreateVariable<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>("v1");
            this.v2 = this.Manager.CreateVariable<int>("v2");
        }
        
        protected override void TestCleanup() {
            base.TestCleanup();
            this.CleanupTestManager();
        }
        #endregion
        
        #region Test Starting in S0
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS0() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS0");
            this.Manager.Comment("reaching state \'S0\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp0;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp0);
            this.Manager.AddReturn(ReadConfigInfo, null, temp0);
            this.Manager.Comment("reaching state \'S1\'");
            int temp15 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS0ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS0ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS0ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS0ReadConfigChecker3)));
            if ((temp15 == 0)) {
                this.Manager.Comment("reaching state \'S147\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S148\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S149\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S150\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S151\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker)));
                }
                goto label14;
            }
            if ((temp15 == 1)) {
                this.Manager.Comment("reaching state \'S2\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S3\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S4\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S5\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S6\'");
                int temp5 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker3)));
                if ((temp5 == 0)) {
                    ResilientHandleBasicTestCaseS20();
                    goto label4;
                }
                if ((temp5 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label4;
                }
                if ((temp5 == 2)) {
                    ResilientHandleBasicTestCaseS7();
                    goto label4;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker3)));
            label4:
;
                goto label14;
            }
            if ((temp15 == 2)) {
                this.Manager.Comment("reaching state \'S46\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S47\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S48\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S49\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S50\'");
                int temp8 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker5)));
                if ((temp8 == 0)) {
                    ResilientHandleBasicTestCaseS51();
                    goto label7;
                }
                if ((temp8 == 1)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label7;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker5)));
            label7:
;
                goto label14;
            }
            if ((temp15 == 3)) {
                this.Manager.Comment("reaching state \'S77\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S78\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S79\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S80\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S81\'");
                int temp14 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker9)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker10)));
                if ((temp14 == 0)) {
                    ResilientHandleBasicTestCaseS108();
                    goto label13;
                }
                if ((temp14 == 1)) {
                    ResilientHandleBasicTestCaseS121();
                    goto label13;
                }
                if ((temp14 == 2)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label13;
                }
                if ((temp14 == 3)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label13;
                }
                if ((temp14 == 4)) {
                    ResilientHandleBasicTestCaseS95();
                    goto label13;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker9)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker10)));
            label13:
;
                goto label14;
            }
            throw new InvalidOperationException("never reached");
        label14:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS0ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S151");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S151");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS152() {
            this.Manager.Comment("reaching state \'S152\'");
            int temp1 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker1)));
            if ((temp1 == 0)) {
                this.Manager.Comment("reaching state \'S153\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S154\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S155\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S156\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S157\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker))) != -1)) {
                    this.Manager.Comment("reaching state \'S158\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker)));
                }
                goto label0;
            }
            if ((temp1 == 1)) {
                ResilientHandleBasicTestCaseS159();
                goto label0;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S152\'.");
        label0:
;
        }
        
        private void PreConstraintChecker() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S157");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker1() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS159() {
            this.Manager.Comment("reaching state \'S159\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S160\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S161\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S162\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S163\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker1))) != -1)) {
                this.Manager.Comment("reaching state \'S164\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker1)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S163");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS0ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S6");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S6");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS20() {
            this.Manager.Comment("reaching state \'S20\'");
            int temp2 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker2)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker3)));
            if ((temp2 == 0)) {
                this.Manager.Comment("reaching state \'S21\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.AddReturn(DisconnectInfo, null);
                ResilientHandleBasicTestCaseS22();
                goto label1;
            }
            if ((temp2 == 1)) {
                this.Manager.Comment("reaching state \'S27\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S28\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S29\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S30\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S31\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S32\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker3)));
                }
                goto label1;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S20\'.");
        label1:
;
        }
        
        private void PreConstraintChecker2() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS22() {
            this.Manager.Comment("reaching state \'S22\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS0DisconnectChecker)));
            this.Manager.Comment("reaching state \'S23\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S24\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S25\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker2))) != -1)) {
                this.Manager.Comment("reaching state \'S26\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker2)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS0DisconnectChecker() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S25");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker3() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S31");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S6");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S6");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS33() {
            this.Manager.Comment("reaching state \'S33\'");
            int temp3 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker4)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker5)));
            if ((temp3 == 0)) {
                this.Manager.Comment("reaching state \'S34\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S35\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S36\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S37\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S38\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker4))) != -1)) {
                    this.Manager.Comment("reaching state \'S39\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker4)));
                }
                goto label2;
            }
            if ((temp3 == 1)) {
                this.Manager.Comment("reaching state \'S40\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S41\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S42\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S43\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S44\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker5))) != -1)) {
                    this.Manager.Comment("reaching state \'S45\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker5)));
                }
                goto label2;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S33\'.");
        label2:
;
        }
        
        private void PreConstraintChecker4() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S38");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker5() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S44");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S6");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S6");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS7() {
            this.Manager.Comment("reaching state \'S7\'");
            int temp4 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker6)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker7)));
            if ((temp4 == 0)) {
                this.Manager.Comment("reaching state \'S14\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S15\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S16\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S17\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S18\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker6))) != -1)) {
                    this.Manager.Comment("reaching state \'S19\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker6)));
                }
                goto label3;
            }
            if ((temp4 == 1)) {
                this.Manager.Comment("reaching state \'S8\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S9\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S10\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S11\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S12\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker7))) != -1)) {
                    this.Manager.Comment("reaching state \'S13\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker7)));
                }
                goto label3;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S7\'.");
        label3:
;
        }
        
        private void PreConstraintChecker6() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb30 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S18");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker7() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb30 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S12");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S50");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S50");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS51() {
            this.Manager.Comment("reaching state \'S51\'");
            int temp6 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker8)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker9)));
            if ((temp6 == 0)) {
                this.Manager.Comment("reaching state \'S52\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Comment("reaching state \'S53\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S54\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S55\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S56\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker8))) != -1)) {
                    this.Manager.Comment("reaching state \'S57\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker8)));
                }
                goto label5;
            }
            if ((temp6 == 1)) {
                this.Manager.Comment("reaching state \'S58\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S59\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S60\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S61\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S62\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker9))) != -1)) {
                    ResilientHandleBasicTestCaseS63();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker9)));
                }
                goto label5;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S51\'.");
        label5:
;
        }
        
        private void PreConstraintChecker8() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S56");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker9() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S62");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS63() {
            this.Manager.Comment("reaching state \'S63\'");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S50");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S50");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS64() {
            this.Manager.Comment("reaching state \'S64\'");
            int temp7 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker10)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker11)));
            if ((temp7 == 0)) {
                this.Manager.Comment("reaching state \'S65\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S66\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S67\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S68\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S69\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker10))) != -1)) {
                    this.Manager.Comment("reaching state \'S70\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker10)));
                }
                goto label6;
            }
            if ((temp7 == 1)) {
                this.Manager.Comment("reaching state \'S71\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S72\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S73\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S74\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S75\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker11))) != -1)) {
                    this.Manager.Comment("reaching state \'S76\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker11)));
                }
                goto label6;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S64\'.");
        label6:
;
        }
        
        private void PreConstraintChecker10() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker10(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S69");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker11() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker11(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S75");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S81");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S81");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS108() {
            this.Manager.Comment("reaching state \'S108\'");
            int temp9 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker12)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker13)));
            if ((temp9 == 0)) {
                this.Manager.Comment("reaching state \'S109\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S110\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S111\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S112\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S113\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker12))) != -1)) {
                    this.Manager.Comment("reaching state \'S114\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker12)));
                }
                goto label8;
            }
            if ((temp9 == 1)) {
                this.Manager.Comment("reaching state \'S115\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S116\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S117\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S118\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S119\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker13))) != -1)) {
                    this.Manager.Comment("reaching state \'S120\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker13)));
                }
                goto label8;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S108\'.");
        label8:
;
        }
        
        private void PreConstraintChecker12() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker12(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S113");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker13() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker13(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S119");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S81");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S81");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS121() {
            this.Manager.Comment("reaching state \'S121\'");
            int temp10 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker14)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker15)));
            if ((temp10 == 0)) {
                this.Manager.Comment("reaching state \'S122\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S123\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S124\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S125\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S126\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker14))) != -1)) {
                    this.Manager.Comment("reaching state \'S127\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker14)));
                }
                goto label9;
            }
            if ((temp10 == 1)) {
                ResilientHandleBasicTestCaseS128();
                goto label9;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S121\'.");
        label9:
;
        }
        
        private void PreConstraintChecker14() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker14(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S126");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker15() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS128() {
            this.Manager.Comment("reaching state \'S128\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S129\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S130\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S131\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S132\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker15))) != -1)) {
                this.Manager.Comment("reaching state \'S133\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker15)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker15(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S132");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S81");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S81");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS134() {
            this.Manager.Comment("reaching state \'S134\'");
            int temp11 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker16)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker17)));
            if ((temp11 == 0)) {
                this.Manager.Comment("reaching state \'S135\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S136\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S137\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S138\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S139\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker16))) != -1)) {
                    this.Manager.Comment("reaching state \'S140\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker16)));
                }
                goto label10;
            }
            if ((temp11 == 1)) {
                this.Manager.Comment("reaching state \'S141\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S142\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S143\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S144\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S145\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker17))) != -1)) {
                    this.Manager.Comment("reaching state \'S146\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker17)));
                }
                goto label10;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S134\'.");
        label10:
;
        }
        
        private void PreConstraintChecker16() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker16(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S139");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker17() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker17(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S145");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S81");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S81");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS82() {
            this.Manager.Comment("reaching state \'S82\'");
            int temp12 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker18)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker19)));
            if ((temp12 == 0)) {
                this.Manager.Comment("reaching state \'S83\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S84\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S85\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S86\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S87\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker18))) != -1)) {
                    this.Manager.Comment("reaching state \'S88\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker18)));
                }
                goto label11;
            }
            if ((temp12 == 1)) {
                ResilientHandleBasicTestCaseS89();
                goto label11;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S82\'.");
        label11:
;
        }
        
        private void PreConstraintChecker18() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker18(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S87");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker19() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS89() {
            this.Manager.Comment("reaching state \'S89\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S90\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S91\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S92\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S93\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker19))) != -1)) {
                this.Manager.Comment("reaching state \'S94\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker19)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker19(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S93");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void ResilientHandleBasicTestCaseS0IoCtlResiliencyResponseChecker10(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S81");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S81");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS95() {
            this.Manager.Comment("reaching state \'S95\'");
            int temp13 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker20)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker21)));
            if ((temp13 == 0)) {
                ResilientHandleBasicTestCaseS102();
                goto label12;
            }
            if ((temp13 == 1)) {
                this.Manager.Comment("reaching state \'S96\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S97\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S98\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S99\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S100\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker21))) != -1)) {
                    this.Manager.Comment("reaching state \'S101\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker21)));
                }
                goto label12;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S95\'.");
        label12:
;
        }
        
        private void PreConstraintChecker20() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS102() {
            this.Manager.Comment("reaching state \'S102\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S103\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S104\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S105\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S106\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker20))) != -1)) {
                this.Manager.Comment("reaching state \'S107\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker20)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker20(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S106");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        
        private void PreConstraintChecker21() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS0ReEstablishResilientOpenResponseChecker21(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S100");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
        }
        #endregion
        
        #region Test Starting in S1048
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1048() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1048");
            this.Manager.Comment("reaching state \'S1048\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp16;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp16);
            this.Manager.AddReturn(ReadConfigInfo, null, temp16);
            this.Manager.Comment("reaching state \'S1049\'");
            int temp32 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1048ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1048ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1048ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1048ReadConfigChecker3)));
            if ((temp32 == 0)) {
                this.Manager.Comment("reaching state \'S1050\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1051\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1052\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1053\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1054\'");
                int temp19 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker1)));
                if ((temp19 == 0)) {
                    this.Manager.Comment("reaching state \'S1055\'");
                    int temp17 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker22)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker23)));
                    if ((temp17 == 0)) {
                        this.Manager.Comment("reaching state \'S1056\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1057\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1058\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S1059\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1060\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1061\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label15;
                    }
                    if ((temp17 == 1)) {
                        ResilientHandleBasicTestCaseS417();
                        goto label15;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1055\'.");
                label15:
;
                    goto label17;
                }
                if ((temp19 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label17;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker1)));
            label17:
;
                goto label30;
            }
            if ((temp32 == 1)) {
                this.Manager.Comment("reaching state \'S1062\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1063\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1064\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1065\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1066\'");
                int temp24 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker5)));
                if ((temp24 == 0)) {
                    this.Manager.Comment("reaching state \'S1067\'");
                    int temp20 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker26)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker27)));
                    if ((temp20 == 0)) {
                        this.Manager.Comment("reaching state \'S1068\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1069\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1070\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1071\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1072\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker4))) != -1)) {
                            this.Manager.Comment("reaching state \'S1073\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker4)));
                        }
                        goto label18;
                    }
                    if ((temp20 == 1)) {
                        ResilientHandleBasicTestCaseS456();
                        goto label18;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1067\'.");
                label18:
;
                    goto label22;
                }
                if ((temp24 == 1)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label22;
                }
                if ((temp24 == 2)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label22;
                }
                if ((temp24 == 3)) {
                    ResilientHandleBasicTestCaseS971();
                    goto label22;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker5)));
            label22:
;
                goto label30;
            }
            if ((temp32 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label30;
            }
            if ((temp32 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label30;
            }
            throw new InvalidOperationException("never reached");
        label30:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1048ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1049");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1054");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1054");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker22() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1060");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker23() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS417() {
            this.Manager.Comment("reaching state \'S417\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS418();
        }
        
        private void ResilientHandleBasicTestCaseS418() {
            this.Manager.Comment("reaching state \'S418\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1048DisconnectChecker)));
            this.Manager.Comment("reaching state \'S419\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S420\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S421\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker1))) != -1)) {
                this.Manager.Comment("reaching state \'S422\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker1)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048DisconnectChecker() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S421");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1054");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1054");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS423() {
            this.Manager.Comment("reaching state \'S423\'");
            int temp18 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker24)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker25)));
            if ((temp18 == 0)) {
                this.Manager.Comment("reaching state \'S424\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S425\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S426\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S427\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S428\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S429\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker2)));
                }
                goto label16;
            }
            if ((temp18 == 1)) {
                this.Manager.Comment("reaching state \'S430\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S431\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S432\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S433\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S434\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S435\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker3)));
                }
                goto label16;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S423\'.");
        label16:
;
        }
        
        private void PreConstraintChecker24() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S428");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker25() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S434");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1049");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1066");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1066");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker26() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1072");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker27() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS456() {
            this.Manager.Comment("reaching state \'S456\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS295();
        }
        
        private void ResilientHandleBasicTestCaseS295() {
            this.Manager.Comment("reaching state \'S295\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1048DisconnectChecker1)));
            this.Manager.Comment("reaching state \'S296\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S297\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S298\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker5))) != -1)) {
                this.Manager.Comment("reaching state \'S299\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker5)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048DisconnectChecker1() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S298");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1066");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1066");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS267() {
            this.Manager.Comment("reaching state \'S267\'");
            int temp21 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker28)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker29)));
            if ((temp21 == 0)) {
                this.Manager.Comment("reaching state \'S268\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S269\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S270\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S271\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S272\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker6))) != -1)) {
                    this.Manager.Comment("reaching state \'S273\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker6)));
                }
                goto label19;
            }
            if ((temp21 == 1)) {
                this.Manager.Comment("reaching state \'S274\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S275\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S276\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S277\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S278\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker7))) != -1)) {
                    this.Manager.Comment("reaching state \'S279\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker7)));
                }
                goto label19;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S267\'.");
        label19:
;
        }
        
        private void PreConstraintChecker28() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S272");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker29() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S278");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1066");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1066");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS280() {
            this.Manager.Comment("reaching state \'S280\'");
            int temp22 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker30)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker31)));
            if ((temp22 == 0)) {
                this.Manager.Comment("reaching state \'S281\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S282\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S283\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S284\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S285\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker8))) != -1)) {
                    this.Manager.Comment("reaching state \'S286\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker8)));
                }
                goto label20;
            }
            if ((temp22 == 1)) {
                this.Manager.Comment("reaching state \'S287\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S288\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S289\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S290\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S291\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker9))) != -1)) {
                    this.Manager.Comment("reaching state \'S292\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker9)));
                }
                goto label20;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S280\'.");
        label20:
;
        }
        
        private void PreConstraintChecker30() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S285");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker31() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S291");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1066");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1066");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS971() {
            this.Manager.Comment("reaching state \'S971\'");
            int temp23 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker32)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker33)));
            if ((temp23 == 0)) {
                ResilientHandleBasicTestCaseS448();
                goto label21;
            }
            if ((temp23 == 1)) {
                this.Manager.Comment("reaching state \'S972\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S973\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S974\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S975\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S976\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker11))) != -1)) {
                    ResilientHandleBasicTestCaseS447();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker11)));
                }
                goto label21;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S971\'.");
        label21:
;
        }
        
        private void PreConstraintChecker32() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS448() {
            this.Manager.Comment("reaching state \'S448\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS256();
        }
        
        private void ResilientHandleBasicTestCaseS256() {
            this.Manager.Comment("reaching state \'S256\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1048DisconnectChecker2)));
            this.Manager.Comment("reaching state \'S257\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S258\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S259\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker10))) != -1)) {
                this.Manager.Comment("reaching state \'S260\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker10)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048DisconnectChecker2() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker10(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S259");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker33() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker11(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S976");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS447() {
            this.Manager.Comment("reaching state \'S447\'");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1049");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS224() {
            this.Manager.Comment("reaching state \'S224\'");
            this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
            this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
            this.Manager.Comment("reaching state \'S225\'");
            this.Manager.Comment("checking step \'return PrepareOpen\'");
            this.Manager.Comment("reaching state \'S226\'");
            this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                    "Timeout)\'");
            this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
            this.Manager.Comment("reaching state \'S227\'");
            this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
            this.Manager.Comment("reaching state \'S228\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker6))) != -1)) {
                this.Manager.Comment("reaching state \'S229\'");
                int temp25 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker34)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker35)));
                if ((temp25 == 0)) {
                    ResilientHandleBasicTestCaseS159();
                    goto label23;
                }
                if ((temp25 == 1)) {
                    ResilientHandleBasicTestCaseS230();
                    goto label23;
                }
                this.Manager.Assert(false, "reached non-accepting end state \'S229\'.");
            label23:
;
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker6)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S228");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S228");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        
        private void PreConstraintChecker34() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void PreConstraintChecker35() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS230() {
            this.Manager.Comment("reaching state \'S230\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S231\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S232\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S233\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S234\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker12))) != -1)) {
                this.Manager.Comment("reaching state \'S235\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker12)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker12(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S234");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1049");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS457() {
            this.Manager.Comment("reaching state \'S457\'");
            this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
            this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
            this.Manager.Comment("reaching state \'S458\'");
            this.Manager.Comment("checking step \'return PrepareOpen\'");
            this.Manager.Comment("reaching state \'S459\'");
            this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                    "Timeout)\'");
            this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
            this.Manager.Comment("reaching state \'S460\'");
            this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
            this.Manager.Comment("reaching state \'S461\'");
            int temp31 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker9)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker10)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker11)));
            if ((temp31 == 0)) {
                ResilientHandleBasicTestCaseS339();
                goto label29;
            }
            if ((temp31 == 1)) {
                ResilientHandleBasicTestCaseS352();
                goto label29;
            }
            if ((temp31 == 2)) {
                ResilientHandleBasicTestCaseS462();
                goto label29;
            }
            if ((temp31 == 3)) {
                ResilientHandleBasicTestCaseS475();
                goto label29;
            }
            if ((temp31 == 4)) {
                this.Manager.Comment("reaching state \'S488\'");
                int temp30 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker44)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker45)));
                if ((temp30 == 0)) {
                    ResilientHandleBasicTestCaseS489();
                    goto label28;
                }
                if ((temp30 == 1)) {
                    ResilientHandleBasicTestCaseS490();
                    goto label28;
                }
                this.Manager.Assert(false, "reached non-accepting end state \'S488\'.");
            label28:
;
                goto label29;
            }
            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker9)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker10)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker11)));
        label29:
;
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S461");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S461");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS339() {
            this.Manager.Comment("reaching state \'S339\'");
            int temp26 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker36)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker37)));
            if ((temp26 == 0)) {
                this.Manager.Comment("reaching state \'S340\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S341\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S342\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S343\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S344\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker13))) != -1)) {
                    this.Manager.Comment("reaching state \'S345\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker13)));
                }
                goto label24;
            }
            if ((temp26 == 1)) {
                this.Manager.Comment("reaching state \'S346\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S347\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S348\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S349\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S350\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker14))) != -1)) {
                    this.Manager.Comment("reaching state \'S351\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker14)));
                }
                goto label24;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S339\'.");
        label24:
;
        }
        
        private void PreConstraintChecker36() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker13(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S344");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker37() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker14(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S350");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S461");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S461");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS352() {
            this.Manager.Comment("reaching state \'S352\'");
            int temp27 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker38)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker39)));
            if ((temp27 == 0)) {
                ResilientHandleBasicTestCaseS353();
                goto label25;
            }
            if ((temp27 == 1)) {
                ResilientHandleBasicTestCaseS359();
                goto label25;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S352\'.");
        label25:
;
        }
        
        private void PreConstraintChecker38() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS353() {
            this.Manager.Comment("reaching state \'S353\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S354\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S355\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S356\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S357\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker15))) != -1)) {
                this.Manager.Comment("reaching state \'S358\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker15)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker15(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S357");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker39() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS359() {
            this.Manager.Comment("reaching state \'S359\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S360\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S361\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S362\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S363\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker16))) != -1)) {
                this.Manager.Comment("reaching state \'S364\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker16)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker16(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S363");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S461");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S461");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS462() {
            this.Manager.Comment("reaching state \'S462\'");
            int temp28 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker40)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker41)));
            if ((temp28 == 0)) {
                this.Manager.Comment("reaching state \'S463\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S464\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S465\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S466\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S467\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker17))) != -1)) {
                    this.Manager.Comment("reaching state \'S468\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker17)));
                }
                goto label26;
            }
            if ((temp28 == 1)) {
                this.Manager.Comment("reaching state \'S469\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S470\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S471\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S472\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S473\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker18))) != -1)) {
                    this.Manager.Comment("reaching state \'S474\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker18)));
                }
                goto label26;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S462\'.");
        label26:
;
        }
        
        private void PreConstraintChecker40() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb30 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker17(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S467");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker41() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb30 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker18(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S473");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker10(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S461");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S461");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS475() {
            this.Manager.Comment("reaching state \'S475\'");
            int temp29 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker42)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker43)));
            if ((temp29 == 0)) {
                this.Manager.Comment("reaching state \'S476\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.AddReturn(DisconnectInfo, null);
                ResilientHandleBasicTestCaseS477();
                goto label27;
            }
            if ((temp29 == 1)) {
                this.Manager.Comment("reaching state \'S482\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S483\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S484\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S485\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S486\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker20))) != -1)) {
                    this.Manager.Comment("reaching state \'S487\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker20)));
                }
                goto label27;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S475\'.");
        label27:
;
        }
        
        private void PreConstraintChecker42() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS477() {
            this.Manager.Comment("reaching state \'S477\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1048DisconnectChecker3)));
            this.Manager.Comment("reaching state \'S478\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S479\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S480\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker19))) != -1)) {
                this.Manager.Comment("reaching state \'S481\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker19)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048DisconnectChecker3() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker19(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S480");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker43() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker20(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S486");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1048IoCtlResiliencyResponseChecker11(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S461");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S461");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker44() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS489() {
            this.Manager.Comment("reaching state \'S489\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS321();
        }
        
        private void ResilientHandleBasicTestCaseS321() {
            this.Manager.Comment("reaching state \'S321\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1048DisconnectChecker4)));
            this.Manager.Comment("reaching state \'S322\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S323\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S324\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker21))) != -1)) {
                this.Manager.Comment("reaching state \'S325\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker21)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048DisconnectChecker4() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker21(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S324");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker45() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS490() {
            this.Manager.Comment("reaching state \'S490\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S491\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S492\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S493\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S494\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker22))) != -1)) {
                this.Manager.Comment("reaching state \'S495\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker22)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1048ReEstablishResilientOpenResponseChecker22(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S494");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        #endregion
        
        #region Test Starting in S1074
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1074() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1074");
            this.Manager.Comment("reaching state \'S1074\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp33;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp33);
            this.Manager.AddReturn(ReadConfigInfo, null, temp33);
            this.Manager.Comment("reaching state \'S1075\'");
            int temp39 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1074ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1074ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1074ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1074ReadConfigChecker3)));
            if ((temp39 == 0)) {
                this.Manager.Comment("reaching state \'S1076\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1077\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1078\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1079\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1080\'");
                int temp35 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker1)));
                if ((temp35 == 0)) {
                    ResilientHandleBasicTestCaseS1081();
                    goto label32;
                }
                if ((temp35 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label32;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker1)));
            label32:
;
                goto label36;
            }
            if ((temp39 == 1)) {
                this.Manager.Comment("reaching state \'S1093\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1094\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1095\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1096\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1097\'");
                int temp38 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker5)));
                if ((temp38 == 0)) {
                    this.Manager.Comment("reaching state \'S1098\'");
                    int temp36 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker48)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker49)));
                    if ((temp36 == 0)) {
                        this.Manager.Comment("reaching state \'S1099\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1100\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1101\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1102\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1103\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S1104\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label33;
                    }
                    if ((temp36 == 1)) {
                        this.Manager.Comment("reaching state \'S1105\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1106\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1107\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S1108\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1109\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker3))) != -1)) {
                            this.Manager.Comment("reaching state \'S1110\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker3)));
                        }
                        goto label33;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1098\'.");
                label33:
;
                    goto label35;
                }
                if ((temp38 == 1)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label35;
                }
                if ((temp38 == 2)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label35;
                }
                if ((temp38 == 3)) {
                    ResilientHandleBasicTestCaseS977();
                    goto label35;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker5)));
            label35:
;
                goto label36;
            }
            if ((temp39 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label36;
            }
            if ((temp39 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label36;
            }
            throw new InvalidOperationException("never reached");
        label36:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1074ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1075");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1080");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1080");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1081() {
            this.Manager.Comment("reaching state \'S1081\'");
            int temp34 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker46)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker47)));
            if ((temp34 == 0)) {
                this.Manager.Comment("reaching state \'S1082\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S1083\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1084\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S1085\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1086\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker))) != -1)) {
                    ResilientHandleBasicTestCaseS416();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker)));
                }
                goto label31;
            }
            if ((temp34 == 1)) {
                this.Manager.Comment("reaching state \'S1087\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Comment("reaching state \'S1088\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S1089\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1090\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1091\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    this.Manager.Comment("reaching state \'S1092\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker1)));
                }
                goto label31;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1081\'.");
        label31:
;
        }
        
        private void PreConstraintChecker46() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1086");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS416() {
            this.Manager.Comment("reaching state \'S416\'");
        }
        
        private void PreConstraintChecker47() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1091");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1080");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1080");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1074ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1075");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1097");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1097");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker48() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1103");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker49() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1109");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1097");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1097");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1097");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1097");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1074IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1097");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1097");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS977() {
            this.Manager.Comment("reaching state \'S977\'");
            int temp37 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker50)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker51)));
            if ((temp37 == 0)) {
                this.Manager.Comment("reaching state \'S978\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S979\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S980\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S981\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S982\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker4))) != -1)) {
                    ResilientHandleBasicTestCaseS455();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker4)));
                }
                goto label34;
            }
            if ((temp37 == 1)) {
                this.Manager.Comment("reaching state \'S983\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Comment("reaching state \'S984\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S985\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S986\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S987\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker5))) != -1)) {
                    this.Manager.Comment("reaching state \'S988\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker5)));
                }
                goto label34;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S977\'.");
        label34:
;
        }
        
        private void PreConstraintChecker50() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S982");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS455() {
            this.Manager.Comment("reaching state \'S455\'");
        }
        
        private void PreConstraintChecker51() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1074ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S987");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1074ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1075");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1074ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1075");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1111
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1111() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1111");
            this.Manager.Comment("reaching state \'S1111\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp40;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp40);
            this.Manager.AddReturn(ReadConfigInfo, null, temp40);
            this.Manager.Comment("reaching state \'S1112\'");
            int temp46 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1111ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1111ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1111ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1111ReadConfigChecker3)));
            if ((temp46 == 0)) {
                this.Manager.Comment("reaching state \'S1113\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1114\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1115\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1116\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1117\'");
                int temp41 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker1)));
                if ((temp41 == 0)) {
                    ResilientHandleBasicTestCaseS1081();
                    goto label37;
                }
                if ((temp41 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label37;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker1)));
            label37:
;
                goto label42;
            }
            if ((temp46 == 1)) {
                this.Manager.Comment("reaching state \'S1118\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1119\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1120\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1121\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1122\'");
                int temp45 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker6)));
                if ((temp45 == 0)) {
                    ResilientHandleBasicTestCaseS241();
                    goto label41;
                }
                if ((temp45 == 1)) {
                    ResilientHandleBasicTestCaseS254();
                    goto label41;
                }
                if ((temp45 == 2)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label41;
                }
                if ((temp45 == 3)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label41;
                }
                if ((temp45 == 4)) {
                    ResilientHandleBasicTestCaseS293();
                    goto label41;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker6)));
            label41:
;
                goto label42;
            }
            if ((temp46 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label42;
            }
            if ((temp46 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label42;
            }
            throw new InvalidOperationException("never reached");
        label42:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1111ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1112");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1117");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1117");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1117");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1117");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1112");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1122");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1122");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS241() {
            this.Manager.Comment("reaching state \'S241\'");
            int temp42 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker52)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker53)));
            if ((temp42 == 0)) {
                this.Manager.Comment("reaching state \'S242\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S243\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S244\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S245\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S246\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker))) != -1)) {
                    this.Manager.Comment("reaching state \'S247\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker)));
                }
                goto label38;
            }
            if ((temp42 == 1)) {
                this.Manager.Comment("reaching state \'S248\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S249\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S250\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S251\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S252\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    this.Manager.Comment("reaching state \'S253\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker1)));
                }
                goto label38;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S241\'.");
        label38:
;
        }
        
        private void PreConstraintChecker52() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb21 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S246");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker53() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb21 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S252");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1122");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1122");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS254() {
            this.Manager.Comment("reaching state \'S254\'");
            int temp43 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker54)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker55)));
            if ((temp43 == 0)) {
                this.Manager.Comment("reaching state \'S255\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.AddReturn(DisconnectInfo, null);
                ResilientHandleBasicTestCaseS256();
                goto label39;
            }
            if ((temp43 == 1)) {
                this.Manager.Comment("reaching state \'S261\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S262\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S263\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S264\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S265\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S266\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker2)));
                }
                goto label39;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S254\'.");
        label39:
;
        }
        
        private void PreConstraintChecker54() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker55() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S265");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1122");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1122");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1122");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1122");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1122");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1122");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS293() {
            this.Manager.Comment("reaching state \'S293\'");
            int temp44 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker56)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker57)));
            if ((temp44 == 0)) {
                this.Manager.Comment("reaching state \'S294\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.AddReturn(DisconnectInfo, null);
                ResilientHandleBasicTestCaseS295();
                goto label40;
            }
            if ((temp44 == 1)) {
                this.Manager.Comment("reaching state \'S300\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S301\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S302\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S303\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S304\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S305\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker3)));
                }
                goto label40;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S293\'.");
        label40:
;
        }
        
        private void PreConstraintChecker56() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker57() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1111ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S304");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1111ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1112");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1111ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1112");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1123
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1123() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1123");
            this.Manager.Comment("reaching state \'S1123\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp47;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp47);
            this.Manager.AddReturn(ReadConfigInfo, null, temp47);
            this.Manager.Comment("reaching state \'S1124\'");
            int temp52 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1123ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1123ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1123ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1123ReadConfigChecker3)));
            if ((temp52 == 0)) {
                this.Manager.Comment("reaching state \'S1125\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1126\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1127\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1128\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1129\'");
                int temp50 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker2)));
                if ((temp50 == 0)) {
                    ResilientHandleBasicTestCaseS1130();
                    goto label45;
                }
                if ((temp50 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label45;
                }
                if ((temp50 == 2)) {
                    ResilientHandleBasicTestCaseS996();
                    goto label45;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker2)));
            label45:
;
                goto label47;
            }
            if ((temp52 == 1)) {
                this.Manager.Comment("reaching state \'S1143\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1144\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1145\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1146\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1147\'");
                int temp51 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker7)));
                if ((temp51 == 0)) {
                    ResilientHandleBasicTestCaseS241();
                    goto label46;
                }
                if ((temp51 == 1)) {
                    ResilientHandleBasicTestCaseS254();
                    goto label46;
                }
                if ((temp51 == 2)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label46;
                }
                if ((temp51 == 3)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label46;
                }
                if ((temp51 == 4)) {
                    ResilientHandleBasicTestCaseS293();
                    goto label46;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker7)));
            label46:
;
                goto label47;
            }
            if ((temp52 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label47;
            }
            if ((temp52 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label47;
            }
            throw new InvalidOperationException("never reached");
        label47:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1123ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1124");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1129");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1129");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1130() {
            this.Manager.Comment("reaching state \'S1130\'");
            int temp48 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker58)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker59)));
            if ((temp48 == 0)) {
                this.Manager.Comment("reaching state \'S1131\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S1132\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S1133\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1134\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1135\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker))) != -1)) {
                    this.Manager.Comment("reaching state \'S1136\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker)));
                }
                goto label43;
            }
            if ((temp48 == 1)) {
                this.Manager.Comment("reaching state \'S1137\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1138\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1139\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1140\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1141\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    this.Manager.Comment("reaching state \'S1142\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker1)));
                }
                goto label43;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1130\'.");
        label43:
;
        }
        
        private void PreConstraintChecker58() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1135");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker59() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1141");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1129");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1129");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1129");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1129");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS996() {
            this.Manager.Comment("reaching state \'S996\'");
            int temp49 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker60)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker61)));
            if ((temp49 == 0)) {
                this.Manager.Comment("reaching state \'S1003\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1004\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1005\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1006\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1007\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S1008\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker2)));
                }
                goto label44;
            }
            if ((temp49 == 1)) {
                this.Manager.Comment("reaching state \'S997\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S998\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S999\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1000\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1001\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S1002\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker3)));
                }
                goto label44;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S996\'.");
        label44:
;
        }
        
        private void PreConstraintChecker60() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1007");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker61() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1001");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1124");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1147");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1147");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1147");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1147");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1147");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1147");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1147");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1147");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1147");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1147");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1123ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1124");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1123ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1124");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1148
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1148() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1148");
            this.Manager.Comment("reaching state \'S1148\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp53;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp53);
            this.Manager.AddReturn(ReadConfigInfo, null, temp53);
            this.Manager.Comment("reaching state \'S1149\'");
            int temp57 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1148ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1148ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1148ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1148ReadConfigChecker3)));
            if ((temp57 == 0)) {
                this.Manager.Comment("reaching state \'S1150\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1151\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1152\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1153\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1154\'");
                int temp54 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker1)));
                if ((temp54 == 0)) {
                    ResilientHandleBasicTestCaseS1081();
                    goto label48;
                }
                if ((temp54 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label48;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker1)));
            label48:
;
                goto label51;
            }
            if ((temp57 == 1)) {
                this.Manager.Comment("reaching state \'S1155\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1156\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1157\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1158\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1159\'");
                int temp56 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker6)));
                if ((temp56 == 0)) {
                    this.Manager.Comment("reaching state \'S1160\'");
                    int temp55 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker62)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker63)));
                    if ((temp55 == 0)) {
                        this.Manager.Comment("reaching state \'S1161\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1162\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1163\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1164\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1165\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1148ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1166\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1148ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label49;
                    }
                    if ((temp55 == 1)) {
                        this.Manager.Comment("reaching state \'S1167\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1168\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1169\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1170\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1171\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1148ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1172\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1148ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label49;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1160\'.");
                label49:
;
                    goto label50;
                }
                if ((temp56 == 1)) {
                    ResilientHandleBasicTestCaseS254();
                    goto label50;
                }
                if ((temp56 == 2)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label50;
                }
                if ((temp56 == 3)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label50;
                }
                if ((temp56 == 4)) {
                    ResilientHandleBasicTestCaseS293();
                    goto label50;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker6)));
            label50:
;
                goto label51;
            }
            if ((temp57 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label51;
            }
            if ((temp57 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label51;
            }
            throw new InvalidOperationException("never reached");
        label51:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1148ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1149");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1154");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1154");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1154");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1154");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1149");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1159");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1159");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker62() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb21 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1148ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1165");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker63() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb21 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1171");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1159");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1159");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1159");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1159");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1159");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1159");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1159");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1159");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1148ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1149");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1148ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1149");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1173
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1173() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1173");
            this.Manager.Comment("reaching state \'S1173\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp58;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp58);
            this.Manager.AddReturn(ReadConfigInfo, null, temp58);
            this.Manager.Comment("reaching state \'S1174\'");
            int temp63 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1173ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1173ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1173ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1173ReadConfigChecker3)));
            if ((temp63 == 0)) {
                this.Manager.Comment("reaching state \'S1175\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1176\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1177\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1178\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1179\'");
                int temp59 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker2)));
                if ((temp59 == 0)) {
                    ResilientHandleBasicTestCaseS1130();
                    goto label52;
                }
                if ((temp59 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label52;
                }
                if ((temp59 == 2)) {
                    ResilientHandleBasicTestCaseS996();
                    goto label52;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker2)));
            label52:
;
                goto label56;
            }
            if ((temp63 == 1)) {
                this.Manager.Comment("reaching state \'S1180\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1181\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1182\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1183\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1184\'");
                int temp62 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker6)));
                if ((temp62 == 0)) {
                    this.Manager.Comment("reaching state \'S1185\'");
                    int temp60 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker64)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker65)));
                    if ((temp60 == 0)) {
                        this.Manager.Comment("reaching state \'S1186\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1187\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1188\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1189\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1190\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1191\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label53;
                    }
                    if ((temp60 == 1)) {
                        this.Manager.Comment("reaching state \'S1192\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1193\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1194\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1195\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1196\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1197\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label53;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1185\'.");
                label53:
;
                    goto label55;
                }
                if ((temp62 == 1)) {
                    this.Manager.Comment("reaching state \'S1198\'");
                    int temp61 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker66)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker67)));
                    if ((temp61 == 0)) {
                        this.Manager.Comment("reaching state \'S1199\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1200\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1201\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1202\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1203\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S1204\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label54;
                    }
                    if ((temp61 == 1)) {
                        this.Manager.Comment("reaching state \'S1205\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1206\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1207\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1208\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1209\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker3))) != -1)) {
                            this.Manager.Comment("reaching state \'S1210\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker3)));
                        }
                        goto label54;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1198\'.");
                label54:
;
                    goto label55;
                }
                if ((temp62 == 2)) {
                    ResilientHandleBasicTestCaseS971();
                    goto label55;
                }
                if ((temp62 == 3)) {
                    ResilientHandleBasicTestCaseS977();
                    goto label55;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker6)));
            label55:
;
                goto label56;
            }
            if ((temp63 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label56;
            }
            if ((temp63 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label56;
            }
            throw new InvalidOperationException("never reached");
        label56:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1173ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1174");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1179");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1179");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1179");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1179");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1179");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1179");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1173ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1174");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1184");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1184");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker64() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1190");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker65() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1196");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1184");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1184");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker66() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1203");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker67() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1173ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1209");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1184");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1184");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1173IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1184");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1184");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1173ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1174");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1173ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1174");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1211
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1211() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1211");
            this.Manager.Comment("reaching state \'S1211\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp64;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp64);
            this.Manager.AddReturn(ReadConfigInfo, null, temp64);
            this.Manager.Comment("reaching state \'S1212\'");
            int temp69 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1211ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1211ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1211ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1211ReadConfigChecker3)));
            if ((temp69 == 0)) {
                this.Manager.Comment("reaching state \'S1213\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1214\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1215\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1216\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1217\'");
                int temp65 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker2)));
                if ((temp65 == 0)) {
                    ResilientHandleBasicTestCaseS1130();
                    goto label57;
                }
                if ((temp65 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label57;
                }
                if ((temp65 == 2)) {
                    ResilientHandleBasicTestCaseS996();
                    goto label57;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker2)));
            label57:
;
                goto label61;
            }
            if ((temp69 == 1)) {
                this.Manager.Comment("reaching state \'S1218\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1219\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1220\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1221\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1222\'");
                int temp68 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker4)));
                if ((temp68 == 0)) {
                    this.Manager.Comment("reaching state \'S1223\'");
                    int temp66 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker68)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker69)));
                    if ((temp66 == 0)) {
                        this.Manager.Comment("reaching state \'S1224\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1225\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1226\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1227\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1228\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1229\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label58;
                    }
                    if ((temp66 == 1)) {
                        this.Manager.Comment("reaching state \'S1230\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1231\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1232\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1233\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1234\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1235\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label58;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1223\'.");
                label58:
;
                    goto label60;
                }
                if ((temp68 == 1)) {
                    this.Manager.Comment("reaching state \'S1236\'");
                    int temp67 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker70)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker71)));
                    if ((temp67 == 0)) {
                        this.Manager.Comment("reaching state \'S1237\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1238\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1239\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1240\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1241\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S1242\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label59;
                    }
                    if ((temp67 == 1)) {
                        ResilientHandleBasicTestCaseS1243();
                        goto label59;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1236\'.");
                label59:
;
                    goto label60;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker4)));
            label60:
;
                goto label61;
            }
            if ((temp69 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label61;
            }
            if ((temp69 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label61;
            }
            throw new InvalidOperationException("never reached");
        label61:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1211ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1212");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1217");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1217");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1217");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1217");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1217");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1217");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1211ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1212");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1222");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1222");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker68() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1228");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker69() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1234");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1211IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1222");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1222");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker70() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1241");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker71() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1243() {
            this.Manager.Comment("reaching state \'S1243\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS1244();
        }
        
        private void ResilientHandleBasicTestCaseS1244() {
            this.Manager.Comment("reaching state \'S1244\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1211DisconnectChecker)));
            this.Manager.Comment("reaching state \'S1245\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S1246\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S1247\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker3))) != -1)) {
                this.Manager.Comment("reaching state \'S1248\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker3)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1211DisconnectChecker() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1211ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1247");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1211ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1212");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1211ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1212");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1249
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1249() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1249");
            this.Manager.Comment("reaching state \'S1249\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp70;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp70);
            this.Manager.AddReturn(ReadConfigInfo, null, temp70);
            this.Manager.Comment("reaching state \'S1250\'");
            int temp76 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1249ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1249ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1249ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1249ReadConfigChecker3)));
            if ((temp76 == 0)) {
                this.Manager.Comment("reaching state \'S1251\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1252\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1253\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1254\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1255\'");
                int temp72 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker4)));
                if ((temp72 == 0)) {
                    ResilientHandleBasicTestCaseS108();
                    goto label63;
                }
                if ((temp72 == 1)) {
                    ResilientHandleBasicTestCaseS121();
                    goto label63;
                }
                if ((temp72 == 2)) {
                    this.Manager.Comment("reaching state \'S1256\'");
                    int temp71 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker72)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker73)));
                    if ((temp71 == 0)) {
                        this.Manager.Comment("reaching state \'S1257\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1258\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1259\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1260\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1261\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1262\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label62;
                    }
                    if ((temp71 == 1)) {
                        ResilientHandleBasicTestCaseS397();
                        goto label62;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1256\'.");
                label62:
;
                    goto label63;
                }
                if ((temp72 == 3)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label63;
                }
                if ((temp72 == 4)) {
                    ResilientHandleBasicTestCaseS95();
                    goto label63;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker4)));
            label63:
;
                goto label67;
            }
            if ((temp76 == 1)) {
                this.Manager.Comment("reaching state \'S1263\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1264\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1265\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1266\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1267\'");
                int temp75 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker7)));
                if ((temp75 == 0)) {
                    ResilientHandleBasicTestCaseS1268();
                    goto label66;
                }
                if ((temp75 == 1)) {
                    ResilientHandleBasicTestCaseS1281();
                    goto label66;
                }
                if ((temp75 == 2)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label66;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker7)));
            label66:
;
                goto label67;
            }
            if ((temp76 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label67;
            }
            if ((temp76 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label67;
            }
            throw new InvalidOperationException("never reached");
        label67:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1249ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1250");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1255");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1255");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1255");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1255");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1255");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1255");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker72() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1261");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker73() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS397() {
            this.Manager.Comment("reaching state \'S397\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.Comment("reaching state \'S398\'");
            this.Manager.Comment("checking step \'return Disconnect\'");
            this.Manager.Comment("reaching state \'S399\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S400\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S401\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker1))) != -1)) {
                this.Manager.Comment("reaching state \'S402\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker1)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S401");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1255");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1255");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1255");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1255");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1250");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1267");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1267");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1268() {
            this.Manager.Comment("reaching state \'S1268\'");
            int temp73 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker74)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker75)));
            if ((temp73 == 0)) {
                this.Manager.Comment("reaching state \'S1269\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S1270\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S1271\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1272\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1273\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S1274\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker2)));
                }
                goto label64;
            }
            if ((temp73 == 1)) {
                this.Manager.Comment("reaching state \'S1275\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1276\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1277\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1278\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1279\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S1280\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker3)));
                }
                goto label64;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1268\'.");
        label64:
;
        }
        
        private void PreConstraintChecker74() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1273");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker75() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1279");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1267");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1267");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1281() {
            this.Manager.Comment("reaching state \'S1281\'");
            int temp74 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker76)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker77)));
            if ((temp74 == 0)) {
                this.Manager.Comment("reaching state \'S1282\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1283\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1284\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1285\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1286\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker4))) != -1)) {
                    this.Manager.Comment("reaching state \'S1287\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker4)));
                }
                goto label65;
            }
            if ((temp74 == 1)) {
                this.Manager.Comment("reaching state \'S1288\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1289\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1290\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1291\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1292\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker5))) != -1)) {
                    this.Manager.Comment("reaching state \'S1293\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker5)));
                }
                goto label65;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1281\'.");
        label65:
;
        }
        
        private void PreConstraintChecker76() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb21 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1286");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker77() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb21 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1249ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1292");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1267");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1267");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1249ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1250");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1249ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1250");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1294
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1294() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1294");
            this.Manager.Comment("reaching state \'S1294\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp77;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp77);
            this.Manager.AddReturn(ReadConfigInfo, null, temp77);
            this.Manager.Comment("reaching state \'S1295\'");
            int temp83 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1294ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1294ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1294ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1294ReadConfigChecker3)));
            if ((temp83 == 0)) {
                this.Manager.Comment("reaching state \'S1296\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1297\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1298\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1299\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1300\'");
                int temp80 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker3)));
                if ((temp80 == 0)) {
                    ResilientHandleBasicTestCaseS1301();
                    goto label70;
                }
                if ((temp80 == 1)) {
                    ResilientHandleBasicTestCaseS1313();
                    goto label70;
                }
                if ((temp80 == 2)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label70;
                }
                if ((temp80 == 3)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label70;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker3)));
            label70:
;
                goto label73;
            }
            if ((temp83 == 1)) {
                this.Manager.Comment("reaching state \'S1325\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1326\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1327\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1328\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1329\'");
                int temp82 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker6)));
                if ((temp82 == 0)) {
                    ResilientHandleBasicTestCaseS1268();
                    goto label72;
                }
                if ((temp82 == 1)) {
                    this.Manager.Comment("reaching state \'S1330\'");
                    int temp81 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker82)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker83)));
                    if ((temp81 == 0)) {
                        this.Manager.Comment("reaching state \'S1331\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1332\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1333\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1334\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1335\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker4))) != -1)) {
                            this.Manager.Comment("reaching state \'S1336\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker4)));
                        }
                        goto label71;
                    }
                    if ((temp81 == 1)) {
                        this.Manager.Comment("reaching state \'S1337\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1338\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1339\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1340\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1341\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker5))) != -1)) {
                            this.Manager.Comment("reaching state \'S1342\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker5)));
                        }
                        goto label71;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1330\'.");
                label71:
;
                    goto label72;
                }
                if ((temp82 == 2)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label72;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker6)));
            label72:
;
                goto label73;
            }
            if ((temp83 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label73;
            }
            if ((temp83 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label73;
            }
            throw new InvalidOperationException("never reached");
        label73:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1294ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1295");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1300");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1300");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1301() {
            this.Manager.Comment("reaching state \'S1301\'");
            int temp78 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker78)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker79)));
            if ((temp78 == 0)) {
                this.Manager.Comment("reaching state \'S1302\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Comment("reaching state \'S1303\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S1304\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S1305\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1306\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker))) != -1)) {
                    this.Manager.Comment("reaching state \'S1307\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker)));
                }
                goto label68;
            }
            if ((temp78 == 1)) {
                this.Manager.Comment("reaching state \'S1308\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S1309\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1310\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S1311\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1312\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    ResilientHandleBasicTestCaseS389();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker1)));
                }
                goto label68;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1301\'.");
        label68:
;
        }
        
        private void PreConstraintChecker78() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1306");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker79() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1312");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS389() {
            this.Manager.Comment("reaching state \'S389\'");
        }
        
        private void ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1300");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1300");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1313() {
            this.Manager.Comment("reaching state \'S1313\'");
            int temp79 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker80)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker81)));
            if ((temp79 == 0)) {
                this.Manager.Comment("reaching state \'S1314\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S1315\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1316\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S1317\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1318\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    ResilientHandleBasicTestCaseS376();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker2)));
                }
                goto label69;
            }
            if ((temp79 == 1)) {
                this.Manager.Comment("reaching state \'S1319\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Comment("reaching state \'S1320\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S1321\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1322\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1323\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S1324\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker3)));
                }
                goto label69;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1313\'.");
        label69:
;
        }
        
        private void PreConstraintChecker80() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1318");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS376() {
            this.Manager.Comment("reaching state \'S376\'");
        }
        
        private void PreConstraintChecker81() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1323");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1300");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1300");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1300");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1300");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1294ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1295");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1329");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1329");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1329");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1329");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker82() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb21 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1335");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker83() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb21 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1294ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1341");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1294IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1329");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1329");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1294ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1295");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1294ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1295");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1343
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1343() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1343");
            this.Manager.Comment("reaching state \'S1343\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp84;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp84);
            this.Manager.AddReturn(ReadConfigInfo, null, temp84);
            this.Manager.Comment("reaching state \'S1344\'");
            int temp90 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1343ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1343ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1343ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1343ReadConfigChecker3)));
            if ((temp90 == 0)) {
                this.Manager.Comment("reaching state \'S1345\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1346\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1347\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1348\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1349\'");
                int temp87 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker3)));
                if ((temp87 == 0)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label76;
                }
                if ((temp87 == 1)) {
                    this.Manager.Comment("reaching state \'S1350\'");
                    int temp85 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker84)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker85)));
                    if ((temp85 == 0)) {
                        this.Manager.Comment("reaching state \'S1351\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1352\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1353\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1354\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1355\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1356\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label74;
                    }
                    if ((temp85 == 1)) {
                        ResilientHandleBasicTestCaseS390();
                        goto label74;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1350\'.");
                label74:
;
                    goto label76;
                }
                if ((temp87 == 2)) {
                    this.Manager.Comment("reaching state \'S1357\'");
                    int temp86 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker86)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker87)));
                    if ((temp86 == 0)) {
                        this.Manager.Comment("reaching state \'S1358\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1359\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1360\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S1361\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1362\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S1363\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label75;
                    }
                    if ((temp86 == 1)) {
                        ResilientHandleBasicTestCaseS377();
                        goto label75;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1357\'.");
                label75:
;
                    goto label76;
                }
                if ((temp87 == 3)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label76;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker3)));
            label76:
;
                goto label79;
            }
            if ((temp90 == 1)) {
                this.Manager.Comment("reaching state \'S1364\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1365\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1366\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1367\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1368\'");
                int temp89 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker5)));
                if ((temp89 == 0)) {
                    this.Manager.Comment("reaching state \'S1369\'");
                    int temp88 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker88)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker89)));
                    if ((temp88 == 0)) {
                        ResilientHandleBasicTestCaseS1243();
                        goto label77;
                    }
                    if ((temp88 == 1)) {
                        this.Manager.Comment("reaching state \'S1370\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S1371\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S1372\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1373\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1374\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker4))) != -1)) {
                            ResilientHandleBasicTestCaseS63();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker4)));
                        }
                        goto label77;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1369\'.");
                label77:
;
                    goto label78;
                }
                if ((temp89 == 1)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label78;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker5)));
            label78:
;
                goto label79;
            }
            if ((temp90 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label79;
            }
            if ((temp90 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label79;
            }
            throw new InvalidOperationException("never reached");
        label79:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1343ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1344");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1349");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1349");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1349");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1349");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker84() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1355");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker85() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS390() {
            this.Manager.Comment("reaching state \'S390\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS391();
        }
        
        private void ResilientHandleBasicTestCaseS391() {
            this.Manager.Comment("reaching state \'S391\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1343DisconnectChecker)));
            this.Manager.Comment("reaching state \'S392\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S393\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S394\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker1))) != -1)) {
                this.Manager.Comment("reaching state \'S395\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker1)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1343DisconnectChecker() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S394");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1349");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1349");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker86() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1362");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker87() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS377() {
            this.Manager.Comment("reaching state \'S377\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS378();
        }
        
        private void ResilientHandleBasicTestCaseS378() {
            this.Manager.Comment("reaching state \'S378\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1343DisconnectChecker1)));
            this.Manager.Comment("reaching state \'S379\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S380\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S381\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker3))) != -1)) {
                this.Manager.Comment("reaching state \'S382\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker3)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1343DisconnectChecker1() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S381");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1349");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1349");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1343ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1344");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1368");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1368");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker88() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker89() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1343ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1374");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1343IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1368");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1368");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1343ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1344");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1343ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1344");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1375
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1375() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1375");
            this.Manager.Comment("reaching state \'S1375\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp91;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp91);
            this.Manager.AddReturn(ReadConfigInfo, null, temp91);
            this.Manager.Comment("reaching state \'S1376\'");
            int temp95 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1375ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1375ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1375ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1375ReadConfigChecker3)));
            if ((temp95 == 0)) {
                this.Manager.Comment("reaching state \'S1377\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1378\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1379\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1380\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1381\'");
                int temp93 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker4)));
                if ((temp93 == 0)) {
                    ResilientHandleBasicTestCaseS108();
                    goto label81;
                }
                if ((temp93 == 1)) {
                    ResilientHandleBasicTestCaseS121();
                    goto label81;
                }
                if ((temp93 == 2)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label81;
                }
                if ((temp93 == 3)) {
                    this.Manager.Comment("reaching state \'S1382\'");
                    int temp92 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker90)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker91)));
                    if ((temp92 == 0)) {
                        this.Manager.Comment("reaching state \'S1383\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1384\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1385\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1386\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1387\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1375ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1388\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1375ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label80;
                    }
                    if ((temp92 == 1)) {
                        ResilientHandleBasicTestCaseS1389();
                        goto label80;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1382\'.");
                label80:
;
                    goto label81;
                }
                if ((temp93 == 4)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label81;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker4)));
            label81:
;
                goto label83;
            }
            if ((temp95 == 1)) {
                this.Manager.Comment("reaching state \'S1390\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1391\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1392\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1393\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1394\'");
                int temp94 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker7)));
                if ((temp94 == 0)) {
                    ResilientHandleBasicTestCaseS1268();
                    goto label82;
                }
                if ((temp94 == 1)) {
                    ResilientHandleBasicTestCaseS1281();
                    goto label82;
                }
                if ((temp94 == 2)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label82;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker7)));
            label82:
;
                goto label83;
            }
            if ((temp95 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label83;
            }
            if ((temp95 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label83;
            }
            throw new InvalidOperationException("never reached");
        label83:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1375ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1376");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1381");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1381");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1381");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1381");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1381");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1381");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1381");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1381");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker90() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1375ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1387");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker91() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1389() {
            this.Manager.Comment("reaching state \'S1389\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS378();
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1381");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1381");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1375ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1376");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1394");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1394");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1394");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1394");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1375IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1394");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1394");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1375ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1376");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1375ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1376");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1395
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1395() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1395");
            this.Manager.Comment("reaching state \'S1395\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp96;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp96);
            this.Manager.AddReturn(ReadConfigInfo, null, temp96);
            this.Manager.Comment("reaching state \'S1396\'");
            int temp99 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1395ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1395ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1395ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1395ReadConfigChecker3)));
            if ((temp99 == 0)) {
                this.Manager.Comment("reaching state \'S1397\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1398\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1399\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1400\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1401\'");
                int temp97 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker4)));
                if ((temp97 == 0)) {
                    ResilientHandleBasicTestCaseS108();
                    goto label84;
                }
                if ((temp97 == 1)) {
                    ResilientHandleBasicTestCaseS121();
                    goto label84;
                }
                if ((temp97 == 2)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label84;
                }
                if ((temp97 == 3)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label84;
                }
                if ((temp97 == 4)) {
                    ResilientHandleBasicTestCaseS95();
                    goto label84;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker4)));
            label84:
;
                goto label86;
            }
            if ((temp99 == 1)) {
                this.Manager.Comment("reaching state \'S1402\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1403\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1404\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1405\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1406\'");
                int temp98 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker6)));
                if ((temp98 == 0)) {
                    ResilientHandleBasicTestCaseS51();
                    goto label85;
                }
                if ((temp98 == 1)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label85;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker6)));
            label85:
;
                goto label86;
            }
            if ((temp99 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label86;
            }
            if ((temp99 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label86;
            }
            throw new InvalidOperationException("never reached");
        label86:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1395ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1396");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1401");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1401");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1401");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1401");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1401");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1401");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1401");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1401");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1401");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1401");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1395ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1396");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1406");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1406");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1395IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1406");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1406");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1395ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1396");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1395ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1396");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1407
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1407() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1407");
            this.Manager.Comment("reaching state \'S1407\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp100;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp100);
            this.Manager.AddReturn(ReadConfigInfo, null, temp100);
            this.Manager.Comment("reaching state \'S1408\'");
            int temp103 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1407ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1407ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1407ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1407ReadConfigChecker3)));
            if ((temp103 == 0)) {
                this.Manager.Comment("reaching state \'S1409\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1410\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1411\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1412\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1413\'");
                int temp101 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker3)));
                if ((temp101 == 0)) {
                    ResilientHandleBasicTestCaseS1301();
                    goto label87;
                }
                if ((temp101 == 1)) {
                    ResilientHandleBasicTestCaseS1313();
                    goto label87;
                }
                if ((temp101 == 2)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label87;
                }
                if ((temp101 == 3)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label87;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker3)));
            label87:
;
                goto label89;
            }
            if ((temp103 == 1)) {
                this.Manager.Comment("reaching state \'S1414\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1415\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1416\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1417\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1418\'");
                int temp102 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker6)));
                if ((temp102 == 0)) {
                    ResilientHandleBasicTestCaseS1268();
                    goto label88;
                }
                if ((temp102 == 1)) {
                    ResilientHandleBasicTestCaseS1281();
                    goto label88;
                }
                if ((temp102 == 2)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label88;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker6)));
            label88:
;
                goto label89;
            }
            if ((temp103 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label89;
            }
            if ((temp103 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label89;
            }
            throw new InvalidOperationException("never reached");
        label89:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1407ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1408");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1413");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1413");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1413");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1413");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1413");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1413");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1413");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1413");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1407ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1408");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1418");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1418");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1418");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1418");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1407IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1418");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1418");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1407ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1408");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1407ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1408");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1419
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1419() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1419");
            this.Manager.Comment("reaching state \'S1419\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp104;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp104);
            this.Manager.AddReturn(ReadConfigInfo, null, temp104);
            this.Manager.Comment("reaching state \'S1420\'");
            int temp108 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1419ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1419ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1419ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1419ReadConfigChecker3)));
            if ((temp108 == 0)) {
                this.Manager.Comment("reaching state \'S1421\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1422\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1423\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1424\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1425\'");
                int temp105 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker3)));
                if ((temp105 == 0)) {
                    ResilientHandleBasicTestCaseS1301();
                    goto label90;
                }
                if ((temp105 == 1)) {
                    ResilientHandleBasicTestCaseS1313();
                    goto label90;
                }
                if ((temp105 == 2)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label90;
                }
                if ((temp105 == 3)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label90;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker3)));
            label90:
;
                goto label93;
            }
            if ((temp108 == 1)) {
                this.Manager.Comment("reaching state \'S1426\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1427\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1428\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1429\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1430\'");
                int temp107 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker6)));
                if ((temp107 == 0)) {
                    ResilientHandleBasicTestCaseS1281();
                    goto label92;
                }
                if ((temp107 == 1)) {
                    this.Manager.Comment("reaching state \'S1431\'");
                    int temp106 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker92)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker93)));
                    if ((temp106 == 0)) {
                        this.Manager.Comment("reaching state \'S1432\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1433\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1434\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1435\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1436\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1419ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1437\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1419ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label91;
                    }
                    if ((temp106 == 1)) {
                        this.Manager.Comment("reaching state \'S1438\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                                "e the Open as specified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                        this.Manager.AddReturn(DisconnectInfo, null);
                        ResilientHandleBasicTestCaseS1244();
                        goto label91;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1431\'.");
                label91:
;
                    goto label92;
                }
                if ((temp107 == 2)) {
                    ResilientHandleBasicTestCaseS64();
                    goto label92;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker6)));
            label92:
;
                goto label93;
            }
            if ((temp108 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label93;
            }
            if ((temp108 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label93;
            }
            throw new InvalidOperationException("never reached");
        label93:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1419ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1420");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1425");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1425");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1425");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1425");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1425");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1425");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1425");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1425");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1419ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1420");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1430");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1430");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1430");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1430");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker92() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1419ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1436");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker93() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1419IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1430");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1430");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1419ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1420");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1419ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1420");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1439
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1439() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1439");
            this.Manager.Comment("reaching state \'S1439\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp109;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp109);
            this.Manager.AddReturn(ReadConfigInfo, null, temp109);
            this.Manager.Comment("reaching state \'S1440\'");
            int temp116 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1439ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1439ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1439ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1439ReadConfigChecker3)));
            if ((temp116 == 0)) {
                this.Manager.Comment("reaching state \'S1441\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1442\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1443\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1444\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1445\'");
                int temp113 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker4)));
                if ((temp113 == 0)) {
                    this.Manager.Comment("reaching state \'S1446\'");
                    int temp110 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker94)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker95)));
                    if ((temp110 == 0)) {
                        this.Manager.Comment("reaching state \'S1447\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1448\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1449\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1450\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1451\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1452\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label94;
                    }
                    if ((temp110 == 1)) {
                        ResilientHandleBasicTestCaseS1453();
                        goto label94;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1446\'.");
                label94:
;
                    goto label97;
                }
                if ((temp113 == 1)) {
                    this.Manager.Comment("reaching state \'S1454\'");
                    int temp111 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker96)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker97)));
                    if ((temp111 == 0)) {
                        this.Manager.Comment("reaching state \'S1455\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1456\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1457\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1458\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1459\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1460\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label95;
                    }
                    if ((temp111 == 1)) {
                        this.Manager.Comment("reaching state \'S1461\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1462\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1463\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1464\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1465\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S1466\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label95;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1454\'.");
                label95:
;
                    goto label97;
                }
                if ((temp113 == 2)) {
                    ResilientHandleBasicTestCaseS1467();
                    goto label97;
                }
                if ((temp113 == 3)) {
                    ResilientHandleBasicTestCaseS82();
                    goto label97;
                }
                if ((temp113 == 4)) {
                    ResilientHandleBasicTestCaseS95();
                    goto label97;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker4)));
            label97:
;
                goto label100;
            }
            if ((temp116 == 1)) {
                this.Manager.Comment("reaching state \'S1480\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1481\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1482\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1483\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1484\'");
                int temp115 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker9)));
                if ((temp115 == 0)) {
                    this.Manager.Comment("reaching state \'S1485\'");
                    int temp114 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker100)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker101)));
                    if ((temp114 == 0)) {
                        this.Manager.Comment("reaching state \'S1486\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1487\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1488\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1489\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1490\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker5))) != -1)) {
                            this.Manager.Comment("reaching state \'S1491\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker5)));
                        }
                        goto label98;
                    }
                    if ((temp114 == 1)) {
                        this.Manager.Comment("reaching state \'S1492\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1493\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1494\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1495\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1496\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker6))) != -1)) {
                            this.Manager.Comment("reaching state \'S1497\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker6)));
                        }
                        goto label98;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1485\'.");
                label98:
;
                    goto label99;
                }
                if ((temp115 == 1)) {
                    ResilientHandleBasicTestCaseS241();
                    goto label99;
                }
                if ((temp115 == 2)) {
                    ResilientHandleBasicTestCaseS254();
                    goto label99;
                }
                if ((temp115 == 3)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label99;
                }
                if ((temp115 == 4)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label99;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker9)));
            label99:
;
                goto label100;
            }
            if ((temp116 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label100;
            }
            if ((temp116 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label100;
            }
            throw new InvalidOperationException("never reached");
        label100:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1439ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1440");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1445");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1445");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker94() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1451");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker95() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1453() {
            this.Manager.Comment("reaching state \'S1453\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS391();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1445");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1445");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker96() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1459");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker97() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1465");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1445");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1445");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1467() {
            this.Manager.Comment("reaching state \'S1467\'");
            int temp112 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker98)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker99)));
            if ((temp112 == 0)) {
                this.Manager.Comment("reaching state \'S1468\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1469\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1470\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1471\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1472\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S1473\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker3)));
                }
                goto label96;
            }
            if ((temp112 == 1)) {
                this.Manager.Comment("reaching state \'S1474\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1475\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1476\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1477\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1478\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker4))) != -1)) {
                    this.Manager.Comment("reaching state \'S1479\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker4)));
                }
                goto label96;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1467\'.");
        label96:
;
        }
        
        private void PreConstraintChecker98() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1472");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker99() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1478");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1445");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1445");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1445");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1445");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1440");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1484");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1484");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker100() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1490");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker101() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1439ReEstablishResilientOpenResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1496");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1484");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1484");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1484");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1484");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1484");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1484");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439IoCtlResiliencyResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1484");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1484");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1439ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1440");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1439ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1440");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S1498
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1498() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1498");
            this.Manager.Comment("reaching state \'S1498\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp117;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp117);
            this.Manager.AddReturn(ReadConfigInfo, null, temp117);
            this.Manager.Comment("reaching state \'S1499\'");
            int temp127 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1498ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1498ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1498ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1498ReadConfigChecker3)));
            if ((temp127 == 0)) {
                this.Manager.Comment("reaching state \'S1500\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1501\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1502\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1503\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1504\'");
                int temp121 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker2)));
                if ((temp121 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label104;
                }
                if ((temp121 == 1)) {
                    ResilientHandleBasicTestCaseS648();
                    goto label104;
                }
                if ((temp121 == 2)) {
                    ResilientHandleBasicTestCaseS661();
                    goto label104;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker2)));
            label104:
;
                goto label110;
            }
            if ((temp127 == 1)) {
                this.Manager.Comment("reaching state \'S1505\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1506\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1507\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1508\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1509\'");
                int temp125 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker5)));
                if ((temp125 == 0)) {
                    ResilientHandleBasicTestCaseS1510();
                    goto label108;
                }
                if ((temp125 == 1)) {
                    ResilientHandleBasicTestCaseS1523();
                    goto label108;
                }
                if ((temp125 == 2)) {
                    this.Manager.Comment("reaching state \'S1536\'");
                    int temp124 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker112)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker113)));
                    if ((temp124 == 0)) {
                        this.Manager.Comment("reaching state \'S1537\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1538\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1539\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1540\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1541\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker10))) != -1)) {
                            this.Manager.Comment("reaching state \'S1542\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker10)));
                        }
                        goto label107;
                    }
                    if ((temp124 == 1)) {
                        this.Manager.Comment("reaching state \'S1543\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1544\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1545\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1546\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1547\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker11))) != -1)) {
                            this.Manager.Comment("reaching state \'S1548\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker11)));
                        }
                        goto label107;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1536\'.");
                label107:
;
                    goto label108;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker5)));
            label108:
;
                goto label110;
            }
            if ((temp127 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label110;
            }
            if ((temp127 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label110;
            }
            throw new InvalidOperationException("never reached");
        label110:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1498ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1499");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1504");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1504");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS516() {
            this.Manager.Comment("reaching state \'S516\'");
            int temp118 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker102)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker103)));
            if ((temp118 == 0)) {
                this.Manager.Comment("reaching state \'S517\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S518\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S519\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S520\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S521\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker))) != -1)) {
                    this.Manager.Comment("reaching state \'S522\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker)));
                }
                goto label101;
            }
            if ((temp118 == 1)) {
                this.Manager.Comment("reaching state \'S523\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S524\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S525\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S526\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S527\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    this.Manager.Comment("reaching state \'S528\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker1)));
                }
                goto label101;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S516\'.");
        label101:
;
        }
        
        private void PreConstraintChecker102() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S521");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker103() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S527");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1504");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1504");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS648() {
            this.Manager.Comment("reaching state \'S648\'");
            int temp119 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker104)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker105)));
            if ((temp119 == 0)) {
                this.Manager.Comment("reaching state \'S649\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S650\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S651\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S652\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S653\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S654\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker2)));
                }
                goto label102;
            }
            if ((temp119 == 1)) {
                this.Manager.Comment("reaching state \'S655\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S656\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S657\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S658\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S659\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S660\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker3)));
                }
                goto label102;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S648\'.");
        label102:
;
        }
        
        private void PreConstraintChecker104() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S653");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker105() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S659");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1504");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1504");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS661() {
            this.Manager.Comment("reaching state \'S661\'");
            int temp120 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker106)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker107)));
            if ((temp120 == 0)) {
                this.Manager.Comment("reaching state \'S662\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S663\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S664\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S665\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S666\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker4))) != -1)) {
                    this.Manager.Comment("reaching state \'S667\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker4)));
                }
                goto label103;
            }
            if ((temp120 == 1)) {
                this.Manager.Comment("reaching state \'S668\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S669\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S670\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S671\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S672\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker5))) != -1)) {
                    this.Manager.Comment("reaching state \'S673\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker5)));
                }
                goto label103;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S661\'.");
        label103:
;
        }
        
        private void PreConstraintChecker106() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S666");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker107() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S672");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1499");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1509");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1509");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1510() {
            this.Manager.Comment("reaching state \'S1510\'");
            int temp122 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker108)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker109)));
            if ((temp122 == 0)) {
                this.Manager.Comment("reaching state \'S1511\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1512\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1513\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1514\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1515\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker6))) != -1)) {
                    this.Manager.Comment("reaching state \'S1516\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker6)));
                }
                goto label105;
            }
            if ((temp122 == 1)) {
                this.Manager.Comment("reaching state \'S1517\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1518\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1519\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1520\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1521\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker7))) != -1)) {
                    this.Manager.Comment("reaching state \'S1522\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker7)));
                }
                goto label105;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1510\'.");
        label105:
;
        }
        
        private void PreConstraintChecker108() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb30 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1515");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker109() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb30 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1521");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1509");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1509");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1523() {
            this.Manager.Comment("reaching state \'S1523\'");
            int temp123 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker110)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker111)));
            if ((temp123 == 0)) {
                this.Manager.Comment("reaching state \'S1524\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S1525\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S1526\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1527\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1528\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker8))) != -1)) {
                    this.Manager.Comment("reaching state \'S1529\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker8)));
                }
                goto label106;
            }
            if ((temp123 == 1)) {
                this.Manager.Comment("reaching state \'S1530\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1531\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1532\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1533\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1534\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker9))) != -1)) {
                    this.Manager.Comment("reaching state \'S1535\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker9)));
                }
                goto label106;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1523\'.");
        label106:
;
        }
        
        private void PreConstraintChecker110() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1528");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker111() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1534");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1509");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1509");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker112() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker10(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1541");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker113() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReEstablishResilientOpenResponseChecker11(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1547");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1499");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1498ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1499");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS236() {
            this.Manager.Comment("reaching state \'S236\'");
            this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
            this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
            this.Manager.Comment("reaching state \'S237\'");
            this.Manager.Comment("checking step \'return PrepareOpen\'");
            this.Manager.Comment("reaching state \'S238\'");
            this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                    "Timeout)\'");
            this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
            this.Manager.Comment("reaching state \'S239\'");
            this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
            this.Manager.Comment("reaching state \'S240\'");
            int temp126 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker9)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker10)));
            if ((temp126 == 0)) {
                ResilientHandleBasicTestCaseS241();
                goto label109;
            }
            if ((temp126 == 1)) {
                ResilientHandleBasicTestCaseS254();
                goto label109;
            }
            if ((temp126 == 2)) {
                ResilientHandleBasicTestCaseS267();
                goto label109;
            }
            if ((temp126 == 3)) {
                ResilientHandleBasicTestCaseS280();
                goto label109;
            }
            if ((temp126 == 4)) {
                ResilientHandleBasicTestCaseS293();
                goto label109;
            }
            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker7)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker8)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker9)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker10)));
        label109:
;
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S240");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S240");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S240");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S240");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S240");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S240");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S240");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S240");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1498IoCtlResiliencyResponseChecker10(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S240");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S240");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        #endregion
        
        #region Test Starting in S1549
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1549() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1549");
            this.Manager.Comment("reaching state \'S1549\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp128;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp128);
            this.Manager.AddReturn(ReadConfigInfo, null, temp128);
            this.Manager.Comment("reaching state \'S1550\'");
            int temp136 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1549ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1549ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1549ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1549ReadConfigChecker3)));
            if ((temp136 == 0)) {
                this.Manager.Comment("reaching state \'S1551\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1552\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1553\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1554\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1555\'");
                int temp132 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker2)));
                if ((temp132 == 0)) {
                    this.Manager.Comment("reaching state \'S1556\'");
                    int temp129 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker114)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker115)));
                    if ((temp129 == 0)) {
                        this.Manager.Comment("reaching state \'S1557\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1558\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1559\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1560\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1561\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1562\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label111;
                    }
                    if ((temp129 == 1)) {
                        this.Manager.Comment("reaching state \'S1563\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1564\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1565\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1566\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1567\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1568\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label111;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1556\'.");
                label111:
;
                    goto label114;
                }
                if ((temp132 == 1)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label114;
                }
                if ((temp132 == 2)) {
                    ResilientHandleBasicTestCaseS872();
                    goto label114;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker2)));
            label114:
;
                goto label118;
            }
            if ((temp136 == 1)) {
                this.Manager.Comment("reaching state \'S1569\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1570\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1571\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1572\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1573\'");
                int temp135 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker4)));
                if ((temp135 == 0)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label117;
                }
                if ((temp135 == 1)) {
                    ResilientHandleBasicTestCaseS1587();
                    goto label117;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker4)));
            label117:
;
                goto label118;
            }
            if ((temp136 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label118;
            }
            if ((temp136 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label118;
            }
            throw new InvalidOperationException("never reached");
        label118:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1549ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1550");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1555");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1555");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker114() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1561");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker115() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1567");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1555");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1555");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS211() {
            this.Manager.Comment("reaching state \'S211\'");
            int temp130 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker116)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker117)));
            if ((temp130 == 0)) {
                this.Manager.Comment("reaching state \'S212\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S213\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S214\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S215\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S216\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S217\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker2)));
                }
                goto label112;
            }
            if ((temp130 == 1)) {
                this.Manager.Comment("reaching state \'S218\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S219\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S220\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S221\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S222\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S223\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker3)));
                }
                goto label112;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S211\'.");
        label112:
;
        }
        
        private void PreConstraintChecker116() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S216");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker117() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S222");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1555");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1555");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS872() {
            this.Manager.Comment("reaching state \'S872\'");
            int temp131 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker118)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker119)));
            if ((temp131 == 0)) {
                this.Manager.Comment("reaching state \'S873\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S874\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S875\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S876\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S877\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker4))) != -1)) {
                    this.Manager.Comment("reaching state \'S878\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker4)));
                }
                goto label113;
            }
            if ((temp131 == 1)) {
                this.Manager.Comment("reaching state \'S879\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S880\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S881\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S882\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S883\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker5))) != -1)) {
                    this.Manager.Comment("reaching state \'S884\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker5)));
                }
                goto label113;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S872\'.");
        label113:
;
        }
        
        private void PreConstraintChecker118() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S877");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker119() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S883");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1549ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1550");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1573");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1573");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1574() {
            this.Manager.Comment("reaching state \'S1574\'");
            int temp133 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker120)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker121)));
            if ((temp133 == 0)) {
                this.Manager.Comment("reaching state \'S1575\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1576\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1577\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1578\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1579\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker6))) != -1)) {
                    this.Manager.Comment("reaching state \'S1580\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker6)));
                }
                goto label115;
            }
            if ((temp133 == 1)) {
                this.Manager.Comment("reaching state \'S1581\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S1582\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1583\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S1584\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1585\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker7))) != -1)) {
                    this.Manager.Comment("reaching state \'S1586\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker7)));
                }
                goto label115;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1574\'.");
        label115:
;
        }
        
        private void PreConstraintChecker120() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1579");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker121() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1585");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1549IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1573");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1573");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1587() {
            this.Manager.Comment("reaching state \'S1587\'");
            int temp134 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker122)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker123)));
            if ((temp134 == 0)) {
                this.Manager.Comment("reaching state \'S1588\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S1589\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1590\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S1591\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1592\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker8))) != -1)) {
                    ResilientHandleBasicTestCaseS1593();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker8)));
                }
                goto label116;
            }
            if ((temp134 == 1)) {
                ResilientHandleBasicTestCaseS1594();
                goto label116;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1587\'.");
        label116:
;
        }
        
        private void PreConstraintChecker122() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker8(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1592");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1593() {
            this.Manager.Comment("reaching state \'S1593\'");
        }
        
        private void PreConstraintChecker123() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1594() {
            this.Manager.Comment("reaching state \'S1594\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS1595();
        }
        
        private void ResilientHandleBasicTestCaseS1595() {
            this.Manager.Comment("reaching state \'S1595\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS1549DisconnectChecker)));
            this.Manager.Comment("reaching state \'S1596\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S1597\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S1598\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker9))) != -1)) {
                this.Manager.Comment("reaching state \'S1599\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker9)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS1549DisconnectChecker() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReEstablishResilientOpenResponseChecker9(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1598");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1549ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1550");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1549ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1550");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1600
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1600() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1600");
            this.Manager.Comment("reaching state \'S1600\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp137;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp137);
            this.Manager.AddReturn(ReadConfigInfo, null, temp137);
            this.Manager.Comment("reaching state \'S1601\'");
            int temp141 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1600ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1600ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1600ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1600ReadConfigChecker3)));
            if ((temp141 == 0)) {
                this.Manager.Comment("reaching state \'S1602\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1603\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1604\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1605\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1606\'");
                int temp139 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker2)));
                if ((temp139 == 0)) {
                    ResilientHandleBasicTestCaseS1130();
                    goto label120;
                }
                if ((temp139 == 1)) {
                    this.Manager.Comment("reaching state \'S1607\'");
                    int temp138 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker124)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker125)));
                    if ((temp138 == 0)) {
                        this.Manager.Comment("reaching state \'S1608\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1609\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1610\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1611\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1612\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1600ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1613\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1600ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label119;
                    }
                    if ((temp138 == 1)) {
                        this.Manager.Comment("reaching state \'S1614\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1615\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1616\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1617\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1618\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1600ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1619\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1600ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label119;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1607\'.");
                label119:
;
                    goto label120;
                }
                if ((temp139 == 2)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label120;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker2)));
            label120:
;
                goto label122;
            }
            if ((temp141 == 1)) {
                this.Manager.Comment("reaching state \'S1620\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1621\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1622\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1623\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1624\'");
                int temp140 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker4)));
                if ((temp140 == 0)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label121;
                }
                if ((temp140 == 1)) {
                    ResilientHandleBasicTestCaseS1587();
                    goto label121;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker4)));
            label121:
;
                goto label122;
            }
            if ((temp141 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label122;
            }
            if ((temp141 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label122;
            }
            throw new InvalidOperationException("never reached");
        label122:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1600ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1601");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1606");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1606");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1606");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1606");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker124() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1600ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1612");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker125() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1600ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1618");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1606");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1606");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1600ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1601");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1624");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1624");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1600IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1624");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1624");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1600ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1601");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1600ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1601");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1625
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1625() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1625");
            this.Manager.Comment("reaching state \'S1625\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp142;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp142);
            this.Manager.AddReturn(ReadConfigInfo, null, temp142);
            this.Manager.Comment("reaching state \'S1626\'");
            int temp150 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1625ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1625ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1625ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1625ReadConfigChecker3)));
            if ((temp150 == 0)) {
                this.Manager.Comment("reaching state \'S1627\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1628\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1629\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1630\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1631\'");
                int temp145 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker2)));
                if ((temp145 == 0)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label125;
                }
                if ((temp145 == 1)) {
                    this.Manager.Comment("reaching state \'S1632\'");
                    int temp143 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker126)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker127)));
                    if ((temp143 == 0)) {
                        this.Manager.Comment("reaching state \'S1633\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1634\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1635\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1636\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1637\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1638\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label123;
                    }
                    if ((temp143 == 1)) {
                        this.Manager.Comment("reaching state \'S1639\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1640\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1641\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1642\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1643\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1644\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label123;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1632\'.");
                label123:
;
                    goto label125;
                }
                if ((temp145 == 2)) {
                    this.Manager.Comment("reaching state \'S1645\'");
                    int temp144 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker128)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker129)));
                    if ((temp144 == 0)) {
                        this.Manager.Comment("reaching state \'S1646\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1647\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1648\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1649\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1650\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S1651\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label124;
                    }
                    if ((temp144 == 1)) {
                        this.Manager.Comment("reaching state \'S1652\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                                "e the Open as specified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                        this.Manager.AddReturn(DisconnectInfo, null);
                        ResilientHandleBasicTestCaseS1595();
                        goto label124;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1645\'.");
                label124:
;
                    goto label125;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker2)));
            label125:
;
                goto label130;
            }
            if ((temp150 == 1)) {
                ResilientHandleBasicTestCaseS1653();
                goto label130;
            }
            if ((temp150 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label130;
            }
            if ((temp150 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label130;
            }
            throw new InvalidOperationException("never reached");
        label130:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1625ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1626");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1631");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1631");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1631");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1631");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker126() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb30 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1637");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker127() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb30 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1643");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1631");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1631");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker128() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1625ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1650");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker129() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1625ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1626");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1653() {
            this.Manager.Comment("reaching state \'S1653\'");
            this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
            this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
            this.Manager.Comment("reaching state \'S1654\'");
            this.Manager.Comment("checking step \'return PrepareOpen\'");
            this.Manager.Comment("reaching state \'S1655\'");
            this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                    "Timeout)\'");
            this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
            this.Manager.Comment("reaching state \'S1656\'");
            this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
            this.Manager.Comment("reaching state \'S1657\'");
            int temp149 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker7)));
            if ((temp149 == 0)) {
                ResilientHandleBasicTestCaseS134();
                goto label129;
            }
            if ((temp149 == 1)) {
                ResilientHandleBasicTestCaseS1467();
                goto label129;
            }
            if ((temp149 == 2)) {
                this.Manager.Comment("reaching state \'S1658\'");
                int temp146 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker130)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker131)));
                if ((temp146 == 0)) {
                    ResilientHandleBasicTestCaseS102();
                    goto label126;
                }
                if ((temp146 == 1)) {
                    ResilientHandleBasicTestCaseS1389();
                    goto label126;
                }
                this.Manager.Assert(false, "reached non-accepting end state \'S1658\'.");
            label126:
;
                goto label129;
            }
            if ((temp149 == 3)) {
                this.Manager.Comment("reaching state \'S1659\'");
                int temp147 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker132)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker133)));
                if ((temp147 == 0)) {
                    ResilientHandleBasicTestCaseS128();
                    goto label127;
                }
                if ((temp147 == 1)) {
                    ResilientHandleBasicTestCaseS1453();
                    goto label127;
                }
                this.Manager.Assert(false, "reached non-accepting end state \'S1659\'.");
            label127:
;
                goto label129;
            }
            if ((temp149 == 4)) {
                ResilientHandleBasicTestCaseS396();
                goto label129;
            }
            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker7)));
        label129:
;
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1657");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1657");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1657");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1657");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1657");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1657");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker130() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void PreConstraintChecker131() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1657");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1657");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker132() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void PreConstraintChecker133() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1625IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1657");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1657");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS396() {
            this.Manager.Comment("reaching state \'S396\'");
            int temp148 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker134)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker135)));
            if ((temp148 == 0)) {
                ResilientHandleBasicTestCaseS397();
                goto label128;
            }
            if ((temp148 == 1)) {
                ResilientHandleBasicTestCaseS89();
                goto label128;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S396\'.");
        label128:
;
        }
        
        private void PreConstraintChecker134() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker135() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1625ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1626");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1625ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1626");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S165
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS165() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS165");
            this.Manager.Comment("reaching state \'S165\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp151;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp151);
            this.Manager.AddReturn(ReadConfigInfo, null, temp151);
            this.Manager.Comment("reaching state \'S166\'");
            int temp157 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS165ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS165ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS165ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS165ReadConfigChecker3)));
            if ((temp157 == 0)) {
                this.Manager.Comment("reaching state \'S167\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S168\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S169\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S170\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S171\'");
                int temp154 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker1)));
                if ((temp154 == 0)) {
                    this.Manager.Comment("reaching state \'S172\'");
                    int temp152 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker136)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker137)));
                    if ((temp152 == 0)) {
                        this.Manager.Comment("reaching state \'S173\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S174\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S175\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S176\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S177\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker))) != -1)) {
                            ResilientHandleBasicTestCaseS178();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label131;
                    }
                    if ((temp152 == 1)) {
                        ResilientHandleBasicTestCaseS179();
                        goto label131;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S172\'.");
                label131:
;
                    goto label133;
                }
                if ((temp154 == 1)) {
                    ResilientHandleBasicTestCaseS180();
                    goto label133;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker1)));
            label133:
;
                goto label136;
            }
            if ((temp157 == 1)) {
                this.Manager.Comment("reaching state \'S193\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S194\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S195\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S196\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S197\'");
                int temp156 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker3)));
                if ((temp156 == 0)) {
                    this.Manager.Comment("reaching state \'S198\'");
                    int temp155 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker140)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker141)));
                    if ((temp155 == 0)) {
                        this.Manager.Comment("reaching state \'S199\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S200\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S201\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S202\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S203\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker3))) != -1)) {
                            this.Manager.Comment("reaching state \'S204\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker3)));
                        }
                        goto label134;
                    }
                    if ((temp155 == 1)) {
                        this.Manager.Comment("reaching state \'S205\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S206\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S207\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S208\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S209\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker4))) != -1)) {
                            ResilientHandleBasicTestCaseS210();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker4)));
                        }
                        goto label134;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S198\'.");
                label134:
;
                    goto label135;
                }
                if ((temp156 == 1)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label135;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker3)));
            label135:
;
                goto label136;
            }
            if ((temp157 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label136;
            }
            if ((temp157 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label136;
            }
            throw new InvalidOperationException("never reached");
        label136:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS165ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S166");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S171");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S171");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker136() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S177");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS178() {
            this.Manager.Comment("reaching state \'S178\'");
        }
        
        private void PreConstraintChecker137() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS179() {
            this.Manager.Comment("reaching state \'S179\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS22();
        }
        
        private void ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S171");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S171");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS180() {
            this.Manager.Comment("reaching state \'S180\'");
            int temp153 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker138)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker139)));
            if ((temp153 == 0)) {
                this.Manager.Comment("reaching state \'S181\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S182\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S183\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S184\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S185\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    this.Manager.Comment("reaching state \'S186\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker1)));
                }
                goto label132;
            }
            if ((temp153 == 1)) {
                this.Manager.Comment("reaching state \'S187\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S188\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S189\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S190\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S191\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S192\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker2)));
                }
                goto label132;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S180\'.");
        label132:
;
        }
        
        private void PreConstraintChecker138() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S185");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker139() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S191");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS165ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S166");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S197");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S197");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker140() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S203");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker141() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS165ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S209");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS210() {
            this.Manager.Comment("reaching state \'S210\'");
        }
        
        private void ResilientHandleBasicTestCaseS165IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S197");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S197");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS165ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S166");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS165ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S166");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1660
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1660() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1660");
            this.Manager.Comment("reaching state \'S1660\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp158;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp158);
            this.Manager.AddReturn(ReadConfigInfo, null, temp158);
            this.Manager.Comment("reaching state \'S1661\'");
            int temp160 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1660ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1660ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1660ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1660ReadConfigChecker3)));
            if ((temp160 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label138;
            }
            if ((temp160 == 1)) {
                this.Manager.Comment("reaching state \'S1662\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1663\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1664\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1665\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1666\'");
                int temp159 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker2)));
                if ((temp159 == 0)) {
                    ResilientHandleBasicTestCaseS1510();
                    goto label137;
                }
                if ((temp159 == 1)) {
                    ResilientHandleBasicTestCaseS1523();
                    goto label137;
                }
                if ((temp159 == 2)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label137;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker2)));
            label137:
;
                goto label138;
            }
            if ((temp160 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label138;
            }
            if ((temp160 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label138;
            }
            throw new InvalidOperationException("never reached");
        label138:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1660ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1661");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1660ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1661");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1666");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1666");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1666");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1666");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1660IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1666");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1666");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1660ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1661");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1660ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1661");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1667
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1667() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1667");
            this.Manager.Comment("reaching state \'S1667\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp161;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp161);
            this.Manager.AddReturn(ReadConfigInfo, null, temp161);
            this.Manager.Comment("reaching state \'S1668\'");
            int temp164 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1667ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1667ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1667ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1667ReadConfigChecker3)));
            if ((temp164 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label141;
            }
            if ((temp164 == 1)) {
                this.Manager.Comment("reaching state \'S1669\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1670\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1671\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1672\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1673\'");
                int temp163 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1667IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1667IoCtlResiliencyResponseChecker1)));
                if ((temp163 == 0)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label140;
                }
                if ((temp163 == 1)) {
                    this.Manager.Comment("reaching state \'S1674\'");
                    int temp162 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker142)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker143)));
                    if ((temp162 == 0)) {
                        ResilientHandleBasicTestCaseS1594();
                        goto label139;
                    }
                    if ((temp162 == 1)) {
                        this.Manager.Comment("reaching state \'S1675\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S1676\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S1677\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1678\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1679\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1667ReEstablishResilientOpenResponseChecker))) != -1)) {
                            ResilientHandleBasicTestCaseS1593();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1667ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label139;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1674\'.");
                label139:
;
                    goto label140;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1667IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1667IoCtlResiliencyResponseChecker1)));
            label140:
;
                goto label141;
            }
            if ((temp164 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label141;
            }
            if ((temp164 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label141;
            }
            throw new InvalidOperationException("never reached");
        label141:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1667ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1668");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1667ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1668");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1667IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1673");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1673");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1667IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1673");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1673");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker142() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker143() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1667ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1679");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1667ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1668");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1667ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1668");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1680
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1680() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1680");
            this.Manager.Comment("reaching state \'S1680\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp165;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp165);
            this.Manager.AddReturn(ReadConfigInfo, null, temp165);
            this.Manager.Comment("reaching state \'S1681\'");
            int temp168 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1680ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1680ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1680ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1680ReadConfigChecker3)));
            if ((temp168 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label144;
            }
            if ((temp168 == 1)) {
                this.Manager.Comment("reaching state \'S1682\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1683\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1684\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1685\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1686\'");
                int temp167 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1680IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1680IoCtlResiliencyResponseChecker1)));
                if ((temp167 == 0)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label143;
                }
                if ((temp167 == 1)) {
                    this.Manager.Comment("reaching state \'S1687\'");
                    int temp166 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker144)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker145)));
                    if ((temp166 == 0)) {
                        this.Manager.Comment("reaching state \'S1688\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1689\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1690\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1691\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1692\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1680ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1693\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1680ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label142;
                    }
                    if ((temp166 == 1)) {
                        this.Manager.Comment("reaching state \'S1694\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1695\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1696\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S1697\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1698\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1680ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1699\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1680ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label142;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1687\'.");
                label142:
;
                    goto label143;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1680IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1680IoCtlResiliencyResponseChecker1)));
            label143:
;
                goto label144;
            }
            if ((temp168 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label144;
            }
            if ((temp168 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label144;
            }
            throw new InvalidOperationException("never reached");
        label144:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1680ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1681");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1680ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1681");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1680IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1686");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1686");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1680IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1686");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1686");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker144() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1680ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1692");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker145() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1680ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1698");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1680ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1681");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1680ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1681");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1700
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1700() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1700");
            this.Manager.Comment("reaching state \'S1700\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp169;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp169);
            this.Manager.AddReturn(ReadConfigInfo, null, temp169);
            this.Manager.Comment("reaching state \'S1701\'");
            int temp171 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1700ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1700ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1700ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1700ReadConfigChecker3)));
            if ((temp171 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label146;
            }
            if ((temp171 == 1)) {
                this.Manager.Comment("reaching state \'S1702\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1703\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1704\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1705\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1706\'");
                int temp170 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker2)));
                if ((temp170 == 0)) {
                    ResilientHandleBasicTestCaseS1510();
                    goto label145;
                }
                if ((temp170 == 1)) {
                    ResilientHandleBasicTestCaseS1523();
                    goto label145;
                }
                if ((temp170 == 2)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label145;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker2)));
            label145:
;
                goto label146;
            }
            if ((temp171 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label146;
            }
            if ((temp171 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label146;
            }
            throw new InvalidOperationException("never reached");
        label146:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1700ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1701");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1700ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1701");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1706");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1706");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1706");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1706");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1700IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1706");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1706");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1700ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1701");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1700ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1701");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1707
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1707() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1707");
            this.Manager.Comment("reaching state \'S1707\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp172;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp172);
            this.Manager.AddReturn(ReadConfigInfo, null, temp172);
            this.Manager.Comment("reaching state \'S1708\'");
            int temp175 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1707ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1707ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1707ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1707ReadConfigChecker3)));
            if ((temp175 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label149;
            }
            if ((temp175 == 1)) {
                this.Manager.Comment("reaching state \'S1709\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1710\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1711\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1712\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1713\'");
                int temp174 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1707IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1707IoCtlResiliencyResponseChecker1)));
                if ((temp174 == 0)) {
                    ResilientHandleBasicTestCaseS1714();
                    goto label148;
                }
                if ((temp174 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label148;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1707IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1707IoCtlResiliencyResponseChecker1)));
            label148:
;
                goto label149;
            }
            if ((temp175 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label149;
            }
            if ((temp175 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label149;
            }
            throw new InvalidOperationException("never reached");
        label149:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1707ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1708");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1707ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1708");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1707IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1713");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1713");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1714() {
            this.Manager.Comment("reaching state \'S1714\'");
            int temp173 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker146)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker147)));
            if ((temp173 == 0)) {
                this.Manager.Comment("reaching state \'S1715\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S1716\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S1717\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S1718\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S1719\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1707ReEstablishResilientOpenResponseChecker))) != -1)) {
                    ResilientHandleBasicTestCaseS178();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1707ReEstablishResilientOpenResponseChecker)));
                }
                goto label147;
            }
            if ((temp173 == 1)) {
                ResilientHandleBasicTestCaseS179();
                goto label147;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S1714\'.");
        label147:
;
        }
        
        private void PreConstraintChecker146() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1707ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1719");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker147() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1707IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1713");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1713");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1707ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1708");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1707ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1708");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1720
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1720() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1720");
            this.Manager.Comment("reaching state \'S1720\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp176;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp176);
            this.Manager.AddReturn(ReadConfigInfo, null, temp176);
            this.Manager.Comment("reaching state \'S1721\'");
            int temp178 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1720ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1720ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1720ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1720ReadConfigChecker3)));
            if ((temp178 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label151;
            }
            if ((temp178 == 1)) {
                this.Manager.Comment("reaching state \'S1722\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1723\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1724\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1725\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1726\'");
                int temp177 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1720IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1720IoCtlResiliencyResponseChecker1)));
                if ((temp177 == 0)) {
                    ResilientHandleBasicTestCaseS1714();
                    goto label150;
                }
                if ((temp177 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label150;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1720IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1720IoCtlResiliencyResponseChecker1)));
            label150:
;
                goto label151;
            }
            if ((temp178 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label151;
            }
            if ((temp178 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label151;
            }
            throw new InvalidOperationException("never reached");
        label151:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1720ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1721");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1720ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1721");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1720IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1726");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1726");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1720IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1726");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1726");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1720ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1721");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1720ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1721");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1727
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1727() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1727");
            this.Manager.Comment("reaching state \'S1727\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp179;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp179);
            this.Manager.AddReturn(ReadConfigInfo, null, temp179);
            this.Manager.Comment("reaching state \'S1728\'");
            int temp182 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1727ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1727ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1727ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1727ReadConfigChecker3)));
            if ((temp182 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label154;
            }
            if ((temp182 == 1)) {
                this.Manager.Comment("reaching state \'S1729\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1730\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1731\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1732\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1733\'");
                int temp181 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1727IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1727IoCtlResiliencyResponseChecker1)));
                if ((temp181 == 0)) {
                    this.Manager.Comment("reaching state \'S1734\'");
                    int temp180 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker148)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker149)));
                    if ((temp180 == 0)) {
                        this.Manager.Comment("reaching state \'S1735\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1736\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1737\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1738\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1739\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1727ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1740\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1727ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label152;
                    }
                    if ((temp180 == 1)) {
                        this.Manager.Comment("reaching state \'S1741\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1742\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1743\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S1744\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1745\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1727ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1746\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1727ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label152;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1734\'.");
                label152:
;
                    goto label153;
                }
                if ((temp181 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label153;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1727IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1727IoCtlResiliencyResponseChecker1)));
            label153:
;
                goto label154;
            }
            if ((temp182 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label154;
            }
            if ((temp182 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label154;
            }
            throw new InvalidOperationException("never reached");
        label154:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1727ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1728");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1727ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1728");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1727IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1733");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1733");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker148() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1727ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S1739");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker149() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1727ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1745");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1727IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1733");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1733");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1727ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1728");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1727ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1728");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1747
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1747() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1747");
            this.Manager.Comment("reaching state \'S1747\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp183;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp183);
            this.Manager.AddReturn(ReadConfigInfo, null, temp183);
            this.Manager.Comment("reaching state \'S1748\'");
            int temp185 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1747ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1747ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1747ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1747ReadConfigChecker3)));
            if ((temp185 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label156;
            }
            if ((temp185 == 1)) {
                this.Manager.Comment("reaching state \'S1749\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1750\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1751\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1752\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1753\'");
                int temp184 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1747IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1747IoCtlResiliencyResponseChecker1)));
                if ((temp184 == 0)) {
                    ResilientHandleBasicTestCaseS1714();
                    goto label155;
                }
                if ((temp184 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label155;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1747IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1747IoCtlResiliencyResponseChecker1)));
            label155:
;
                goto label156;
            }
            if ((temp185 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label156;
            }
            if ((temp185 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label156;
            }
            throw new InvalidOperationException("never reached");
        label156:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1747ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1748");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1747ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1748");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1747IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1753");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1753");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1747IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1753");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1753");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1747ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1748");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1747ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1748");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1754
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1754() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1754");
            this.Manager.Comment("reaching state \'S1754\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp186;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp186);
            this.Manager.AddReturn(ReadConfigInfo, null, temp186);
            this.Manager.Comment("reaching state \'S1755\'");
            int temp189 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1754ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1754ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1754ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1754ReadConfigChecker3)));
            if ((temp189 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label159;
            }
            if ((temp189 == 1)) {
                this.Manager.Comment("reaching state \'S1756\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1757\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1758\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S1759\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1760\'");
                int temp188 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker2)));
                if ((temp188 == 0)) {
                    this.Manager.Comment("reaching state \'S1761\'");
                    int temp187 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker150)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker151)));
                    if ((temp187 == 0)) {
                        this.Manager.Comment("reaching state \'S1762\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1763\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1764\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1765\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1766\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1754ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1767\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1754ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label157;
                    }
                    if ((temp187 == 1)) {
                        this.Manager.Comment("reaching state \'S1768\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                                "e the Open as specified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                        this.Manager.Comment("reaching state \'S1769\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S1770\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1771\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1772\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1754ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1773\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1754ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label157;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1761\'.");
                label157:
;
                    goto label158;
                }
                if ((temp188 == 1)) {
                    ResilientHandleBasicTestCaseS180();
                    goto label158;
                }
                if ((temp188 == 2)) {
                    ResilientHandleBasicTestCaseS20();
                    goto label158;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker2)));
            label158:
;
                goto label159;
            }
            if ((temp189 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label159;
            }
            if ((temp189 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label159;
            }
            throw new InvalidOperationException("never reached");
        label159:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1754ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1755");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1754ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1755");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1760");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1760");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker150() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb30 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1754ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1766");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker151() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb30 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1754ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1772");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1760");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1760");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1754IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1760");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1760");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1754ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1755");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1754ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1755");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1774
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1774() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1774");
            this.Manager.Comment("reaching state \'S1774\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp190;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp190);
            this.Manager.AddReturn(ReadConfigInfo, null, temp190);
            this.Manager.Comment("reaching state \'S1775\'");
            int temp193 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1774ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1774ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1774ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1774ReadConfigChecker3)));
            if ((temp193 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label162;
            }
            if ((temp193 == 1)) {
                this.Manager.Comment("reaching state \'S1776\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1777\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1778\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1779\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1780\'");
                int temp192 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker2)));
                if ((temp192 == 0)) {
                    this.Manager.Comment("reaching state \'S1781\'");
                    int temp191 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker152)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker153)));
                    if ((temp191 == 0)) {
                        this.Manager.Comment("reaching state \'S1782\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1783\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1784\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1785\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1786\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1774ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1787\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1774ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label160;
                    }
                    if ((temp191 == 1)) {
                        this.Manager.Comment("reaching state \'S1788\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1789\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1790\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1791\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1792\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1774ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1793\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1774ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label160;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1781\'.");
                label160:
;
                    goto label161;
                }
                if ((temp192 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label161;
                }
                if ((temp192 == 2)) {
                    ResilientHandleBasicTestCaseS7();
                    goto label161;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker2)));
            label161:
;
                goto label162;
            }
            if ((temp193 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label162;
            }
            if ((temp193 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label162;
            }
            throw new InvalidOperationException("never reached");
        label162:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1774ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1775");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1774ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1775");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1780");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1780");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker152() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1774ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1786");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker153() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1774ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1792");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1780");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1780");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1774IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1780");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1780");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1774ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1775");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1774ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1775");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1794
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1794() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1794");
            this.Manager.Comment("reaching state \'S1794\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp194;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp194);
            this.Manager.AddReturn(ReadConfigInfo, null, temp194);
            this.Manager.Comment("reaching state \'S1795\'");
            int temp196 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1794ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1794ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1794ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1794ReadConfigChecker3)));
            if ((temp196 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label164;
            }
            if ((temp196 == 1)) {
                this.Manager.Comment("reaching state \'S1796\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1797\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1798\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1799\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1800\'");
                int temp195 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker2)));
                if ((temp195 == 0)) {
                    ResilientHandleBasicTestCaseS20();
                    goto label163;
                }
                if ((temp195 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label163;
                }
                if ((temp195 == 2)) {
                    ResilientHandleBasicTestCaseS7();
                    goto label163;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker2)));
            label163:
;
                goto label164;
            }
            if ((temp196 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label164;
            }
            if ((temp196 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label164;
            }
            throw new InvalidOperationException("never reached");
        label164:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1794ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1795");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1794ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1795");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1800");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1800");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1800");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1800");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1794IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1800");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1800");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1794ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1795");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1794ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1795");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1801
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1801() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1801");
            this.Manager.Comment("reaching state \'S1801\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp197;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp197);
            this.Manager.AddReturn(ReadConfigInfo, null, temp197);
            this.Manager.Comment("reaching state \'S1802\'");
            int temp199 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1801ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1801ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1801ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1801ReadConfigChecker3)));
            if ((temp199 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label166;
            }
            if ((temp199 == 1)) {
                this.Manager.Comment("reaching state \'S1803\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1804\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1805\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1806\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1807\'");
                int temp198 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker2)));
                if ((temp198 == 0)) {
                    ResilientHandleBasicTestCaseS20();
                    goto label165;
                }
                if ((temp198 == 1)) {
                    ResilientHandleBasicTestCaseS33();
                    goto label165;
                }
                if ((temp198 == 2)) {
                    ResilientHandleBasicTestCaseS7();
                    goto label165;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker2)));
            label165:
;
                goto label166;
            }
            if ((temp199 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label166;
            }
            if ((temp199 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label166;
            }
            throw new InvalidOperationException("never reached");
        label166:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1801ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1802");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1801ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1802");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1807");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1807");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1807");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1807");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1801IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1807");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1807");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1801ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1802");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1801ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1802");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1808
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1808() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1808");
            this.Manager.Comment("reaching state \'S1808\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp200;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp200);
            this.Manager.AddReturn(ReadConfigInfo, null, temp200);
            this.Manager.Comment("reaching state \'S1809\'");
            int temp205 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1808ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1808ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1808ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1808ReadConfigChecker3)));
            if ((temp205 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label171;
            }
            if ((temp205 == 1)) {
                this.Manager.Comment("reaching state \'S1810\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1811\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1812\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S1813\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1814\'");
                int temp204 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker3)));
                if ((temp204 == 0)) {
                    this.Manager.Comment("reaching state \'S1815\'");
                    int temp201 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker154)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker155)));
                    if ((temp201 == 0)) {
                        this.Manager.Comment("reaching state \'S1816\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S1817\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1818\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S1819\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1820\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1821\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label167;
                    }
                    if ((temp201 == 1)) {
                        ResilientHandleBasicTestCaseS540();
                        goto label167;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1815\'.");
                label167:
;
                    goto label170;
                }
                if ((temp204 == 1)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label170;
                }
                if ((temp204 == 2)) {
                    ResilientHandleBasicTestCaseS541();
                    goto label170;
                }
                if ((temp204 == 3)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label170;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker3)));
            label170:
;
                goto label171;
            }
            if ((temp205 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label171;
            }
            if ((temp205 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label171;
            }
            throw new InvalidOperationException("never reached");
        label171:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1808ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1809");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1808ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1809");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1814");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1814");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker154() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S1820");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker155() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS540() {
            this.Manager.Comment("reaching state \'S540\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS477();
        }
        
        private void ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1814");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1814");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S1814");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1814");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS541() {
            this.Manager.Comment("reaching state \'S541\'");
            int temp202 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker156)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker157)));
            if ((temp202 == 0)) {
                this.Manager.Comment("reaching state \'S542\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S543\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S544\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S545\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S546\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    ResilientHandleBasicTestCaseS319();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker1)));
                }
                goto label168;
            }
            if ((temp202 == 1)) {
                this.Manager.Comment("reaching state \'S547\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Comment("reaching state \'S548\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S549\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S550\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S551\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    this.Manager.Comment("reaching state \'S552\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker2)));
                }
                goto label168;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S541\'.");
        label168:
;
        }
        
        private void PreConstraintChecker156() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S546");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS319() {
            this.Manager.Comment("reaching state \'S319\'");
        }
        
        private void PreConstraintChecker157() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S551");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1808IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1814");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1814");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS567() {
            this.Manager.Comment("reaching state \'S567\'");
            int temp203 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker158)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker159)));
            if ((temp203 == 0)) {
                ResilientHandleBasicTestCaseS359();
                goto label169;
            }
            if ((temp203 == 1)) {
                this.Manager.Comment("reaching state \'S568\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S569\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S570\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S571\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S572\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S573\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker3)));
                }
                goto label169;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S567\'.");
        label169:
;
        }
        
        private void PreConstraintChecker158() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void PreConstraintChecker159() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS1808ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S572");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1808ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1809");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1808ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1809");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S1822
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS1822() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS1822");
            this.Manager.Comment("reaching state \'S1822\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp206;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp206);
            this.Manager.AddReturn(ReadConfigInfo, null, temp206);
            this.Manager.Comment("reaching state \'S1823\'");
            int temp208 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1822ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1822ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1822ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS1822ReadConfigChecker3)));
            if ((temp208 == 0)) {
                ResilientHandleBasicTestCaseS1653();
                goto label173;
            }
            if ((temp208 == 1)) {
                this.Manager.Comment("reaching state \'S1824\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1825\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1826\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1827\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1828\'");
                int temp207 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker2)));
                if ((temp207 == 0)) {
                    ResilientHandleBasicTestCaseS1510();
                    goto label172;
                }
                if ((temp207 == 1)) {
                    ResilientHandleBasicTestCaseS1523();
                    goto label172;
                }
                if ((temp207 == 2)) {
                    ResilientHandleBasicTestCaseS1574();
                    goto label172;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker2)));
            label172:
;
                goto label173;
            }
            if ((temp208 == 2)) {
                ResilientHandleBasicTestCaseS224();
                goto label173;
            }
            if ((temp208 == 3)) {
                ResilientHandleBasicTestCaseS236();
                goto label173;
            }
            throw new InvalidOperationException("never reached");
        label173:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS1822ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1823");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS1822ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1823");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1828");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1828");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1828");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1828");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1822IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1828");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1828");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS1822ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1823");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS1822ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S1823");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        #endregion
        
        #region Test Starting in S306
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS306() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS306");
            this.Manager.Comment("reaching state \'S306\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp209;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp209);
            this.Manager.AddReturn(ReadConfigInfo, null, temp209);
            this.Manager.Comment("reaching state \'S307\'");
            int temp216 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS306ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS306ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS306ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS306ReadConfigChecker3)));
            if ((temp216 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label180;
            }
            if ((temp216 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label180;
            }
            if ((temp216 == 2)) {
                this.Manager.Comment("reaching state \'S308\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S309\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S310\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S311\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S312\'");
                int temp212 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker3)));
                if ((temp212 == 0)) {
                    this.Manager.Comment("reaching state \'S313\'");
                    int temp210 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker160)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker161)));
                    if ((temp210 == 0)) {
                        this.Manager.Comment("reaching state \'S314\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S315\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S316\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S317\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S318\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker))) != -1)) {
                            ResilientHandleBasicTestCaseS319();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label174;
                    }
                    if ((temp210 == 1)) {
                        ResilientHandleBasicTestCaseS320();
                        goto label174;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S313\'.");
                label174:
;
                    goto label176;
                }
                if ((temp212 == 1)) {
                    this.Manager.Comment("reaching state \'S326\'");
                    int temp211 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker162)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker163)));
                    if ((temp211 == 0)) {
                        this.Manager.Comment("reaching state \'S327\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S328\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S329\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S330\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S331\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S332\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label175;
                    }
                    if ((temp211 == 1)) {
                        this.Manager.Comment("reaching state \'S333\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S334\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S335\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S336\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S337\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            ResilientHandleBasicTestCaseS338();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label175;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S326\'.");
                label175:
;
                    goto label176;
                }
                if ((temp212 == 2)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label176;
                }
                if ((temp212 == 3)) {
                    ResilientHandleBasicTestCaseS352();
                    goto label176;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker3)));
            label176:
;
                goto label180;
            }
            if ((temp216 == 3)) {
                this.Manager.Comment("reaching state \'S365\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S366\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S367\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S368\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S369\'");
                int temp215 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker7)));
                if ((temp215 == 0)) {
                    ResilientHandleBasicTestCaseS134();
                    goto label179;
                }
                if ((temp215 == 1)) {
                    this.Manager.Comment("reaching state \'S370\'");
                    int temp213 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker164)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker165)));
                    if ((temp213 == 0)) {
                        this.Manager.Comment("reaching state \'S371\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S372\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S373\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S374\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S375\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker3))) != -1)) {
                            ResilientHandleBasicTestCaseS376();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker3)));
                        }
                        goto label177;
                    }
                    if ((temp213 == 1)) {
                        ResilientHandleBasicTestCaseS377();
                        goto label177;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S370\'.");
                label177:
;
                    goto label179;
                }
                if ((temp215 == 2)) {
                    this.Manager.Comment("reaching state \'S383\'");
                    int temp214 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker166)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker167)));
                    if ((temp214 == 0)) {
                        this.Manager.Comment("reaching state \'S384\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S385\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S386\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S387\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S388\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker4))) != -1)) {
                            ResilientHandleBasicTestCaseS389();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker4)));
                        }
                        goto label178;
                    }
                    if ((temp214 == 1)) {
                        ResilientHandleBasicTestCaseS390();
                        goto label178;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S383\'.");
                label178:
;
                    goto label179;
                }
                if ((temp215 == 3)) {
                    ResilientHandleBasicTestCaseS396();
                    goto label179;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker7)));
            label179:
;
                goto label180;
            }
            throw new InvalidOperationException("never reached");
        label180:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS306ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S307");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS306ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S307");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS306ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S307");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S312");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S312");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker160() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S318");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker161() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS320() {
            this.Manager.Comment("reaching state \'S320\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS321();
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S312");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S312");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker162() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S331");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker163() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S337");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS338() {
            this.Manager.Comment("reaching state \'S338\'");
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S312");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S312");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S312");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S312");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS306ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S307");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S369");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S369");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S369");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S369");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker164() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S375");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker165() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S369");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S369");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker166() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS306ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S388");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker167() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS306IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S369");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S369");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        #endregion
        
        #region Test Starting in S403
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS403() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS403");
            this.Manager.Comment("reaching state \'S403\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp217;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp217);
            this.Manager.AddReturn(ReadConfigInfo, null, temp217);
            this.Manager.Comment("reaching state \'S404\'");
            int temp223 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS403ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS403ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS403ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS403ReadConfigChecker3)));
            if ((temp223 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label186;
            }
            if ((temp223 == 1)) {
                this.Manager.Comment("reaching state \'S405\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S406\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S407\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S408\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S409\'");
                int temp219 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker1)));
                if ((temp219 == 0)) {
                    this.Manager.Comment("reaching state \'S410\'");
                    int temp218 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker168)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker169)));
                    if ((temp218 == 0)) {
                        this.Manager.Comment("reaching state \'S411\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S412\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S413\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S414\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S415\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker))) != -1)) {
                            ResilientHandleBasicTestCaseS416();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label181;
                    }
                    if ((temp218 == 1)) {
                        ResilientHandleBasicTestCaseS417();
                        goto label181;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S410\'.");
                label181:
;
                    goto label182;
                }
                if ((temp219 == 1)) {
                    ResilientHandleBasicTestCaseS423();
                    goto label182;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker1)));
            label182:
;
                goto label186;
            }
            if ((temp223 == 2)) {
                this.Manager.Comment("reaching state \'S436\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S437\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S438\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S439\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S440\'");
                int temp222 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker5)));
                if ((temp222 == 0)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label185;
                }
                if ((temp222 == 1)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label185;
                }
                if ((temp222 == 2)) {
                    this.Manager.Comment("reaching state \'S441\'");
                    int temp220 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker170)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker171)));
                    if ((temp220 == 0)) {
                        this.Manager.Comment("reaching state \'S442\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S443\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S444\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S445\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S446\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            ResilientHandleBasicTestCaseS447();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label183;
                    }
                    if ((temp220 == 1)) {
                        ResilientHandleBasicTestCaseS448();
                        goto label183;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S441\'.");
                label183:
;
                    goto label185;
                }
                if ((temp222 == 3)) {
                    this.Manager.Comment("reaching state \'S449\'");
                    int temp221 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker172)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker173)));
                    if ((temp221 == 0)) {
                        this.Manager.Comment("reaching state \'S450\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S451\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S452\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S453\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S454\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            ResilientHandleBasicTestCaseS455();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label184;
                    }
                    if ((temp221 == 1)) {
                        ResilientHandleBasicTestCaseS456();
                        goto label184;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S449\'.");
                label184:
;
                    goto label185;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker5)));
            label185:
;
                goto label186;
            }
            if ((temp223 == 3)) {
                ResilientHandleBasicTestCaseS457();
                goto label186;
            }
            throw new InvalidOperationException("never reached");
        label186:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS403ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S404");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS403ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S404");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S409");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S409");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker168() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S415");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker169() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S409");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S409");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS403ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S404");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S440");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S440");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S440");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S440");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S440");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S440");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker170() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S446");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker171() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS403IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S440");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S440");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker172() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS403ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S454");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker173() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS403ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S404");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        #endregion
        
        #region Test Starting in S496
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS496() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS496");
            this.Manager.Comment("reaching state \'S496\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp224;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp224);
            this.Manager.AddReturn(ReadConfigInfo, null, temp224);
            this.Manager.Comment("reaching state \'S497\'");
            int temp230 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS496ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS496ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS496ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS496ReadConfigChecker3)));
            if ((temp230 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label192;
            }
            if ((temp230 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label192;
            }
            if ((temp230 == 2)) {
                this.Manager.Comment("reaching state \'S498\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S499\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S500\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S501\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S502\'");
                int temp226 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker1)));
                if ((temp226 == 0)) {
                    this.Manager.Comment("reaching state \'S503\'");
                    int temp225 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker174)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker175)));
                    if ((temp225 == 0)) {
                        this.Manager.Comment("reaching state \'S504\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S505\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S506\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S507\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S508\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S509\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label187;
                    }
                    if ((temp225 == 1)) {
                        this.Manager.Comment("reaching state \'S510\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                                " Open is to be preserved for reconnect. \"");
                        this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                        this.Manager.Comment("reaching state \'S511\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S512\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S513\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S514\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            ResilientHandleBasicTestCaseS515();
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label187;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S503\'.");
                label187:
;
                    goto label188;
                }
                if ((temp226 == 1)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label188;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker1)));
            label188:
;
                goto label192;
            }
            if ((temp230 == 3)) {
                this.Manager.Comment("reaching state \'S529\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S530\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S531\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S532\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S533\'");
                int temp229 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker5)));
                if ((temp229 == 0)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label191;
                }
                if ((temp229 == 1)) {
                    ResilientHandleBasicTestCaseS534();
                    goto label191;
                }
                if ((temp229 == 2)) {
                    ResilientHandleBasicTestCaseS541();
                    goto label191;
                }
                if ((temp229 == 3)) {
                    this.Manager.Comment("reaching state \'S553\'");
                    int temp228 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker178)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker179)));
                    if ((temp228 == 0)) {
                        ResilientHandleBasicTestCaseS353();
                        goto label190;
                    }
                    if ((temp228 == 1)) {
                        this.Manager.Comment("reaching state \'S554\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S555\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S556\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S557\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S558\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker3))) != -1)) {
                            this.Manager.Comment("reaching state \'S559\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker3)));
                        }
                        goto label190;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S553\'.");
                label190:
;
                    goto label191;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker5)));
            label191:
;
                goto label192;
            }
            throw new InvalidOperationException("never reached");
        label192:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS496ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S497");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS496ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S497");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS496ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S497");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S502");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S502");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker174() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S508");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker175() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_SUCCESS)\'");
            TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of ReEstablishResilientOpenResponse, state S514");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS515() {
            this.Manager.Comment("reaching state \'S515\'");
        }
        
        private void ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S502");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S502");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS496ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S497");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S533");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S533");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S533");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S533");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS534() {
            this.Manager.Comment("reaching state \'S534\'");
            int temp227 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker176)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker177)));
            if ((temp227 == 0)) {
                this.Manager.Comment("reaching state \'S535\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S536\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S537\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S538\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S539\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker2))) != -1)) {
                    ResilientHandleBasicTestCaseS338();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker2)));
                }
                goto label189;
            }
            if ((temp227 == 1)) {
                ResilientHandleBasicTestCaseS540();
                goto label189;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S534\'.");
        label189:
;
        }
        
        private void PreConstraintChecker176() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S539");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker177() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S533");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S533");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS496IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S533");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S533");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker178() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker179() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS496ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S558");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        #endregion
        
        #region Test Starting in S560
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS560() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS560");
            this.Manager.Comment("reaching state \'S560\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp231;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp231);
            this.Manager.AddReturn(ReadConfigInfo, null, temp231);
            this.Manager.Comment("reaching state \'S561\'");
            int temp238 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS560ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS560ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS560ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS560ReadConfigChecker3)));
            if ((temp238 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label199;
            }
            if ((temp238 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label199;
            }
            if ((temp238 == 2)) {
                this.Manager.Comment("reaching state \'S562\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S563\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S564\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S565\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S566\'");
                int temp234 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker4)));
                if ((temp234 == 0)) {
                    ResilientHandleBasicTestCaseS462();
                    goto label195;
                }
                if ((temp234 == 1)) {
                    ResilientHandleBasicTestCaseS475();
                    goto label195;
                }
                if ((temp234 == 2)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label195;
                }
                if ((temp234 == 3)) {
                    ResilientHandleBasicTestCaseS574();
                    goto label195;
                }
                if ((temp234 == 4)) {
                    this.Manager.Comment("reaching state \'S581\'");
                    int temp233 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker182)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker183)));
                    if ((temp233 == 0)) {
                        this.Manager.Comment("reaching state \'S582\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S583\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S584\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S585\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S586\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S587\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label194;
                    }
                    if ((temp233 == 1)) {
                        this.Manager.Comment("reaching state \'S588\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S589\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S590\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S591\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S592\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S593\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label194;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S581\'.");
                label194:
;
                    goto label195;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker4)));
            label195:
;
                goto label199;
            }
            if ((temp238 == 3)) {
                this.Manager.Comment("reaching state \'S594\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S595\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S596\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S597\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S598\'");
                int temp237 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker6)));
                if ((temp237 == 0)) {
                    ResilientHandleBasicTestCaseS599();
                    goto label198;
                }
                if ((temp237 == 1)) {
                    this.Manager.Comment("reaching state \'S611\'");
                    int temp236 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker186)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker187)));
                    if ((temp236 == 0)) {
                        this.Manager.Comment("reaching state \'S612\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S613\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S614\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S615\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S616\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker5))) != -1)) {
                            this.Manager.Comment("reaching state \'S617\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker5)));
                        }
                        goto label197;
                    }
                    if ((temp236 == 1)) {
                        this.Manager.Comment("reaching state \'S618\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S619\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S620\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S621\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S622\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker6))) != -1)) {
                            this.Manager.Comment("reaching state \'S623\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker6)));
                        }
                        goto label197;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S611\'.");
                label197:
;
                    goto label198;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker6)));
            label198:
;
                goto label199;
            }
            throw new InvalidOperationException("never reached");
        label199:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS560ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S561");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS560ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S561");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS560ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S561");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S566");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S566");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S566");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S566");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S566");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S566");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S566");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S566");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS574() {
            this.Manager.Comment("reaching state \'S574\'");
            int temp232 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker180)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker181)));
            if ((temp232 == 0)) {
                ResilientHandleBasicTestCaseS490();
                goto label193;
            }
            if ((temp232 == 1)) {
                this.Manager.Comment("reaching state \'S575\'");
                this.Manager.Comment("executing step \'call LogOff()\'");
                this.IResilientHandleAdapterInstance.LogOff();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                        "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                        "cified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                        " closed.\"");
                this.Manager.Comment("reaching state \'S576\'");
                this.Manager.Comment("checking step \'return LogOff\'");
                this.Manager.Comment("reaching state \'S577\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S578\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S579\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker))) != -1)) {
                    this.Manager.Comment("reaching state \'S580\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker)));
                }
                goto label193;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S574\'.");
        label193:
;
        }
        
        private void PreConstraintChecker180() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void PreConstraintChecker181() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S579");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S566");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S566");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker182() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S586");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker183() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S592");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS560ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S561");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S598");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S598");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS599() {
            this.Manager.Comment("reaching state \'S599\'");
            int temp235 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker184)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker185)));
            if ((temp235 == 0)) {
                this.Manager.Comment("reaching state \'S600\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S601\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S602\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S603\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S604\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker3))) != -1)) {
                    ResilientHandleBasicTestCaseS515();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker3)));
                }
                goto label196;
            }
            if ((temp235 == 1)) {
                ResilientHandleBasicTestCaseS605();
                goto label196;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S599\'.");
        label196:
;
        }
        
        private void PreConstraintChecker184() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S604");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker185() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS605() {
            this.Manager.Comment("reaching state \'S605\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS606();
        }
        
        private void ResilientHandleBasicTestCaseS606() {
            this.Manager.Comment("reaching state \'S606\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS560DisconnectChecker)));
            this.Manager.Comment("reaching state \'S607\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S608\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S609\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker4))) != -1)) {
                this.Manager.Comment("reaching state \'S610\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker4)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS560DisconnectChecker() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S609");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS560IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S598");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S598");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker186() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S616");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker187() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS560ReEstablishResilientOpenResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S622");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        #endregion
        
        #region Test Starting in S624
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS624() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS624");
            this.Manager.Comment("reaching state \'S624\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp239;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp239);
            this.Manager.AddReturn(ReadConfigInfo, null, temp239);
            this.Manager.Comment("reaching state \'S625\'");
            int temp242 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS624ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS624ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS624ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS624ReadConfigChecker3)));
            if ((temp242 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label202;
            }
            if ((temp242 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label202;
            }
            if ((temp242 == 2)) {
                this.Manager.Comment("reaching state \'S626\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S627\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S628\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S629\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S630\'");
                int temp240 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker4)));
                if ((temp240 == 0)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label200;
                }
                if ((temp240 == 1)) {
                    ResilientHandleBasicTestCaseS462();
                    goto label200;
                }
                if ((temp240 == 2)) {
                    ResilientHandleBasicTestCaseS475();
                    goto label200;
                }
                if ((temp240 == 3)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label200;
                }
                if ((temp240 == 4)) {
                    ResilientHandleBasicTestCaseS574();
                    goto label200;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker4)));
            label200:
;
                goto label202;
            }
            if ((temp242 == 3)) {
                this.Manager.Comment("reaching state \'S631\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S632\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S633\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S634\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S635\'");
                int temp241 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker6)));
                if ((temp241 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label201;
                }
                if ((temp241 == 1)) {
                    ResilientHandleBasicTestCaseS599();
                    goto label201;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker6)));
            label201:
;
                goto label202;
            }
            throw new InvalidOperationException("never reached");
        label202:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS624ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S625");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS624ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S625");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS624ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S625");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S630");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S630");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S630");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S630");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S630");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S630");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S630");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S630");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S630");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S630");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS624ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S625");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S635");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S635");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS624IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S635");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S635");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        #endregion
        
        #region Test Starting in S636
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS636() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS636");
            this.Manager.Comment("reaching state \'S636\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp243;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp243);
            this.Manager.AddReturn(ReadConfigInfo, null, temp243);
            this.Manager.Comment("reaching state \'S637\'");
            int temp246 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS636ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS636ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS636ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS636ReadConfigChecker3)));
            if ((temp246 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label205;
            }
            if ((temp246 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label205;
            }
            if ((temp246 == 2)) {
                this.Manager.Comment("reaching state \'S638\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S639\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S640\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S641\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S642\'");
                int temp244 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker4)));
                if ((temp244 == 0)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label203;
                }
                if ((temp244 == 1)) {
                    ResilientHandleBasicTestCaseS462();
                    goto label203;
                }
                if ((temp244 == 2)) {
                    ResilientHandleBasicTestCaseS475();
                    goto label203;
                }
                if ((temp244 == 3)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label203;
                }
                if ((temp244 == 4)) {
                    ResilientHandleBasicTestCaseS574();
                    goto label203;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker4)));
            label203:
;
                goto label205;
            }
            if ((temp246 == 3)) {
                this.Manager.Comment("reaching state \'S643\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S644\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S645\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S646\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S647\'");
                int temp245 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker7)));
                if ((temp245 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label204;
                }
                if ((temp245 == 1)) {
                    ResilientHandleBasicTestCaseS648();
                    goto label204;
                }
                if ((temp245 == 2)) {
                    ResilientHandleBasicTestCaseS661();
                    goto label204;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker7)));
            label204:
;
                goto label205;
            }
            throw new InvalidOperationException("never reached");
        label205:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS636ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S637");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS636ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S637");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS636ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S637");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S642");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S642");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S642");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S642");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S642");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S642");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S642");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S642");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S642");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S642");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS636ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S637");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S647");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S647");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S647");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S647");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS636IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S647");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S647");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        #endregion
        
        #region Test Starting in S674
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS674() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS674");
            this.Manager.Comment("reaching state \'S674\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp247;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp247);
            this.Manager.AddReturn(ReadConfigInfo, null, temp247);
            this.Manager.Comment("reaching state \'S675\'");
            int temp252 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS674ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS674ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS674ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS674ReadConfigChecker3)));
            if ((temp252 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label210;
            }
            if ((temp252 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label210;
            }
            if ((temp252 == 2)) {
                this.Manager.Comment("reaching state \'S676\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S677\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S678\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S679\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S680\'");
                int temp249 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker3)));
                if ((temp249 == 0)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label207;
                }
                if ((temp249 == 1)) {
                    ResilientHandleBasicTestCaseS534();
                    goto label207;
                }
                if ((temp249 == 2)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label207;
                }
                if ((temp249 == 3)) {
                    this.Manager.Comment("reaching state \'S681\'");
                    int temp248 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker188)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker189)));
                    if ((temp248 == 0)) {
                        ResilientHandleBasicTestCaseS320();
                        goto label206;
                    }
                    if ((temp248 == 1)) {
                        this.Manager.Comment("reaching state \'S682\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S683\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S684\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S685\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S686\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S687\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label206;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S681\'.");
                label206:
;
                    goto label207;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker3)));
            label207:
;
                goto label210;
            }
            if ((temp252 == 3)) {
                this.Manager.Comment("reaching state \'S688\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S689\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S690\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S691\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S692\'");
                int temp251 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker6)));
                if ((temp251 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label209;
                }
                if ((temp251 == 1)) {
                    ResilientHandleBasicTestCaseS661();
                    goto label209;
                }
                if ((temp251 == 2)) {
                    this.Manager.Comment("reaching state \'S693\'");
                    int temp250 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker190)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker191)));
                    if ((temp250 == 0)) {
                        this.Manager.Comment("reaching state \'S694\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S695\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S696\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S697\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S698\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S699\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label208;
                    }
                    if ((temp250 == 1)) {
                        this.Manager.Comment("reaching state \'S700\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                                "e the Open as specified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                        this.Manager.Comment("reaching state \'S701\'");
                        this.Manager.Comment("checking step \'return Disconnect\'");
                        this.Manager.Comment("reaching state \'S702\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S703\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S704\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S705\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label208;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S693\'.");
                label208:
;
                    goto label209;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker6)));
            label209:
;
                goto label210;
            }
            throw new InvalidOperationException("never reached");
        label210:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS674ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S675");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS674ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S675");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS674ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S675");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S680");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S680");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S680");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S680");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S680");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S680");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S680");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S680");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker188() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker189() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S686");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS674ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S675");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S692");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S692");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S692");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S692");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS674IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S692");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S692");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker190() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S698");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker191() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS674ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S704");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        #endregion
        
        #region Test Starting in S706
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS706() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS706");
            this.Manager.Comment("reaching state \'S706\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp253;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp253);
            this.Manager.AddReturn(ReadConfigInfo, null, temp253);
            this.Manager.Comment("reaching state \'S707\'");
            int temp257 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS706ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS706ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS706ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS706ReadConfigChecker3)));
            if ((temp257 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label214;
            }
            if ((temp257 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label214;
            }
            if ((temp257 == 2)) {
                this.Manager.Comment("reaching state \'S708\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S709\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S710\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S711\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S712\'");
                int temp254 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker3)));
                if ((temp254 == 0)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label211;
                }
                if ((temp254 == 1)) {
                    ResilientHandleBasicTestCaseS534();
                    goto label211;
                }
                if ((temp254 == 2)) {
                    ResilientHandleBasicTestCaseS541();
                    goto label211;
                }
                if ((temp254 == 3)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label211;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker3)));
            label211:
;
                goto label214;
            }
            if ((temp257 == 3)) {
                this.Manager.Comment("reaching state \'S713\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S714\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S715\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S716\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S717\'");
                int temp256 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker5)));
                if ((temp256 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label213;
                }
                if ((temp256 == 1)) {
                    this.Manager.Comment("reaching state \'S718\'");
                    int temp255 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker192)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker193)));
                    if ((temp255 == 0)) {
                        ResilientHandleBasicTestCaseS605();
                        goto label212;
                    }
                    if ((temp255 == 1)) {
                        this.Manager.Comment("reaching state \'S719\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S720\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S721\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S722\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S723\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS706ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S724\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS706ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label212;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S718\'.");
                label212:
;
                    goto label213;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker5)));
            label213:
;
                goto label214;
            }
            throw new InvalidOperationException("never reached");
        label214:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS706ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S707");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS706ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S707");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS706ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S707");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S712");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S712");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S712");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S712");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S712");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S712");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S712");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S712");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS706ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S707");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S717");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S717");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS706IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S717");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S717");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker192() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker193() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS706ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S723");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        #endregion
        
        #region Test Starting in S725
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS725() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS725");
            this.Manager.Comment("reaching state \'S725\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp258;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp258);
            this.Manager.AddReturn(ReadConfigInfo, null, temp258);
            this.Manager.Comment("reaching state \'S726\'");
            int temp265 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS725ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS725ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS725ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS725ReadConfigChecker3)));
            if ((temp265 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label221;
            }
            if ((temp265 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label221;
            }
            if ((temp265 == 2)) {
                this.Manager.Comment("reaching state \'S727\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S728\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S729\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S730\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S731\'");
                int temp262 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker4)));
                if ((temp262 == 0)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label218;
                }
                if ((temp262 == 1)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label218;
                }
                if ((temp262 == 2)) {
                    this.Manager.Comment("reaching state \'S732\'");
                    int temp259 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker194)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker195)));
                    if ((temp259 == 0)) {
                        ResilientHandleBasicTestCaseS489();
                        goto label215;
                    }
                    if ((temp259 == 1)) {
                        this.Manager.Comment("reaching state \'S733\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S734\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S735\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S736\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S737\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S738\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label215;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S732\'.");
                label215:
;
                    goto label218;
                }
                if ((temp262 == 3)) {
                    this.Manager.Comment("reaching state \'S739\'");
                    int temp260 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker196)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker197)));
                    if ((temp260 == 0)) {
                        this.Manager.Comment("reaching state \'S740\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S741\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S742\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S743\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S744\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S745\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label216;
                    }
                    if ((temp260 == 1)) {
                        this.Manager.Comment("reaching state \'S746\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S747\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S748\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S749\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S750\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S751\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label216;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S739\'.");
                label216:
;
                    goto label218;
                }
                if ((temp262 == 4)) {
                    this.Manager.Comment("reaching state \'S752\'");
                    int temp261 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker198)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker199)));
                    if ((temp261 == 0)) {
                        this.Manager.Comment("reaching state \'S753\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S754\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S755\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S756\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S757\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker3))) != -1)) {
                            this.Manager.Comment("reaching state \'S758\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker3)));
                        }
                        goto label217;
                    }
                    if ((temp261 == 1)) {
                        this.Manager.Comment("reaching state \'S759\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S760\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S761\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S762\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S763\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker4))) != -1)) {
                            this.Manager.Comment("reaching state \'S764\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker4)));
                        }
                        goto label217;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S752\'.");
                label217:
;
                    goto label218;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker4)));
            label218:
;
                goto label221;
            }
            if ((temp265 == 3)) {
                this.Manager.Comment("reaching state \'S765\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S766\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S767\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S768\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S769\'");
                int temp264 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker7)));
                if ((temp264 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label220;
                }
                if ((temp264 == 1)) {
                    ResilientHandleBasicTestCaseS648();
                    goto label220;
                }
                if ((temp264 == 2)) {
                    this.Manager.Comment("reaching state \'S770\'");
                    int temp263 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker200)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker201)));
                    if ((temp263 == 0)) {
                        this.Manager.Comment("reaching state \'S771\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S772\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S773\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S774\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S775\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker5))) != -1)) {
                            this.Manager.Comment("reaching state \'S776\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker5)));
                        }
                        goto label219;
                    }
                    if ((temp263 == 1)) {
                        this.Manager.Comment("reaching state \'S777\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                                "e the Open as specified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                        this.Manager.AddReturn(DisconnectInfo, null);
                        ResilientHandleBasicTestCaseS606();
                        goto label219;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S770\'.");
                label219:
;
                    goto label220;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker7)));
            label220:
;
                goto label221;
            }
            throw new InvalidOperationException("never reached");
        label221:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS725ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S726");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS725ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S726");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS725ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S726");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S731");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S731");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S731");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S731");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S731");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S731");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker194() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker195() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S737");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S731");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S731");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker196() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb30 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppor" +
                    "ted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S744");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker197() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb30 \r\nIsIoCtl" +
                    "CodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindow" +
                    "s \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S750");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S731");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S731");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker198() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S757");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker199() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S763");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S726");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S769");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S769");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S769");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S769");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS725IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S769");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S769");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker200() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS725ReEstablishResilientOpenResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S775");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker201() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        #endregion
        
        #region Test Starting in S778
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS778() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS778");
            this.Manager.Comment("reaching state \'S778\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp266;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp266);
            this.Manager.AddReturn(ReadConfigInfo, null, temp266);
            this.Manager.Comment("reaching state \'S779\'");
            int temp269 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS778ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS778ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS778ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS778ReadConfigChecker3)));
            if ((temp269 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label224;
            }
            if ((temp269 == 1)) {
                ResilientHandleBasicTestCaseS236();
                goto label224;
            }
            if ((temp269 == 2)) {
                this.Manager.Comment("reaching state \'S780\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S781\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S782\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S783\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S784\'");
                int temp267 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker4)));
                if ((temp267 == 0)) {
                    ResilientHandleBasicTestCaseS339();
                    goto label222;
                }
                if ((temp267 == 1)) {
                    ResilientHandleBasicTestCaseS462();
                    goto label222;
                }
                if ((temp267 == 2)) {
                    ResilientHandleBasicTestCaseS475();
                    goto label222;
                }
                if ((temp267 == 3)) {
                    ResilientHandleBasicTestCaseS567();
                    goto label222;
                }
                if ((temp267 == 4)) {
                    ResilientHandleBasicTestCaseS574();
                    goto label222;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker4)));
            label222:
;
                goto label224;
            }
            if ((temp269 == 3)) {
                this.Manager.Comment("reaching state \'S785\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S786\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S787\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S788\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S789\'");
                int temp268 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker6)));
                if ((temp268 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label223;
                }
                if ((temp268 == 1)) {
                    ResilientHandleBasicTestCaseS599();
                    goto label223;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker6)));
            label223:
;
                goto label224;
            }
            throw new InvalidOperationException("never reached");
        label224:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS778ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S779");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS778ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S779");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS778ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S779");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S784");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S784");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S784");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S784");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S784");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S784");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S784");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S784");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S784");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S784");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : c.MaxSmbVersionSupported == 768");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 768");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS778ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S779");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S789");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S789");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS778IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S789");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S789");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        #endregion
        
        #region Test Starting in S790
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS790() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS790");
            this.Manager.Comment("reaching state \'S790\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp270;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp270);
            this.Manager.AddReturn(ReadConfigInfo, null, temp270);
            this.Manager.Comment("reaching state \'S791\'");
            int temp273 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS790ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS790ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS790ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS790ReadConfigChecker3)));
            if ((temp273 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label227;
            }
            if ((temp273 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label227;
            }
            if ((temp273 == 2)) {
                this.Manager.Comment("reaching state \'S792\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb21,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb21, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S793\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S794\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S795\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S796\'");
                int temp271 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker2)));
                if ((temp271 == 0)) {
                    ResilientHandleBasicTestCaseS516();
                    goto label225;
                }
                if ((temp271 == 1)) {
                    ResilientHandleBasicTestCaseS648();
                    goto label225;
                }
                if ((temp271 == 2)) {
                    ResilientHandleBasicTestCaseS661();
                    goto label225;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker2)));
            label225:
;
                goto label227;
            }
            if ((temp273 == 3)) {
                this.Manager.Comment("reaching state \'S797\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S798\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S799\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S800\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S801\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker3))) != -1)) {
                    this.Manager.Comment("reaching state \'S802\'");
                    int temp272 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker202)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker203)));
                    if ((temp272 == 0)) {
                        ResilientHandleBasicTestCaseS230();
                        goto label226;
                    }
                    if ((temp272 == 1)) {
                        this.Manager.Comment("reaching state \'S803\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S804\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S805\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S806\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S807\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS790ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S808\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS790ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label226;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S802\'.");
                label226:
;
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker3)));
                }
                goto label227;
            }
            throw new InvalidOperationException("never reached");
        label227:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS790ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S791");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS790ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S791");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS790ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S791");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S796");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S796");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S796");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S796");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S796");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S796");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS790ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S791");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS790IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S801");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S801");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        
        private void PreConstraintChecker202() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker203() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS790ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S807");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        #endregion
        
        #region Test Starting in S809
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS809() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS809");
            this.Manager.Comment("reaching state \'S809\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp274;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp274);
            this.Manager.AddReturn(ReadConfigInfo, null, temp274);
            this.Manager.Comment("reaching state \'S810\'");
            int temp277 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS809ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS809ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS809ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS809ReadConfigChecker3)));
            if ((temp277 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label230;
            }
            if ((temp277 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label230;
            }
            if ((temp277 == 2)) {
                this.Manager.Comment("reaching state \'S811\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S812\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S813\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S814\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S815\'");
                int temp276 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker1)));
                if ((temp276 == 0)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label229;
                }
                if ((temp276 == 1)) {
                    ResilientHandleBasicTestCaseS816();
                    goto label229;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker1)));
            label229:
;
                goto label230;
            }
            if ((temp277 == 3)) {
                this.Manager.Comment("reaching state \'S828\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S829\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S830\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ZeroTime" +
                        "out)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S831\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S832\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker2))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker2)));
                }
                goto label230;
            }
            throw new InvalidOperationException("never reached");
        label230:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS809ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S810");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS809ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S810");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS809ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S810");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S815");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S815");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S815");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S815");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS816() {
            this.Manager.Comment("reaching state \'S816\'");
            int temp275 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker204)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker205)));
            if ((temp275 == 0)) {
                this.Manager.Comment("reaching state \'S817\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If any of the following conditions is satisfied, it indicates that the" +
                        " Open is to be preserved for reconnect. \"");
                this.Manager.Checkpoint("\"[MS-SMB2] \tThe server supports leasing and Open.IsResilient is TRUE.\"");
                this.Manager.Checkpoint("\"[TestInfo] The above conditions are met.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is preserved.\"");
                this.Manager.Comment("reaching state \'S818\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S819\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                this.Manager.Comment("reaching state \'S820\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S821\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS809ReEstablishResilientOpenResponseChecker))) != -1)) {
                    ResilientHandleBasicTestCaseS210();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS809ReEstablishResilientOpenResponseChecker)));
                }
                goto label228;
            }
            if ((temp275 == 1)) {
                ResilientHandleBasicTestCaseS822();
                goto label228;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S816\'.");
        label228:
;
        }
        
        private void PreConstraintChecker204() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS809ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S821");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker205() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS822() {
            this.Manager.Comment("reaching state \'S822\'");
            this.Manager.Comment("executing step \'call Disconnect()\'");
            this.IResilientHandleAdapterInstance.Disconnect();
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                    "e the Open as specified in section 3.3.4.17.\"");
            this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
            this.Manager.AddReturn(DisconnectInfo, null);
            ResilientHandleBasicTestCaseS823();
        }
        
        private void ResilientHandleBasicTestCaseS823() {
            this.Manager.Comment("reaching state \'S823\'");
            this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.DisconnectInfo, null, new DisconnectDelegate1(this.ResilientHandleBasicTestCaseS809DisconnectChecker)));
            this.Manager.Comment("reaching state \'S824\'");
            this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
            this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
            this.Manager.Comment("reaching state \'S825\'");
            this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
            this.Manager.Comment("reaching state \'S826\'");
            if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS809ReEstablishResilientOpenResponseChecker1))) != -1)) {
                this.Manager.Comment("reaching state \'S827\'");
            }
            else {
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS809ReEstablishResilientOpenResponseChecker1)));
            }
        }
        
        private void ResilientHandleBasicTestCaseS809DisconnectChecker() {
            this.Manager.Comment("checking step \'return Disconnect\'");
        }
        
        private void ResilientHandleBasicTestCaseS809ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S826");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS809ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S810");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS809IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S832");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S832");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        #endregion
        
        #region Test Starting in S833
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS833() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS833");
            this.Manager.Comment("reaching state \'S833\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp278;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp278);
            this.Manager.AddReturn(ReadConfigInfo, null, temp278);
            this.Manager.Comment("reaching state \'S834\'");
            int temp282 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS833ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS833ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS833ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS833ReadConfigChecker3)));
            if ((temp282 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label234;
            }
            if ((temp282 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label234;
            }
            if ((temp282 == 2)) {
                this.Manager.Comment("reaching state \'S835\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S836\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S837\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S838\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S839\'");
                int temp281 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker1)));
                if ((temp281 == 0)) {
                    this.Manager.Comment("reaching state \'S840\'");
                    int temp279 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker206)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker207)));
                    if ((temp279 == 0)) {
                        ResilientHandleBasicTestCaseS822();
                        goto label231;
                    }
                    if ((temp279 == 1)) {
                        this.Manager.Comment("reaching state \'S841\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Comment("reaching state \'S842\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S843\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DiffUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(1)));
                        this.Manager.Comment("reaching state \'S844\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S845\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S846\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label231;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S840\'.");
                label231:
;
                    goto label233;
                }
                if ((temp281 == 1)) {
                    this.Manager.Comment("reaching state \'S847\'");
                    int temp280 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker208)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker209)));
                    if ((temp280 == 0)) {
                        this.Manager.Comment("reaching state \'S848\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S849\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S850\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S851\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S852\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S853\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label232;
                    }
                    if ((temp280 == 1)) {
                        this.Manager.Comment("reaching state \'S854\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S855\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S856\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S857\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S858\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S859\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label232;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S847\'.");
                label232:
;
                    goto label233;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker1)));
            label233:
;
                goto label234;
            }
            if ((temp282 == 3)) {
                this.Manager.Comment("reaching state \'S860\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S861\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S862\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S863\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S864\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker2))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker2)));
                }
                goto label234;
            }
            throw new InvalidOperationException("never reached");
        label234:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS833ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S834");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS833ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S834");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS833ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S834");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S839");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S839");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker206() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void PreConstraintChecker207() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_ACCESS_DENIED)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_ACCESS_DENIED, status, "status of ReEstablishResilientOpenResponse, state S845");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The user is different."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 9. If the user represented by Session.SecurityContext is not the same user denoted by Open.DurableOwner, the server MUST fail the request with STATUS_ACCESS_DENIED and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The user is different.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S839");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S839");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker208() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S852");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker209() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS833ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S858");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS833ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S834");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS833IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S864");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S864");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        #endregion
        
        #region Test Starting in S865
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS865() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS865");
            this.Manager.Comment("reaching state \'S865\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp283;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp283);
            this.Manager.AddReturn(ReadConfigInfo, null, temp283);
            this.Manager.Comment("reaching state \'S866\'");
            int temp286 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS865ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS865ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS865ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS865ReadConfigChecker3)));
            if ((temp286 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label237;
            }
            if ((temp286 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label237;
            }
            if ((temp286 == 2)) {
                this.Manager.Comment("reaching state \'S867\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S868\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S869\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S870\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S871\'");
                int temp285 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker2)));
                if ((temp285 == 0)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label236;
                }
                if ((temp285 == 1)) {
                    ResilientHandleBasicTestCaseS872();
                    goto label236;
                }
                if ((temp285 == 2)) {
                    ResilientHandleBasicTestCaseS885();
                    goto label236;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker2)));
            label236:
;
                goto label237;
            }
            if ((temp286 == 3)) {
                this.Manager.Comment("reaching state \'S898\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S899\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S900\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S901\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S902\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker3))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker3)));
                }
                goto label237;
            }
            throw new InvalidOperationException("never reached");
        label237:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS865ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S866");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS865ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S866");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS865ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S866");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S871");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S871");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S871");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S871");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S871");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S871");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS885() {
            this.Manager.Comment("reaching state \'S885\'");
            int temp284 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker210)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker211)));
            if ((temp284 == 0)) {
                this.Manager.Comment("reaching state \'S886\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S887\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S888\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S889\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S890\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS865ReEstablishResilientOpenResponseChecker))) != -1)) {
                    this.Manager.Comment("reaching state \'S891\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS865ReEstablishResilientOpenResponseChecker)));
                }
                goto label235;
            }
            if ((temp284 == 1)) {
                this.Manager.Comment("reaching state \'S892\'");
                this.Manager.Comment("executing step \'call Disconnect()\'");
                this.IResilientHandleAdapterInstance.Disconnect();
                this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                        "e the Open as specified in section 3.3.4.17.\"");
                this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                this.Manager.Comment("reaching state \'S893\'");
                this.Manager.Comment("checking step \'return Disconnect\'");
                this.Manager.Comment("reaching state \'S894\'");
                this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                this.Manager.Comment("reaching state \'S895\'");
                this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                this.Manager.Comment("reaching state \'S896\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS865ReEstablishResilientOpenResponseChecker1))) != -1)) {
                    this.Manager.Comment("reaching state \'S897\'");
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS865ReEstablishResilientOpenResponseChecker1)));
                }
                goto label235;
            }
            this.Manager.Assert(false, "reached non-accepting end state \'S885\'.");
        label235:
;
        }
        
        private void PreConstraintChecker210() {
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                            "MaxSmbVersionSupported",
                            "IsIoCtlCodeResiliencySupported",
                            "IsLeasingSupported",
                            "Platform"}, new object[] {
                            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                            false,
                            false,
                            Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}), "c == ResilientHandleServerConfig State: \r\nMaxSmbVersionSupported: Smb302 \r\nIsIoCt" +
                    "lCodeResiliencySupported: False \r\nIsLeasingSupported: False \r\nPlatform: NonWindo" +
                    "ws \r\n");
            this.Manager.Comment("Unbinding variable \'c\'");
            this.c.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS865ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S890");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker211() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(this.c.Value)), ((object)(this.Make<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(new string[] {
                    "MaxSmbVersionSupported",
                    "IsIoCtlCodeResiliencySupported",
                    "IsLeasingSupported",
                    "Platform"}, new object[] {
                    Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302,
                    false,
                    false,
                    Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.Platform.NonWindows}))))) 
                            == false), "Fail to check preconstraint : !(c == ResilientHandleServerConfig State: \r\nMaxSmbV" +
                    "ersionSupported: Smb302 \r\nIsIoCtlCodeResiliencySupported: False \r\nIsLeasingSuppo" +
                    "rted: False \r\nPlatform: NonWindows \r\n)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS865ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S896");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS865ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S866");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS865IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S902");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S902");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        #endregion
        
        #region Test Starting in S903
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS903() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS903");
            this.Manager.Comment("reaching state \'S903\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp287;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp287);
            this.Manager.AddReturn(ReadConfigInfo, null, temp287);
            this.Manager.Comment("reaching state \'S904\'");
            int temp290 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS903ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS903ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS903ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS903ReadConfigChecker3)));
            if ((temp290 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label240;
            }
            if ((temp290 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label240;
            }
            if ((temp290 == 2)) {
                this.Manager.Comment("reaching state \'S905\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S906\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S907\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S908\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S909\'");
                int temp289 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker2)));
                if ((temp289 == 0)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label239;
                }
                if ((temp289 == 1)) {
                    ResilientHandleBasicTestCaseS885();
                    goto label239;
                }
                if ((temp289 == 2)) {
                    this.Manager.Comment("reaching state \'S910\'");
                    int temp288 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker212)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker213)));
                    if ((temp288 == 0)) {
                        this.Manager.Comment("reaching state \'S911\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S912\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S913\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S914\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S915\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS903ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S916\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS903ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label238;
                    }
                    if ((temp288 == 1)) {
                        this.Manager.Comment("reaching state \'S917\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                                "e the Open as specified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                        this.Manager.AddReturn(DisconnectInfo, null);
                        ResilientHandleBasicTestCaseS823();
                        goto label238;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S910\'.");
                label238:
;
                    goto label239;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker2)));
            label239:
;
                goto label240;
            }
            if ((temp290 == 3)) {
                this.Manager.Comment("reaching state \'S918\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S919\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S920\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S921\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S922\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker3))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker3)));
                }
                goto label240;
            }
            throw new InvalidOperationException("never reached");
        label240:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS903ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S904");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS903ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S904");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS903ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S904");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S909");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S909");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S909");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S909");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S909");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S909");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker212() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS903ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S915");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker213() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS903ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S904");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS903IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S922");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S922");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        #endregion
        
        #region Test Starting in S923
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS923() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS923");
            this.Manager.Comment("reaching state \'S923\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp291;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp291);
            this.Manager.AddReturn(ReadConfigInfo, null, temp291);
            this.Manager.Comment("reaching state \'S924\'");
            int temp293 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS923ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS923ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS923ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS923ReadConfigChecker3)));
            if ((temp293 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label242;
            }
            if ((temp293 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label242;
            }
            if ((temp293 == 2)) {
                this.Manager.Comment("reaching state \'S925\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S926\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S927\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S928\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S929\'");
                int temp292 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker2)));
                if ((temp292 == 0)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label241;
                }
                if ((temp292 == 1)) {
                    ResilientHandleBasicTestCaseS872();
                    goto label241;
                }
                if ((temp292 == 2)) {
                    ResilientHandleBasicTestCaseS885();
                    goto label241;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker2)));
            label241:
;
                goto label242;
            }
            if ((temp293 == 3)) {
                this.Manager.Comment("reaching state \'S930\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S931\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S932\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S933\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S934\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker3))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker3)));
                }
                goto label242;
            }
            throw new InvalidOperationException("never reached");
        label242:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS923ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S924");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS923ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S924");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS923ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S924");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S929");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S929");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S929");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S929");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S929");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S929");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS923ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S924");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS923IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S934");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S934");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        #endregion
        
        #region Test Starting in S935
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS935() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS935");
            this.Manager.Comment("reaching state \'S935\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp294;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp294);
            this.Manager.AddReturn(ReadConfigInfo, null, temp294);
            this.Manager.Comment("reaching state \'S936\'");
            int temp296 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS935ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS935ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS935ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS935ReadConfigChecker3)));
            if ((temp296 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label244;
            }
            if ((temp296 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label244;
            }
            if ((temp296 == 2)) {
                this.Manager.Comment("reaching state \'S937\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S938\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S939\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,ValidTim" +
                        "eout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S940\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S941\'");
                int temp295 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker1)));
                if ((temp295 == 0)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label243;
                }
                if ((temp295 == 1)) {
                    ResilientHandleBasicTestCaseS816();
                    goto label243;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker1)));
            label243:
;
                goto label244;
            }
            if ((temp296 == 3)) {
                this.Manager.Comment("reaching state \'S942\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S943\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S944\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S945\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S946\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker2))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker2)));
                }
                goto label244;
            }
            throw new InvalidOperationException("never reached");
        label244:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS935ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S936");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS935ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S936");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS935ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S936");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S941");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S941");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S941");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S941");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS935ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S936");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS935IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S946");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S946");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        #endregion
        
        #region Test Starting in S947
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS947() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS947");
            this.Manager.Comment("reaching state \'S947\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp297;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp297);
            this.Manager.AddReturn(ReadConfigInfo, null, temp297);
            this.Manager.Comment("reaching state \'S948\'");
            int temp299 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS947ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS947ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS947ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS947ReadConfigChecker3)));
            if ((temp299 == 0)) {
                ResilientHandleBasicTestCaseS236();
                goto label246;
            }
            if ((temp299 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label246;
            }
            if ((temp299 == 2)) {
                this.Manager.Comment("reaching state \'S949\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S950\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S951\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Vali" +
                        "dTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(1)));
                this.Manager.Comment("reaching state \'S952\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S953\'");
                int temp298 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker1)));
                if ((temp298 == 0)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label245;
                }
                if ((temp298 == 1)) {
                    ResilientHandleBasicTestCaseS816();
                    goto label245;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker1)));
            label245:
;
                goto label246;
            }
            if ((temp299 == 3)) {
                this.Manager.Comment("reaching state \'S954\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S955\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S956\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S957\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S958\'");
                if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker2))) != -1)) {
                    ResilientHandleBasicTestCaseS152();
                }
                else {
                    this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker2)));
                }
                goto label246;
            }
            throw new InvalidOperationException("never reached");
        label246:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS947ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S948");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS947ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S948");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS947ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S948");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S953");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S953");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S953");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S953");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS947ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S948");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS947IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(status,c1)\'");
            try {
                TestManagerHelpers.AssertBind<int>(this.Manager, this.status, (System.Int32)status, "status of IoCtlResiliencyResponse, state S958");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S958");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[TestInfo] The server only supports SMB 2.002."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : c.MaxSmbVersionSupported == 514");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 514");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            TestManagerHelpers.AssertBind<int>(this.Manager, this.v2, this.status, "v2 == status");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server only supports SMB 2.002.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
            this.Manager.Comment("Unbinding variable \'v2\'");
            this.v2.Unbind();
        }
        #endregion
        
        #region Test Starting in S959
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS959() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS959");
            this.Manager.Comment("reaching state \'S959\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp300;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp300);
            this.Manager.AddReturn(ReadConfigInfo, null, temp300);
            this.Manager.Comment("reaching state \'S960\'");
            int temp303 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS959ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS959ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS959ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS959ReadConfigChecker3)));
            if ((temp303 == 0)) {
                ResilientHandleBasicTestCaseS224();
                goto label249;
            }
            if ((temp303 == 1)) {
                ResilientHandleBasicTestCaseS457();
                goto label249;
            }
            if ((temp303 == 2)) {
                this.Manager.Comment("reaching state \'S961\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb30,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb30, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S962\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S963\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountEqualToRequestSize,InvalidT" +
                        "imeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(1)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S964\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S965\'");
                int temp301 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker2)));
                if ((temp301 == 0)) {
                    ResilientHandleBasicTestCaseS211();
                    goto label247;
                }
                if ((temp301 == 1)) {
                    ResilientHandleBasicTestCaseS872();
                    goto label247;
                }
                if ((temp301 == 2)) {
                    ResilientHandleBasicTestCaseS885();
                    goto label247;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker2)));
            label247:
;
                goto label249;
            }
            if ((temp303 == 3)) {
                this.Manager.Comment("reaching state \'S966\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S967\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S968\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountGreaterThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount.InputCountGreaterThanRequestSize, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S969\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S970\'");
                int temp302 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker6)));
                if ((temp302 == 0)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label248;
                }
                if ((temp302 == 1)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label248;
                }
                if ((temp302 == 2)) {
                    ResilientHandleBasicTestCaseS971();
                    goto label248;
                }
                if ((temp302 == 3)) {
                    ResilientHandleBasicTestCaseS977();
                    goto label248;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker4)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker6)));
            label248:
;
                goto label249;
            }
            throw new InvalidOperationException("never reached");
        label249:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS959ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S960");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS959ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S960");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS959ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S960");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S965");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S965");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S965");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S965");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S965");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S965");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is not smaller than the size of the NETWORK_RESILIENCY_REQ" +
                    "UEST request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS959ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S960");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S970");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S970");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S970");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S970");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S970");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S970");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS959IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_SUCCESS,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status)(0)), status, "status of IoCtlResiliencyResponse, state S970");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S970");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to TRUE. "", ""[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE."", ""[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only by the user represented by Open.Session.SecurityContext."", ""[TestInfo] Open.DurableOwner is set to default user.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.IsDurable MUST be set to FALSE. Open.IsResilient MUST be set to T" +
                    "RUE. \"");
            this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is set to FALSE. Open.IsResilient is set to TRUE.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Open.DurableOwner MUST be set to a security descriptor accessible only" +
                    " by the user represented by Open.Session.SecurityContext.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.DurableOwner is set to default user.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        #endregion
        
        #region Test Starting in S989
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestMethod()]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Model)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.Smb21)]
        [Microsoft.VisualStudio.TestTools.UnitTesting.TestCategory(Microsoft.Protocols.TestSuites.FileSharing.Common.Adapter.TestCategories.FsctlLmrRequestResiliency)]
        public void ResilientHandleBasicTestCaseS989() {
            this.Manager.BeginTest("ResilientHandleBasicTestCaseS989");
            this.Manager.Comment("reaching state \'S989\'");
            Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig temp304;
            this.Manager.Comment("executing step \'call ReadConfig(out _)\'");
            this.IResilientHandleAdapterInstance.ReadConfig(out temp304);
            this.Manager.AddReturn(ReadConfigInfo, null, temp304);
            this.Manager.Comment("reaching state \'S990\'");
            int temp310 = this.Manager.ExpectReturn(this.QuiescenceTimeout, true, new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS989ReadConfigChecker)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS989ReadConfigChecker1)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS989ReadConfigChecker2)), new ExpectedReturn(ResilientHandleBasicTestCase.ReadConfigInfo, null, new ReadConfigDelegate1(this.ResilientHandleBasicTestCaseS989ReadConfigChecker3)));
            if ((temp310 == 0)) {
                this.Manager.Comment("reaching state \'S1030\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb2002,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb2002, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S1031\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S1032\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Inva" +
                        "lidTimeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout.InvalidTimeout);
                this.Manager.Comment("reaching state \'S1033\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S1034\'");
                int temp306 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker4)));
                if ((temp306 == 0)) {
                    this.Manager.Comment("reaching state \'S1035\'");
                    int temp305 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker214)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker215)));
                    if ((temp305 == 0)) {
                        this.Manager.Comment("reaching state \'S1036\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1037\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1038\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1039\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1040\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker))) != -1)) {
                            this.Manager.Comment("reaching state \'S1041\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker)));
                        }
                        goto label250;
                    }
                    if ((temp305 == 1)) {
                        this.Manager.Comment("reaching state \'S1042\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1043\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1044\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1045\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1046\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker1))) != -1)) {
                            this.Manager.Comment("reaching state \'S1047\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker1)));
                        }
                        goto label250;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1035\'.");
                label250:
;
                    goto label251;
                }
                if ((temp306 == 1)) {
                    ResilientHandleBasicTestCaseS241();
                    goto label251;
                }
                if ((temp306 == 2)) {
                    ResilientHandleBasicTestCaseS267();
                    goto label251;
                }
                if ((temp306 == 3)) {
                    ResilientHandleBasicTestCaseS280();
                    goto label251;
                }
                if ((temp306 == 4)) {
                    ResilientHandleBasicTestCaseS293();
                    goto label251;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker1)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker2)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker3)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker4)));
            label251:
;
                goto label255;
            }
            if ((temp310 == 1)) {
                ResilientHandleBasicTestCaseS224();
                goto label255;
            }
            if ((temp310 == 2)) {
                ResilientHandleBasicTestCaseS457();
                goto label255;
            }
            if ((temp310 == 3)) {
                this.Manager.Comment("reaching state \'S991\'");
                this.Manager.Comment("executing step \'call PrepareOpen(Smb302,NoDurableHandle)\'");
                this.IResilientHandleAdapterInstance.PrepareOpen(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelDialectRevision.Smb302, ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.DurableHandle)(1)));
                this.Manager.Comment("reaching state \'S992\'");
                this.Manager.Comment("checking step \'return PrepareOpen\'");
                this.Manager.Comment("reaching state \'S993\'");
                this.Manager.Comment("executing step \'call IoCtlResiliencyRequest(InputCountSmallerThanRequestSize,Zero" +
                        "Timeout)\'");
                this.IResilientHandleAdapterInstance.IoCtlResiliencyRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.IoCtlInputCount)(0)), ((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientTimeout)(0)));
                this.Manager.Comment("reaching state \'S994\'");
                this.Manager.Comment("checking step \'return IoCtlResiliencyRequest\'");
                this.Manager.Comment("reaching state \'S995\'");
                int temp309 = this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker7)));
                if ((temp309 == 0)) {
                    this.Manager.Comment("reaching state \'S1009\'");
                    int temp307 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker216)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker217)));
                    if ((temp307 == 0)) {
                        this.Manager.Comment("reaching state \'S1010\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1011\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1012\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1013\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1014\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker2))) != -1)) {
                            this.Manager.Comment("reaching state \'S1015\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker2)));
                        }
                        goto label252;
                    }
                    if ((temp307 == 1)) {
                        this.Manager.Comment("reaching state \'S1016\'");
                        this.Manager.Comment("executing step \'call Disconnect()\'");
                        this.IResilientHandleAdapterInstance.Disconnect();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.7.1 Handling Loss of a Connection\"");
                        this.Manager.Checkpoint("\"[MS-SMB2] If the Open is not to be preserved for reconnect, the server MUST clos" +
                                "e the Open as specified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] The Open is closed.\"");
                        this.Manager.AddReturn(DisconnectInfo, null);
                        ResilientHandleBasicTestCaseS418();
                        goto label252;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1009\'.");
                label252:
;
                    goto label254;
                }
                if ((temp309 == 1)) {
                    this.Manager.Comment("reaching state \'S1017\'");
                    int temp308 = this.Manager.SelectSatisfiedPreConstraint(true, new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker218)), new ExpectedPreConstraint(new PreConstraintDelegate1(this.PreConstraintChecker219)));
                    if ((temp308 == 0)) {
                        this.Manager.Comment("reaching state \'S1018\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1019\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1020\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1021\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1022\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker3))) != -1)) {
                            this.Manager.Comment("reaching state \'S1023\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker3)));
                        }
                        goto label253;
                    }
                    if ((temp308 == 1)) {
                        this.Manager.Comment("reaching state \'S1024\'");
                        this.Manager.Comment("executing step \'call LogOff()\'");
                        this.IResilientHandleAdapterInstance.LogOff();
                        this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.6: The server MUST close every Open in Session.OpenTable of the " +
                                "old session, where Open.IsDurable is FALSE and Open.IsResilient is FALSE, as spe" +
                                "cified in section 3.3.4.17.\"");
                        this.Manager.Checkpoint("\"[TestInfo] Open.IsDurable is FALSE and Open.IsResilient is FALSE, so the open is" +
                                " closed.\"");
                        this.Manager.Comment("reaching state \'S1025\'");
                        this.Manager.Comment("checking step \'return LogOff\'");
                        this.Manager.Comment("reaching state \'S1026\'");
                        this.Manager.Comment("executing step \'call ReEstablishResilientOpenRequest(DefaultUser)\'");
                        this.IResilientHandleAdapterInstance.ReEstablishResilientOpenRequest(((Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelUser)(0)));
                        this.Manager.Comment("reaching state \'S1027\'");
                        this.Manager.Comment("checking step \'return ReEstablishResilientOpenRequest\'");
                        this.Manager.Comment("reaching state \'S1028\'");
                        if ((this.Manager.ExpectEvent(this.QuiescenceTimeout, true, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker4))) != -1)) {
                            this.Manager.Comment("reaching state \'S1029\'");
                        }
                        else {
                            this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.ReEstablishResilientOpenResponseInfo, null, new ReEstablishResilientOpenResponseDelegate1(this.ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker4)));
                        }
                        goto label253;
                    }
                    this.Manager.Assert(false, "reached non-accepting end state \'S1017\'.");
                label253:
;
                    goto label254;
                }
                if ((temp309 == 2)) {
                    ResilientHandleBasicTestCaseS996();
                    goto label254;
                }
                this.Manager.CheckObservationTimeout(false, new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker5)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker6)), new ExpectedEvent(ResilientHandleBasicTestCase.IoCtlResiliencyResponseInfo, null, new IoCtlResiliencyResponseDelegate1(this.ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker7)));
            label254:
;
                goto label255;
            }
            throw new InvalidOperationException("never reached");
        label255:
;
            this.Manager.EndTest();
        }
        
        private void ResilientHandleBasicTestCaseS989ReadConfigChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S990");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v.MaxSmbVersionSupported == 528");
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1034");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1034");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker214() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1040");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker215() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1046");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1034");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1034");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_DEVICE_REQUEST,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_DEVICE_REQUEST, status, "status of IoCtlResiliencyResponse, state S1034");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1034");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows.""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S1034");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1034");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S1034");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S1034");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If Open.Connection.Dialect is ""2.002"", the server MAY<320> fail the request with STATUS_INVALID_DEVICE_REQUEST."", ""[TestInfo] Open.Connection.Dialect is ""2.002""."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : c.MaxSmbVersionSupported == 528");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(528))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 528");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] If Open.Connection.Dialect is \"2.002\", the server MAY<320> fail the re" +
                    "quest with STATUS_INVALID_DEVICE_REQUEST.\"");
            this.Manager.Checkpoint("\"[TestInfo] Open.Connection.Dialect is \"2.002\".\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS989ReadConfigChecker1(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S990");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(514))), "Fail to check the assumption : v.MaxSmbVersionSupported == 514");
        }
        
        private void ResilientHandleBasicTestCaseS989ReadConfigChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S990");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(768))), "Fail to check the assumption : v.MaxSmbVersionSupported == 768");
        }
        
        private void ResilientHandleBasicTestCaseS989ReadConfigChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig config) {
            this.Manager.Comment("checking step \'return ReadConfig/[out c]\'");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c, config, "config of ReadConfig, state S990");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v, this.c, "v == c");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v.MaxSmbVersionSupported == 770");
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker5(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S995");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S995");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.IsIoCtlCodeResiliencySupported == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported)))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == c.IsIoCtlCode" +
                    "ResiliencySupported");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker216() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker2(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1014");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker217() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker6(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_NOT_SUPPORTED,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_NOT_SUPPORTED, status, "status of IoCtlResiliencyResponse, state S995");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S995");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is Windows.""");
                throw;
            }
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0)))) 
                            == false), "Fail to check the assumption : !(c.Platform == 0)");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(((int)(this.c.Value.Platform))))), "Fail to check the assumption : v1.Platform == c.Platform");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is Windows.\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        
        private void PreConstraintChecker218() {
            this.Manager.Assert(((Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0)))) 
                            == false), "Fail to check preconstraint : !(c.IsLeasingSupported == 0)");
        }
        
        private void ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker3(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1022");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void PreConstraintChecker219() {
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsLeasingSupported))), ((object)(0))), "Fail to check preconstraint : c.IsLeasingSupported == 0");
        }
        
        private void ResilientHandleBasicTestCaseS989ReEstablishResilientOpenResponseChecker4(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status) {
            this.Manager.Comment("checking step \'event ReEstablishResilientOpenResponse(STATUS_OBJECT_NAME_NOT_FOUN" +
                    "D)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_OBJECT_NAME_NOT_FOUND, status, "status of ReEstablishResilientOpenResponse, state S1028");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9."", ""[TestInfo] The lookup fails."", ""[TestTag] Compatibility""");
                throw;
            }
            this.Manager.Checkpoint(@"""[MS-SMB2] 3.3.5.9.7: 1. The server MUST look up an existing open in the GlobalOpenTable by doing a lookup with the FileId.Persistent portion of the create context. If the lookup fails, the server SHOULD<268> fail the request with STATUS_OBJECT_NAME_NOT_FOUND and proceed as specified in ""Failed Open Handling"" in section 3.3.5.9.""");
            this.Manager.Checkpoint("\"[TestInfo] The lookup fails.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
        }
        
        private void ResilientHandleBasicTestCaseS989IoCtlResiliencyResponseChecker7(Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status status, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig c) {
            this.Manager.Comment("checking step \'event IoCtlResiliencyResponse(STATUS_INVALID_PARAMETER,c1)\'");
            try {
                TestManagerHelpers.AssertAreEqual<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status>(this.Manager, Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ModelSmb2Status.STATUS_INVALID_PARAMETER, status, "status of IoCtlResiliencyResponse, state S995");
                TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.c1, c, "c of IoCtlResiliencyResponse, state S995");
            }
            catch (TransactionFailedException ) {
                this.Manager.Comment(@"This step would have covered ""[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request"", ""[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the SMB 3.x dialect family."", ""[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED."", ""[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests."", ""[TestTag] Compatibility"", ""[TestInfo] The SUT platform is NonWindows."", ""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER."", ""[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request."", ""[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout."", ""[TestTag] OutOfBoundary""");
                throw;
            }
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.c.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : c.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : c.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.c.Value.Platform)))), ((object)(0))), "Fail to check the assumption : c.Platform == 0");
            TestManagerHelpers.AssertBind<Microsoft.Protocols.TestSuites.FileSharing.SMB2Model.Adapter.ResilientHandle.ResilientHandleServerConfig>(this.Manager, this.v1, this.c1, "v1 == c1");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(System.Convert.ToInt32(this.v1.Value.IsIoCtlCodeResiliencySupported))), ((object)(0))), "Fail to check the assumption : v1.IsIoCtlCodeResiliencySupported == 0");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.MaxSmbVersionSupported)))), ((object)(770))), "Fail to check the assumption : v1.MaxSmbVersionSupported == 770");
            this.Manager.Assert(Microsoft.SpecExplorer.Runtime.Testing.TestManagerHelpers.Equality(((object)(((int)(this.v1.Value.Platform)))), ((object)(0))), "Fail to check the assumption : v1.Platform == 0");
            this.Manager.Checkpoint("\"[MS-SMB2] 3.3.5.15.9 Handling a Resiliency Request\"");
            this.Manager.Checkpoint("\"[MS-SMB2] This section applies only to servers that implement the SMB 2.1 or the" +
                    " SMB 3.x dialect family.\"");
            this.Manager.Checkpoint("\"[MS-SMB2] Otherwise, if the server does not support FSCTL_LMR_REQUEST_RESILIENCY" +
                    " requests, the server SHOULD fail the request with STATUS_NOT_SUPPORTED.\"");
            this.Manager.Checkpoint("\"[TestInfo] The server does not support FSCTL_LMR_REQUEST_RESILIENCY requests.\"");
            this.Manager.Checkpoint("\"[TestTag] Compatibility\"");
            this.Manager.Checkpoint("\"[TestInfo] The SUT platform is NonWindows.\"");
            this.Manager.Checkpoint(@"""[MS-SMB2] If InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST request as specified in section 2.2.31.3, or if the requested Timeout in seconds is greater than MaxResiliencyTimeout in seconds, the request MUST be failed with STATUS_INVALID_PARAMETER.""");
            this.Manager.Checkpoint("\"[TestInfo] InputCount is smaller than the size of the NETWORK_RESILIENCY_REQUEST" +
                    " request.\"");
            this.Manager.Checkpoint("\"[TestInfo] The requested Timeout is not  greater than MaxResiliencyTimeout.\"");
            this.Manager.Checkpoint("\"[TestTag] OutOfBoundary\"");
            this.Manager.Comment("Unbinding variable \'c1\'");
            this.c1.Unbind();
            this.Manager.Comment("Unbinding variable \'status\'");
            this.status.Unbind();
            this.Manager.Comment("Unbinding variable \'v1\'");
            this.v1.Unbind();
        }
        #endregion
    }
}
