// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;

namespace Microsoft.Protocols.TestTools.StackSdk.Networking.Rpce
{
    /// <summary>
    /// RpceStubEncoder provides NDR encode support for RPC stub.
    /// </summary>
    public class RpceStubDecoder : RpceStub
    {
        // Holds the memory of bytes to decode.
        private IntPtr pBytesToDecode;
        private int bytesToDecodeLength;

        // RPC_MESSAGE and MIDL_STUB_DESC
        private IntPtr pRpcMsg;
        private IntPtr pStubDesc;


        /// <summary>
        /// Initialize a RpceStubDecoder.
        /// </summary>
        /// <param name="runtimeTargetPlatform">Runtime platform, x86 or amd64.</param>
        /// <param name="typeFormatString">Type format string generated by MIDL.</param>
        /// <param name="exprEvalRoutines">ExprEvalRoutines generated by MIDL if exists.</param>
        /// <param name="bytesToDecode">Bytes to decode.</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown when typeFormatString or bytesToDecode is null.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown when runtimeTargetPlatform doesn't match current platform at runtime.
        /// </exception>
        public RpceStubDecoder(
            RpceStubTargetPlatform runtimeTargetPlatform,
            byte[] typeFormatString,
            RpceStubExprEval[] exprEvalRoutines,
            byte[] bytesToDecode)
            : base(runtimeTargetPlatform, typeFormatString, exprEvalRoutines)
        {
            if (bytesToDecode == null)
            {
                throw new ArgumentNullException("bytesToDecode");
            }

            pBytesToDecode = Marshal.AllocHGlobal(bytesToDecode.Length);
            Marshal.Copy(bytesToDecode, 0, pBytesToDecode, bytesToDecode.Length);
            bytesToDecodeLength = bytesToDecode.Length;
        }


        /// <summary>
        /// Dispose method.
        /// </summary>
        /// <param name="disposing">
        /// True to release both managed and unmanaged resources.<para/>
        /// False to release unmanaged resources only.
        /// </param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Release managed resources.
            }

            // Release unmanaged resources.
            if (pStubMsg != IntPtr.Zero)
            {
                //Must call NdrFreeBuffer first.
                NdrFreeBuffer();
            }
            if (pRpcMsg != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(pRpcMsg);
                pRpcMsg = IntPtr.Zero;
            }
            if (pStubDesc != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(pStubDesc);
                pStubDesc = IntPtr.Zero;
            }
            if (pStubMsg != IntPtr.Zero)
            {
                Marshal.DestroyStructure(pStubMsg, typeof(NativeMethods.MIDL_STUB_MESSAGE));
                Marshal.FreeHGlobal(pStubMsg);
                pStubMsg = IntPtr.Zero;
            }
            if (pBytesToDecode != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(pBytesToDecode);
                pBytesToDecode = IntPtr.Zero;
            }

            base.Dispose(disposing);
        }


        /// <summary>
        /// Decode byte array to parameter list in one method call.
        /// </summary>
        /// <param name="runtimeTargetPlatform">Runtime platform, x86 or amd64.</param>
        /// <param name="typeFormatString">Type format string generated by MIDL.</param>
        /// <param name="exprEvalRoutines">ExprEvalRoutines generated by MIDL if exists.</param>
        /// <param name="procFormatString">Proc format string generated by MIDL.</param>
        /// <param name="procFormatStringOffset">Offset of the procedure in procFormatString.</param>
        /// <param name="isClient">Is client side.</param>
        /// <param name="bytesToDecode">Bytes to decode.</param>
        /// <param name="parameters">Parameters.</param>
        /// <returns>The decoded parameter list.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown when typeFormatString is null.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown when runtimeTargetPlatform doesn't match current platform at runtime.
        /// </exception>
        public static RpceInt3264Collection ToParamList(
            RpceStubTargetPlatform runtimeTargetPlatform,
            byte[] typeFormatString,
            RpceStubExprEval[] exprEvalRoutines,
            byte[] procFormatString,
            int procFormatStringOffset,
            bool isClient,
            byte[] bytesToDecode,
            params Int3264[] parameters)
        {
            RpceStubDecoder decoder = new RpceStubDecoder(
                runtimeTargetPlatform,
                typeFormatString,
                exprEvalRoutines,
                bytesToDecode);

            decoder.NdrServerInitializeNew();

            return new RpceInt3264Collection(
                decoder.NdrParametersUnmarshall(procFormatString, procFormatStringOffset, isClient, parameters),
                decoder);
        }


        /// <summary>
        /// Decode byte array to parameter list in one method call.
        /// Calling this method assumes that decoding the stub doesn't depends on any parameter.
        /// Only for decoding the stub data from the client side.
        /// </summary>
        /// <param name="runtimeTargetPlatform">Runtime platform, x86 or amd64.</param>
        /// <param name="typeFormatString">Type format string generated by MIDL.</param>
        /// <param name="exprEvalRoutines">ExprEvalRoutines generated by MIDL if exists.</param>
        /// <param name="procFormatString">Proc format string generated by MIDL.</param>
        /// <param name="procFormatStringOffset">Offset of the procedure in procFormatString.</param>
        /// <param name="isClient">Is client side.</param>
        /// <param name="bytesToDecode">Bytes to decode.</param>
        /// <returns>The decoded parameter list.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown when typeFormatString is null.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown when runtimeTargetPlatform doesn't match current platform at runtime.
        /// </exception>
        public static RpceInt3264Collection ToParamList(
            RpceStubTargetPlatform runtimeTargetPlatform,
            byte[] typeFormatString,
            RpceStubExprEval[] exprEvalRoutines,
            byte[] procFormatString,
            int procFormatStringOffset,
            bool isClient,
            byte[] bytesToDecode)
        {
            int offset = procFormatStringOffset;
            RpceProcedureHeaderDescriptor procHeaderInfo
                = RpceStubHelper.ParseProcedureHeaderDescriptor(procFormatString, ref offset);
            return ToParamList(runtimeTargetPlatform, typeFormatString, exprEvalRoutines, procFormatString,
                procFormatStringOffset, isClient, bytesToDecode, new Int3264[procHeaderInfo.NumberOfParams]);
        }


        /// <summary>
        /// Unmarshall parameters.
        /// </summary>
        /// <param name="procFormatString">Proc format string generated by MIDL.</param>
        /// <param name="offset">Offset of the procedure in procFormatString.</param>
        /// <param name="isClient">Is client side.</param>
        /// <param name="parameters">Parameters.</param>
        /// <returns>The decoded parameter list.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        private Int3264[] NdrParametersUnmarshall(
            byte[] procFormatString,
            int offset,
            bool isClient,
            params Int3264[] parameters)
        {
            if (procFormatString == null)
            {
                throw new ArgumentNullException("procFormatString");
            }

            RpceProcedureHeaderDescriptor procHeaderInfo
                = RpceStubHelper.ParseProcedureHeaderDescriptor(procFormatString, ref offset);

            if (procHeaderInfo.NumberOfParams != parameters.Length)
            {
                throw new InvalidOperationException("Number of parameters doesn't match expectation.");
            }

            SaveParametersIntoStack(procFormatString, offset, procHeaderInfo.StackSize, parameters);

            if ((procHeaderInfo.ExtensionFlags2 & RpceInterpreterOptFlags2.HasConformanceRange) != 0)
            {
                SetCorrDespIncrement(RANGED_NDR_CORR_EXTENSION_SIZE);
            }
            else
            {
                SetCorrDespIncrement(NDR_CORR_EXTENSION_SIZE);
            }

            List<Int3264> parameterList = new List<Int3264>(parameters);

            for (int i = 0; i < procHeaderInfo.NumberOfParams; i++)
            {
                RpceParameterAttributes parameterFlags = (RpceParameterAttributes)BitConverter.ToUInt16(procFormatString, offset);
                offset += sizeof(RpceParameterAttributes);
                offset += sizeof(ushort); //skip stack size/top
                ushort parameterTypeFormatStringOffset = BitConverter.ToUInt16(procFormatString, offset);
                offset += sizeof(ushort); //move to next parameter.

                bool sameDirection = (isClient
                    ? (parameterFlags & RpceParameterAttributes.IsOut)
                    : (parameterFlags & RpceParameterAttributes.IsIn)) != 0;
                if (!sameDirection)
                {
                    continue;
                }
                if ((parameterFlags & RpceParameterAttributes.IsPipe) != 0)
                {
                    continue;
                }
                if (!isClient && (parameterFlags & RpceParameterAttributes.IsPartialIgnore) != 0)
                {
                    parameterList[i] = NdrInt32Unmarshal() != 0 ? 1 : 0;
                    continue;
                }

                RpceFormatCharType formatChar;
                if ((parameterFlags & RpceParameterAttributes.IsBaseType) != 0)
                {
                    formatChar = (RpceFormatCharType)parameterTypeFormatStringOffset;
                }
                else
                {
                    formatChar = (RpceFormatCharType)Marshal.ReadByte(
                        stubDesc.pFormatTypes,
                        parameterTypeFormatStringOffset);
                }

                parameterList[i] = NdrUnmarshalRoutines(parameters[i], parameterTypeFormatStringOffset, formatChar);


                if ((parameterFlags & RpceParameterAttributes.IsBaseType) != 0
                    && (parameterFlags & RpceParameterAttributes.IsSimpleRef) != 0)
                {
                    IntPtr ptr = Marshal.AllocHGlobal(sizeof(ulong));//ulong is max size of simple type.
                    FreeMemoryAtDispose(ptr);
                    Marshal.WriteIntPtr(ptr, parameterList[i]);
                    parameterList[i] = ptr;
                }
            }

            return parameterList.ToArray();
        }


        /// <summary>
        /// Unmarshal a parameter.
        /// </summary>
        /// <param name="arg">A parameter.</param>
        /// <param name="typeFormatStringOffset">Offset of a parameter in typeFormatString.</param>
        /// <param name="formatChar">Format char.</param>
        /// <returns>Unmarshalled pointer to the parameter.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private Int3264 NdrUnmarshalRoutines(
            Int3264 arg,
            int typeFormatStringOffset,
            RpceFormatCharType formatChar)
        {
            Int3264 retVal = 0;

            switch ((RpceFormatCharType)((int)formatChar & FORMAT_CHAR_ROUTINE_BITMASK))
            {
                case RpceFormatCharType.FC_ZERO:
                    throw new InvalidOperationException("Bad format char: FC_ZERO.");

                case RpceFormatCharType.FC_BYTE:
                case RpceFormatCharType.FC_CHAR:
                case RpceFormatCharType.FC_SMALL:
                case RpceFormatCharType.FC_USMALL:
                    retVal = (int)NdrByteUnmarshal();
                    break;

                case RpceFormatCharType.FC_WCHAR:
                case RpceFormatCharType.FC_SHORT:
                case RpceFormatCharType.FC_USHORT:
                    retVal = (int)NdrInt16Unmarshal();
                    break;

                case RpceFormatCharType.FC_LONG:
                case RpceFormatCharType.FC_ULONG:
                case RpceFormatCharType.FC_FLOAT:
                    retVal = NdrInt32Unmarshal();
                    break;

                case RpceFormatCharType.FC_HYPER:
                case RpceFormatCharType.FC_DOUBLE:
                    retVal = NdrInt64Unmarshal();
                    break;

                case RpceFormatCharType.FC_ENUM16:
                    retVal = (int)NdrInt16Unmarshal();
                    break;

                case RpceFormatCharType.FC_ENUM32:
                    retVal = NdrInt32Unmarshal();
                    break;

                case RpceFormatCharType.FC_ERROR_STATUS_T:
                    retVal = NdrInt32Unmarshal();
                    break;

                case RpceFormatCharType.FC_RP:
                case RpceFormatCharType.FC_UP:
                case RpceFormatCharType.FC_OP:
                case RpceFormatCharType.FC_FP:
                    retVal = NdrPointerUnmarshall(typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_STRUCT:
                case RpceFormatCharType.FC_PSTRUCT:
                    retVal = NdrSimpleStructUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_CSTRUCT:
                case RpceFormatCharType.FC_CPSTRUCT:
                    retVal = NdrConformantStructUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_CVSTRUCT:
                    retVal = NdrConformantVaryingStructUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_BOGUS_STRUCT:
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_FORCED_BOGUS_STRUCT & FORMAT_CHAR_ROUTINE_BITMASK):
                    retVal = NdrComplexStructUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_CARRAY:
                    retVal = NdrConformantArrayUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_CVARRAY:
                    retVal = NdrConformantVaryingArrayUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_SMFARRAY:
                case RpceFormatCharType.FC_LGFARRAY:
                    retVal = NdrFixedArrayUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_SMVARRAY:
                case RpceFormatCharType.FC_LGVARRAY:
                    retVal = NdrVaryingArrayUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_BOGUS_ARRAY:
                    retVal = NdrComplexArrayUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_C_CSTRING:
                case RpceFormatCharType.FC_C_BSTRING:
                case RpceFormatCharType.FC_C_SSTRING:
                case RpceFormatCharType.FC_C_WSTRING:
                    retVal = NdrConformantStringUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_CSTRING:
                case RpceFormatCharType.FC_BSTRING:
                case RpceFormatCharType.FC_SSTRING:
                case RpceFormatCharType.FC_WSTRING:
                    retVal = NdrNonConformantStringUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_ENCAPSULATED_UNION:
                    retVal = NdrEncapsulatedUnionUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_NON_ENCAPSULATED_UNION:
                    retVal = NdrNonEncapsulatedUnionUnmarshall(typeFormatStringOffset, 0);
                    break;

                case RpceFormatCharType.FC_BYTE_COUNT_POINTER:
                    retVal = NdrByteCountPointerUnmarshall(typeFormatStringOffset, arg.ToIntPtr(), 0);
                    break;

                case RpceFormatCharType.FC_IP:
                    retVal = NdrPointerUnmarshall(typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BIND_CONTEXT:
                    retVal = NdrContextHandleUnmarshall(arg, typeFormatStringOffset);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_SUPPLEMENT & FORMAT_CHAR_ROUTINE_BITMASK):
                    retVal = NdrSupplementUnmarshall(arg, typeFormatStringOffset, 0);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_RANGE & FORMAT_CHAR_ROUTINE_BITMASK):
                    retVal = NdrRangeUnmarshall(typeFormatStringOffset);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_INT3264 & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_UINT3264 & FORMAT_CHAR_ROUTINE_BITMASK):
                    if (IntPtr.Size == sizeof(int))
                    {
                        retVal = NdrInt32Unmarshal();
                    }
                    else if (IntPtr.Size == sizeof(long))
                    {
                        retVal = NdrInt64Unmarshal();
                    }
                    else
                    {
                        throw new InvalidOperationException("Unsupported platform.");
                    }
                    break;

                case (RpceFormatCharType)0x0f: // Ignore
                    break;

                case RpceFormatCharType.FC_TRANSMIT_AS:
                case RpceFormatCharType.FC_REPRESENT_AS:
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_TRANSMIT_AS_PTR & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_REPRESENT_AS_PTR & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_USER_MARSHAL & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_PIPE & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_CSARRAY & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_CS_TAG & FORMAT_CHAR_ROUTINE_BITMASK):
                    throw new NotSupportedException(
                        "transmit_as, represent_as, user_marshal, pipe and csarray are not supported.");

                default:
                    throw new InvalidOperationException(
                        string.Format("Unsupported type format char {0}.", formatChar));
            }

            return retVal;
        }


        /// <summary>
        /// Initialize NDR server context.
        /// </summary>
        public void NdrServerInitializeNew()
        {
            NativeMethods.RPC_MESSAGE rpcMessage = new NativeMethods.RPC_MESSAGE();
            rpcMessage.Buffer = pBytesToDecode;
            rpcMessage.BufferLength = (uint)bytesToDecodeLength;
            rpcMessage.DataRepresentation = NativeMethods.NDR_LOCAL_DATA_REPRESENTATION;
            rpcMessage.RpcFlags = NativeMethods.RPC_BUFFER_COMPLETE;
            pRpcMsg = Marshal.AllocHGlobal(Marshal.SizeOf(rpcMessage));
            Marshal.StructureToPtr(rpcMessage, pRpcMsg, false);

            NativeMethods.MIDL_STUB_MESSAGE stubMsg = new NativeMethods.MIDL_STUB_MESSAGE();
            stubMsg.Buffer = rpcMessage.Buffer;
            stubMsg.BufferStart = rpcMessage.Buffer;
            stubMsg.BufferLength = rpcMessage.BufferLength;
            stubMsg.BufferEnd = IntPtrUtility.Add(stubMsg.BufferStart, (int)stubMsg.BufferLength);
            pStubMsg = Marshal.AllocHGlobal(Marshal.SizeOf(stubMsg));
            Marshal.StructureToPtr(stubMsg, pStubMsg, false);

            pStubDesc = Marshal.AllocHGlobal(Marshal.SizeOf(stubDesc));
            Marshal.StructureToPtr(stubDesc, pStubDesc, false);

            NativeMethods.NdrServerInitializeNew(pRpcMsg, pStubMsg, pStubDesc);
        }


        /// <summary>
        /// Unmarshal a primitive type.
        /// </summary>
        /// <param name="type">Data type</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        private IntPtr NdrUnmarshal(Type type)
        {
            int size = Marshal.SizeOf(type);
            int offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "Buffer").ToInt32();
            IntPtr ptr = Marshal.ReadIntPtr(pStubMsg, offset);
            ptr = IntPtrUtility.Align(ptr, size);
            Marshal.WriteIntPtr(
                pStubMsg,
                offset,
                IntPtrUtility.Add(ptr, size));
            return ptr;
        }


        /// <summary>
        /// Unmarshal a single byte.
        /// </summary>
        /// <returns>Unmarshalled byte.</returns>
        public byte NdrByteUnmarshal()
        {
            return Marshal.ReadByte(NdrUnmarshal(typeof(byte)));
        }


        /// <summary>
        /// Unmashal a 16-byte signed integer.
        /// </summary>
        /// <returns>Unmarshalled short.</returns>
        public short NdrInt16Unmarshal()
        {
            return Marshal.ReadInt16(NdrUnmarshal(typeof(short)));
        }


        /// <summary>
        /// Unmashal a 32-byte signed integer.
        /// </summary>
        /// <returns>Unmarshalled int.</returns>
        public int NdrInt32Unmarshal()
        {
            return Marshal.ReadInt32(NdrUnmarshal(typeof(int)));
        }


        /// <summary>
        /// Unmashal a 64-byte signed integer.
        /// </summary>
        /// <returns>Unmarshalled long.</returns>
        public long NdrInt64Unmarshal()
        {
            return Marshal.ReadInt64(NdrUnmarshal(typeof(long)));
        }


        /// <summary>
        /// The NdrPointerUnmarshall function unmarshalls a top level pointer to anything. 
        /// Pointers embedded in structures, arrays, or unions call NdrPointerUnmarshall directly. 
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrPointerUnmarshall(int formatStringOffset)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrPointerUnmarshall(pStubMsg, ref pValue, pFormat, 0);
            return pValue;
        }


        /// <summary>
        /// The NdrSimpleStructUnmarshall function unmarshals the simple structure 
        /// from the network buffer to memory.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">
        /// Flag that specifies whether the stub must allocate the memory into 
        /// which the simple structure is to be marshaled. 
        /// Specify TRUE if RPC must allocate ppMemory. 
        /// </param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrSimpleStructUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrSimpleStructUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);
            return pValue;
        }


        /// <summary>
        /// The NdrComplexStructUnmarshall function unmarshals the complex structure 
        /// from the network buffer to memory.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">
        /// Flag that specifies whether the stub must allocate the memory into 
        /// which the complex structure is to be marshaled. 
        /// Specify TRUE if RPC must allocate ppMemory.
        /// </param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrComplexStructUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrComplexStructUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);
            return pValue;
        }


        /// <summary>
        /// The NdrSimpleTypeUnmarshall function unmarshalls a simple type.
        /// </summary>
        /// <param name="pMemory">Pointer to memory to unmarshall.</param>
        /// <param name="formatChar">Format char of the simple type.</param>
        public void NdrSimpleTypeUnmarshall(IntPtr pMemory, RpceFormatCharType formatChar)
        {
            NativeMethods.NdrSimpleTypeUnmarshall(pStubMsg, pMemory, (byte)formatChar);
        }


        /// <summary>
        /// Unmarshalls a non encapsulated union.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored</param>
        /// <returns>Double pointer to where the union should be unmarshalled.</returns>
        public IntPtr NdrNonEncapsulatedUnionUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrNonEncapsulatedUnionUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);
            return pValue;
        }


        /// <summary>
        /// Unmarshalls a top level conformant string.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">TRUE if the array must be allocated, FALSE otherwise.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrConformantStringUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantStringUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a top level one dimensional conformant array.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">TRUE if the array must be allocated, FALSE otherwise.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrConformantArrayUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantArrayUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a fixed array of any number of dimensions.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">TRUE if the array must be allocated, FALSE otherwise.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrFixedArrayUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrFixedArrayUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshall a [range] parameter.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <returns>The unmarshalled range parameter.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        public IntPtr NdrRangeUnmarshall(int formatStringOffset)
        {
            // offset + 1 is the place of real format string of this parameter.
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset + 1);
            RpceFormatCharType formatChar = (RpceFormatCharType)Marshal.ReadByte(pFormat);

            //Range is base type only.
            //pArg is ignored for base types.
            IntPtr pValue = NdrUnmarshalRoutines(IntPtr.Zero, formatStringOffset, formatChar);
            return pValue;
        }


        /// <summary>
        /// Unmarshalls a supplement.
        /// </summary>
        /// <param name="pArg">Pointer to a parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters")]
        public IntPtr NdrSupplementUnmarshall(IntPtr pArg, int formatStringOffset, byte mustAlloc)
        {
            // offset + 2 is the size of supplement header size (ushort), skip the size.
            formatStringOffset += 2;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            int supplementOffset = Marshal.ReadInt16(pFormat);
            formatStringOffset += supplementOffset;
            pFormat = IntPtrUtility.Add(pFormat, supplementOffset);
            RpceFormatCharType formatChar = (RpceFormatCharType)Marshal.ReadByte(pFormat);

            return NdrUnmarshalRoutines(pArg, formatStringOffset, formatChar);
        }


        /*/// <summary>
        /// Unmarshalls a user marshal object.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrUserMarshalUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrUserMarshalUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }*/


        /// <summary>
        /// Unmarshalls a context handle.
        /// </summary>
        /// <param name="contextHandle">A input context handle to unmarshall.</param>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        public IntPtr NdrContextHandleUnmarshall(IntPtr contextHandle, int formatStringOffset)
        {
            // offset + 1 contains the flag of isHandlePtr.
            // offset + 3 contains the flag of isHandleComplex.
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset + 1);
            bool isHandlePtr = (Marshal.ReadByte(pFormat) & 0x80) != 0;
            pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset + 3);
            bool isHandleComplex = (Marshal.ReadByte(pFormat) & 0x80) != 0;

            if ((isHandleComplex || isHandlePtr) && contextHandle != IntPtr.Zero)
            {
                contextHandle = Marshal.ReadIntPtr(contextHandle);
            }

            //Release old context handle.
            if (contextHandle != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(contextHandle);
            }

            //Unmarshal
            int offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "Buffer").ToInt32();
            IntPtr ptr = Marshal.ReadIntPtr(pStubMsg, offset);
            ptr = IntPtrUtility.Align(ptr, CONTEXT_HANDLE_ALIGNMENT);
            Marshal.WriteIntPtr(
                pStubMsg,
                offset,
                IntPtrUtility.Add(ptr, CONTEXT_HANDLE_WIRE_SIZE));

            bool isZeroContextHandle = true;
            for (int i = 0; i < CONTEXT_HANDLE_WIRE_SIZE; i+=sizeof(Int32))
            {
                if (Marshal.ReadInt32(IntPtrUtility.Add(ptr, i)) != 0)
                {
                    isZeroContextHandle = false;
                    break;
                }
            }

            IntPtr contextPtr;
            if (isZeroContextHandle)
            {
                contextPtr = IntPtr.Zero;
            }
            else
            {
                contextPtr = Marshal.AllocHGlobal(CONTEXT_HANDLE_WIRE_SIZE);
                NativeMethods.RtlMoveMemory(contextPtr, ptr, CONTEXT_HANDLE_WIRE_SIZE);
            }

            if (isHandleComplex || isHandlePtr)
            {
                ptr = Marshal.AllocHGlobal(IntPtr.Size);
                FreeMemoryAtDispose(ptr);
                Marshal.WriteIntPtr(ptr, contextPtr);
                contextPtr = ptr;
            }

            return contextPtr;
        }


        /*/// <summary>
        /// Unmarshalls a transmit as or represent as argument.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrXmitOrRepAsUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrXmitOrRepAsUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }*/


        /// <summary>
        /// Unmarshalls a byte count pointer.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="pMemory">Client allocated memory</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrByteCountPointerUnmarshall(int formatStringOffset, IntPtr pMemory, byte mustAlloc)
        {
            IntPtr pValue = pMemory;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrByteCountPointerUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls an encapsulated union.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrEncapsulatedUnionUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrEncapsulatedUnionUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a non conformant string.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrNonConformantStringUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrNonConformantStringUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a complex array.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrComplexArrayUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrComplexArrayUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a varying array.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrVaryingArrayUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrVaryingArrayUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a conformant varying array.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrConformantVaryingArrayUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantVaryingArrayUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a conformant varying structure.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrConformantVaryingStructUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantVaryingStructUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }


        /// <summary>
        /// Unmarshalls a conformant structure.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string</param>
        /// <param name="mustAlloc">Ignored.</param>
        /// <returns>Pointer to memory where pointer be unmarshalled.</returns>
        public IntPtr NdrConformantStructUnmarshall(int formatStringOffset, byte mustAlloc)
        {
            IntPtr pValue = IntPtr.Zero;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantStructUnmarshall(pStubMsg, ref pValue, pFormat, mustAlloc);

            return pValue;
        }
    }
}
