// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;

namespace Microsoft.Protocols.TestTools.StackSdk.Networking.Rpce
{
    /// <summary>
    /// RpceStub is a base class for RpceStubEncoder and RpceStubDecoder. 
    /// Do not create an instance of this class directly.
    /// </summary>
    public abstract class RpceStub : IDisposable
    {
        /// <summary>
        /// Ranged NDR correlation check extension size.
        /// </summary>
        protected const byte RANGED_NDR_CORR_EXTENSION_SIZE = 12;

        /// <summary>
        /// Regular NDR correlation check extension size.
        /// </summary>
        protected const byte NDR_CORR_EXTENSION_SIZE = 2;

        /// <summary>
        /// Simple type bitmask of format char.
        /// </summary>
        protected const int FORMAT_CHAR_SIMPLE_TYPE_BITMASK = 0x0F;
        
        /// <summary>
        /// BufferSize, Marshall and Unmarshall routine bitmask of format char.
        /// </summary>
        protected const int FORMAT_CHAR_ROUTINE_BITMASK = 0x3F;

        /// <summary>
        /// Size of context handle transferred on wire.
        /// </summary>
        protected const int CONTEXT_HANDLE_WIRE_SIZE = 20;

        /// <summary>
        /// Context handle alignment.
        /// </summary>
        protected const int CONTEXT_HANDLE_ALIGNMENT = 4;


        // RPC stub descriptor and stub message.
        internal NativeMethods.MIDL_STUB_DESC stubDesc;
        internal IntPtr pStubMsg;
        private List<NativeMethods.EXPR_EVAL> exprEvalList;

        // Keep reference to allocated memory, release them at Dispose.
        private List<IntPtr> allocatedMemoryList;


        #region IDisposable Members

        /// <summary>
        /// Dispose method.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }


        /// <summary>
        /// Dispose method.
        /// </summary>
        /// <param name="disposing">
        /// True to release both managed and unmanaged resources.<para/>
        /// False to release unmanaged resources only.
        /// </param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Release managed resources.
            }

            // Release unmanaged resources.
            if (allocatedMemoryList != null)
            {
                for (int i = 0; i < allocatedMemoryList.Count; i++)
                {
                    Marshal.FreeHGlobal(allocatedMemoryList[i]);
                }
                allocatedMemoryList = null;
            }
            if (stubDesc.RpcInterfaceInformation != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(stubDesc.RpcInterfaceInformation);
                stubDesc.RpcInterfaceInformation = IntPtr.Zero;
            }
            if (stubDesc.apfnExprEval != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(stubDesc.apfnExprEval);
                stubDesc.apfnExprEval = IntPtr.Zero;
            }
            if (stubDesc.pFormatTypes != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(stubDesc.pFormatTypes);
                stubDesc.pFormatTypes = IntPtr.Zero;
            }
        }


        /// <summary>
        /// finalizer
        /// </summary>
        ~RpceStub()
        {
            Dispose(false);
        }

        #endregion


        /// <summary>
        /// constructor.
        /// </summary>
        /// <param name="runtimeTargetPlatform">Runtime platform, x86 or amd64.</param>
        /// <param name="typeFormatString">Type format string generated by MIDL.</param>
        /// <param name="exprEvalRoutines">ExprEvalRoutines generated by MIDL if exists.</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown when typeFormatString is null.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown when runtimeTargetPlatform doesn't match current platform at runtime.
        /// </exception>
        protected RpceStub(
            RpceStubTargetPlatform runtimeTargetPlatform,
            byte[] typeFormatString,
            RpceStubExprEval[] exprEvalRoutines)
        {
            if (typeFormatString == null)
            {
                throw new ArgumentNullException("typeFormatString");
            }
            if ((IntPtr.Size == sizeof(Int32) && (runtimeTargetPlatform & RpceStubTargetPlatform.X86) != RpceStubTargetPlatform.X86) ||
                (IntPtr.Size == sizeof(Int64) && (runtimeTargetPlatform & RpceStubTargetPlatform.Amd64) != RpceStubTargetPlatform.Amd64))
            {
                throw new InvalidOperationException("Invalid target platform.");
            }

            allocatedMemoryList = new List<IntPtr>();

            #region RPC_CLIENT_INTERFACE rpcClientInterface

            NativeMethods.RPC_CLIENT_INTERFACE rpcClientInterface = new NativeMethods.RPC_CLIENT_INTERFACE();
            rpcClientInterface.Length = (uint)Marshal.SizeOf(typeof(NativeMethods.RPC_CLIENT_INTERFACE));

            rpcClientInterface.InterfaceId.SyntaxGUID = RpceStubEncoder.RPCE_BIND_ONLY_SERVER.IF_ID;
            rpcClientInterface.InterfaceId.SyntaxVersion.MajorVersion = RpceStubEncoder.RPCE_BIND_ONLY_SERVER.IF_VERS_MAJOR;
            rpcClientInterface.InterfaceId.SyntaxVersion.MinorVersion = RpceStubEncoder.RPCE_BIND_ONLY_SERVER.IF_VERS_MINOR;

            rpcClientInterface.TransferSyntax.SyntaxGUID = RpceUtility.NDR_INTERFACE_UUID;
            rpcClientInterface.TransferSyntax.SyntaxVersion.MajorVersion = RpceUtility.NDR_INTERFACE_MAJOR_VERSION;
            rpcClientInterface.TransferSyntax.SyntaxVersion.MinorVersion = RpceUtility.NDR_INTERFACE_MINOR_VERSION;

            rpcClientInterface.DispatchTable = IntPtr.Zero;
            rpcClientInterface.RpcProtseqEndpointCount = 0;
            rpcClientInterface.RpcProtseqEndpoint = IntPtr.Zero;
            rpcClientInterface.Reserved = 0;
            rpcClientInterface.InterpreterInfo = IntPtr.Zero;
            rpcClientInterface.Flags = 0x00000000;

            #endregion

            #region MIDL_STUB_DESC stubDesc

            stubDesc = new NativeMethods.MIDL_STUB_DESC();
            stubDesc.RpcInterfaceInformation = Marshal.AllocHGlobal(Marshal.SizeOf(rpcClientInterface));
            Marshal.StructureToPtr(rpcClientInterface, stubDesc.RpcInterfaceInformation, false);

            stubDesc.pfnAllocate = new NativeMethods.PfnAllocate(MIDL_user_allocate);
            stubDesc.pfnFree = new NativeMethods.PfnFree(MIDL_user_free);

            stubDesc.apfnNdrRundownRoutines = IntPtr.Zero;
            stubDesc.aGenericBindingRoutinePairs = IntPtr.Zero;

            if (exprEvalRoutines == null || exprEvalRoutines.Length == 0)
            {
                stubDesc.apfnExprEval = IntPtr.Zero;
            }
            else
            {
                exprEvalList = new List<NativeMethods.EXPR_EVAL>(exprEvalRoutines.Length);
                stubDesc.apfnExprEval = Marshal.AllocHGlobal(IntPtr.Size * exprEvalRoutines.Length);
                for (int i = 0; i < exprEvalRoutines.Length; i++)
                {
                    RpceStubExprEvalCallback callback = new RpceStubExprEvalCallback(this, exprEvalRoutines[i]);
                    NativeMethods.EXPR_EVAL exprEval = new NativeMethods.EXPR_EVAL(callback.EXPR_EVAL);
                    IntPtr funcPtr = Marshal.GetFunctionPointerForDelegate(exprEval);
                    Marshal.WriteIntPtr(stubDesc.apfnExprEval, IntPtr.Size * i, funcPtr);

                    //http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.getfunctionpointerfordelegate.aspx
                    //Caller must manually keep the delegate from being collected by 
                    // the garbage collector from managed code. 
                    exprEvalList.Add(exprEval);
                }
            }
            stubDesc.aXmitQuintuple = IntPtr.Zero;

            stubDesc.pFormatTypes = Marshal.AllocHGlobal(typeFormatString.Length);
            Marshal.Copy(typeFormatString, 0, stubDesc.pFormatTypes, typeFormatString.Length);

            stubDesc.fCheckBounds = 0; /* -error bounds_check flag : "midl /error none" */
            stubDesc.Version = 0x50000; /* Ndr library version */
            stubDesc.pMallocFreeStruct = IntPtr.Zero;
            stubDesc.MIDLVersion = 0x70001e6; /* MIDL Version 7.0.486 */
            stubDesc.CommFaultOffsets = IntPtr.Zero;
            stubDesc.aUserMarshalQuadruple = IntPtr.Zero;
            stubDesc.NotifyRoutineTable = IntPtr.Zero;  /* notify & notify_flag routine table */
            stubDesc.mFlags = 0x1; /* MIDL flag */
            stubDesc.CsRoutineTables = IntPtr.Zero; /* cs routines */
            stubDesc.ProxyServerInfo = IntPtr.Zero; /* proxy/server native */
            stubDesc.pExprInfo = IntPtr.Zero; /* Reserved5 */

            #endregion

        }


        /// <summary>
        /// Callback function to allocate memory, used by NDR engine.<para/>
        /// Copied from midl.exe generated stub code.
        /// </summary>
        /// <param name="s">Buffer size.</param>
        /// <returns>Pointer to allocated memory.</returns>
        private IntPtr MIDL_user_allocate(uint s)
        {
            IntPtr p = Marshal.AllocHGlobal((int)s);
            //Save the pointer, release it at MIDL_user_free or Dispose().
            allocatedMemoryList.Add(p);
            return p;
        }


        /// <summary>
        /// Callback function to free allocated memory , used by NDR engine.<para/>
        /// Copied from midl.exe generated stub code.
        /// </summary>
        /// <param name="p">Pointer to allocated memory.</param>
        private void MIDL_user_free(IntPtr p)
        {
            allocatedMemoryList.Remove(p);
            Marshal.FreeHGlobal(p);
        }


        #region Get/Set MIDL_STUB_MESSAGE fields

        /// <summary>
        /// Get BufferLength field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <returns>The value of BufferLength field.</returns>
        //We want to use a method to get BufferLength, suppress fxcop CA1024.
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
        public uint GetBufferLength()
        {
            IntPtr offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "BufferLength");
            return (uint)Marshal.ReadInt32(pStubMsg, offset.ToInt32());
        }


        /// <summary>
        /// Set BufferLength field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <param name="length">The value of BufferLength field.</param>
        public void SetBufferLength(uint length)
        {
            IntPtr offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "BufferLength");
            Marshal.WriteInt32(pStubMsg, offset.ToInt32(), (int)length);
        }


        /// <summary>
        /// Get StackTop field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <returns>The value of StackTop field.</returns>
        //We want to use a method to get StackTop, suppress fxcop CA1024.
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
        public IntPtr GetStackTop()
        {
            IntPtr offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "StackTop");
            return Marshal.ReadIntPtr(pStubMsg, offset.ToInt32());
        }


        /// <summary>
        /// Set StackTop field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <param name="stackTop">The value of StackTop field.</param>
        public void SetStackTop(IntPtr stackTop)
        {
            IntPtr offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "StackTop");
            Marshal.WriteIntPtr(pStubMsg, offset.ToInt32(), stackTop);
        }


        /// <summary>
        /// Get MaxCount field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <param name="maxCount">The value of MaxCount field.</param>
        public void SetMaxCount(uint maxCount)
        {
            IntPtr offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "MaxCount");
            Marshal.WriteIntPtr(pStubMsg, offset.ToInt32(), new IntPtr(maxCount));
        }


        /// <summary>
        /// Get Offset field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <param name="offset">The value of Offset field.</param>
        public void SetOffset(uint offset)
        {
            IntPtr ofs = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "Offset");
            Marshal.WriteInt32(pStubMsg, ofs.ToInt32(), (int)offset);
        }


        /// <summary>
        /// Get CorrDespIncrement field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <param name="corrDespIncrement">The value of CorrDespIncrement field.</param>
        public void SetCorrDespIncrement(byte corrDespIncrement)
        {
            IntPtr ofs = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "fBufferValid");
            Marshal.WriteInt32(pStubMsg, ofs.ToInt32(), (int)corrDespIncrement);
        }

        /// <summary>
        /// Set OffsetIsClient field of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <param name="isClient">Is client side.</param>
        public void SetIsClient(bool isClient)
        {
            IntPtr offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "IsClient");
            Marshal.WriteInt32(pStubMsg, offset.ToInt32(), isClient? 1 : 0);
        }

        /// <summary>
        /// Get IsClient field of MIDL_STUB_MESSAGE.
        /// </summary>
        public bool GetIsClient()
        {
            IntPtr offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "IsClient");
            return (Marshal.ReadInt32(pStubMsg, offset.ToInt32()) == 1) ? true : false;
        }

        #endregion


        /// <summary>
        /// Save parameters into StackTop of MIDL_STUB_MESSAGE.
        /// </summary>
        /// <param name="procFormatString">ProcFormatString generated by MIDL.</param>
        /// <param name="offset">Offset of a procedure in procFormatString.</param>
        /// <param name="stackSize">Stack size of all parameters.</param>
        /// <param name="parameters">Parameters</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        protected void SaveParametersIntoStack(byte[] procFormatString, int offset, int stackSize, Int3264[] parameters)
        {
            // ensure the stack is large enough, because we may write the last parameter over size.
            byte[] stack = new byte[stackSize + sizeof(long)];
            for (int i = 0; i < parameters.Length; i++)
            {
                offset += sizeof(RpceParameterAttributes); // skip flags
                ushort stackOffset = BitConverter.ToUInt16(procFormatString, offset);
                offset += sizeof(ushort);
                offset += sizeof(ushort); //skip typeFormaString offset, move to next parameter.

                Buffer.BlockCopy(
                    BitConverter.GetBytes(parameters[i].ToInt64()),
                    0,
                    stack,
                    stackOffset,
                    sizeof(ulong));
            }

            IntPtr ptr = Marshal.AllocHGlobal(stack.Length);
            Marshal.Copy(stack, 0, ptr, stack.Length);
            SetStackTop(ptr);
            FreeMemoryAtDispose(ptr);
        }


        /// <summary>
        /// Free specified memory at Dispose.
        /// </summary>
        /// <param name="ptr">Pointer to the memory.</param>
        protected void FreeMemoryAtDispose(IntPtr ptr)
        {
            allocatedMemoryList.Add(ptr);
        }


        /// <summary>
        /// This function converts the network buffer from the data representation of 
        /// the sender to the data representation of the receiver if they are different.
        /// </summary>
        /// <param name="procFormatString">Proc format string generated by MIDL.</param>
        /// <param name="formatStringOffset">Offset of a parameter in typeFormatString.</param>
        /// <param name="numberParams">The number of parameters in the procedure.</param>
        /// <param name="isClient">Is client side.</param>
        public void NdrConvertIfNecessary(byte[] procFormatString, int formatStringOffset, long numberParams, bool isClient)
        {
            IntPtr offset;

            offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "RpcMsg");
            IntPtr pRpcMsg = Marshal.ReadIntPtr(pStubMsg, offset.ToInt32());

            offset = Marshal.OffsetOf(typeof(NativeMethods.RPC_MESSAGE), "DataRepresentation");
            uint dataRepresentation = (uint)Marshal.ReadInt32(pRpcMsg, offset.ToInt32());

            if ((dataRepresentation & 0x0000FFFFU) == NativeMethods.NDR_LOCAL_DATA_REPRESENTATION)
            {
                return;
            }

            if (isClient)
            {
                IntPtr pFormat = Marshal.AllocHGlobal(procFormatString.Length);
                Marshal.Copy(procFormatString, 0, pFormat, procFormatString.Length);
                IntPtr fmt = IntPtrUtility.Add(pFormat, formatStringOffset);

                // We use server stub when decoding, so pStubMsg->IsClient is false.
                // However, this flag is used when doing endian convert. So we save it first and
                // then set it to true and convert back.
                //
                // NdrConvert2 is the entry point for endian conversion of all parameters. We use
                // NdrConvert2 here instead of calling the type specific convert routine ourselves
                // (like what we do in marshal/unmarshal), because convert routines for each type
                // are not exported in rpcrt4.dll, unlike marshal/unmarshal routines.
                bool stubIsClientSaved = GetIsClient();
                SetIsClient(isClient);
                NativeMethods.NdrConvert2(pStubMsg, fmt, numberParams);
                SetIsClient(stubIsClientSaved);

                Marshal.FreeHGlobal(pFormat);
            }
        }


        /// <summary>
        /// Performs an RpcFreeBuffer.
        /// </summary>
        public void NdrFreeBuffer()
        {
            NativeMethods.NdrFreeBuffer(pStubMsg);
        }

    }
}
