// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Runtime.InteropServices;

namespace Microsoft.Protocols.TestTools.StackSdk.Networking.Rpce
{
    /// <summary>
    /// Helper class for encode/decode RPC stub.<para/>
    /// </summary>
    public static class RpceStubHelper
    {
        /// <summary>
        /// Get a byte array from the format string generated by midl.exe.<para/>
        /// Example: Regarding following code generated by midl.exe<para/>
        /// static const foo_MIDL_TYPE_FORMAT_STRING foo__MIDL_TypeFormatString =<para/>
        /// {<para/>
        ///     0,<para/>
        ///     {<para/>
        ///         NdrFcShort( 0x0 ),	/* 0 */<para/>
        /// /*  2 */<para/>
        ///         0x11, 0x0,	/* FC_RP */<para/>
        /// /*  4 */<para/>
        ///         NdrFcShort( 0x10 ),	/* Offset= 16 (20) */<para/>
        /// /*  6 */<para/>
        ///         0x1c,		/* FC_CVARRAY */<para/>
        ///         ...<para/>
        ///     }<para/>
        /// };<para/>
        /// The formatString parameter should be a substring 
        /// start from "NdrFcShort(0x0)" and end at first"}".
        /// </summary>
        /// <param name="formatString">
        /// A format string generated by midl.exe. See method help for details.
        /// </param>
        /// <returns>A byte array of the format string passed to the method.</returns>
        public static byte[] CreateFormatStringByteArray(string formatString)
        {
            int index = 0;
            List<byte> formatStringBuffer = new List<byte>();

            Regex regex = new Regex(@"
0x (?<byte>[0-9a-fA-F]{1,2}) \s* ,
|
NdrFcShort \( \s* 0x (?<short>[0-9a-fA-F]{1,4}) \s* \)
|
NdrFcLong \( \s* 0x (?<long>[0-9a-fA-F]+) \s* \)
|
\n \/\* \s* (?<offset>\d+)* \s* \*\/
|
\/\* .* \*\/
",
                RegexOptions.IgnorePatternWhitespace);

            while (true)
            {
                Match match = regex.Match(formatString, index);
                if (!match.Success)
                {
                    break;
                }
                if (match.Groups["byte"].Success)
                {
                    byte value = Convert.ToByte(match.Groups["byte"].Value, 16);
                    formatStringBuffer.Add(value);
                }
                else if (match.Groups["short"].Success)
                {
                    ushort value = Convert.ToUInt16(match.Groups["short"].Value, 16);
                    formatStringBuffer.Add((byte)(value & 0xff));
                    formatStringBuffer.Add((byte)(value >> 8));
                }
                else if (match.Groups["long"].Success)
                {
                    uint value = Convert.ToUInt32(match.Groups["long"].Value, 16);
                    formatStringBuffer.Add((byte)(value & 0xff));
                    formatStringBuffer.Add((byte)((value >> 8) & 0xff));
                    formatStringBuffer.Add((byte)((value >> 16) & 0xff));
                    formatStringBuffer.Add((byte)(value >> 24));
                }
                else if (match.Groups["offset"].Success)
                {
                    int offset = Convert.ToInt32(match.Groups["offset"].Value);
                    if (formatStringBuffer.Count != offset)
                        throw new InvalidOperationException();
                }
                index = match.Index + match.Length;
            }

            return formatStringBuffer.ToArray();
        }


        /// <summary>
        /// Parse procedure header a from byte array to structure.
        /// </summary>
        /// <param name="procFormatString">Proc format string.</param>
        /// <param name="offset">Offset of a procedure in procFormatString.</param>
        /// <returns>The RpceProcedureHeaderDescriptor.</returns>
        public static RpceProcedureHeaderDescriptor ParseProcedureHeaderDescriptor(
            byte[] procFormatString,
            ref int offset)
        {
            //handle_type<1> 
            //Oi_flags<1>
            //[rpc_flags<4>]
            //proc_num<2>  
            //stack_size<2>
            //[explicit_handle_description<>]
            //constant_client_buffer_size<2>
            //constant_server_buffer_size<2>
            //INTERPRETER_OPT_FLAGS<1>
            //number_of_params<1>
            //extension_size<1>
            //[extension]

            const byte FC_BIND_PRIMITIVE = 0x32;
            const int PRIMITIVE_HANDLE_LENGTH = 4;
            const int OTHER_HANDLE_LENGTH = 6;
            const byte OI_HAS_RPCFLAGS = 0x08;
            const int EXTENSION_SIZE = 8;

            RpceProcedureHeaderDescriptor procHeaderDesc = new RpceProcedureHeaderDescriptor();

            procHeaderDesc.HandleType = procFormatString[offset];
            offset += Marshal.SizeOf(procHeaderDesc.HandleType);
            procHeaderDesc.OiFlags = procFormatString[offset];
            offset += Marshal.SizeOf(procHeaderDesc.OiFlags);
            if ((procHeaderDesc.OiFlags & OI_HAS_RPCFLAGS) != 0)
            {
                procHeaderDesc.RpcFlags = BitConverter.ToUInt32(procFormatString, offset);
                offset += Marshal.SizeOf(procHeaderDesc.RpcFlags.Value);
            }
            procHeaderDesc.ProcNum = BitConverter.ToUInt16(procFormatString, offset);
            offset += Marshal.SizeOf(procHeaderDesc.ProcNum);
            procHeaderDesc.StackSize = BitConverter.ToUInt16(procFormatString, offset);
            offset += Marshal.SizeOf(procHeaderDesc.StackSize);
            if (procHeaderDesc.HandleType == 0) // explicit handle
            {
                int length = (procFormatString[offset] == FC_BIND_PRIMITIVE) 
                    ? PRIMITIVE_HANDLE_LENGTH
                    : OTHER_HANDLE_LENGTH;
                procHeaderDesc.ExplicitHandleDescription = ArrayUtility.SubArray(procFormatString, offset, length);
                offset += length;
            }
            procHeaderDesc.ClientBufferSize = BitConverter.ToUInt16(procFormatString, offset);
            offset += Marshal.SizeOf(procHeaderDesc.ClientBufferSize);
            procHeaderDesc.ServerBufferSize = BitConverter.ToUInt16(procFormatString, offset);
            offset += Marshal.SizeOf(procHeaderDesc.ServerBufferSize);
            procHeaderDesc.InterpreterOptFlags = procFormatString[offset];
            offset += Marshal.SizeOf(procHeaderDesc.InterpreterOptFlags);
            procHeaderDesc.NumberOfParams = procFormatString[offset];
            offset += Marshal.SizeOf(procHeaderDesc.NumberOfParams);
            byte extensionSize = procFormatString[offset];
            if (extensionSize >= EXTENSION_SIZE)
            {
                procHeaderDesc.ExtensionSize = extensionSize;
                offset += Marshal.SizeOf(procHeaderDesc.ExtensionSize.Value);
                procHeaderDesc.ExtensionFlags2 = (RpceInterpreterOptFlags2)procFormatString[offset];
                offset += Marshal.SizeOf((byte)procHeaderDesc.ExtensionFlags2);
                procHeaderDesc.ExtensionClientCorrHint = BitConverter.ToUInt16(procFormatString, offset);
                offset += Marshal.SizeOf(procHeaderDesc.ExtensionClientCorrHint.Value);
                procHeaderDesc.ExtensionServerCorrHint = BitConverter.ToUInt16(procFormatString, offset);
                offset += Marshal.SizeOf(procHeaderDesc.ExtensionServerCorrHint.Value);
                procHeaderDesc.ExtensionNotifyIndex = BitConverter.ToUInt16(procFormatString, offset);
                offset += Marshal.SizeOf(procHeaderDesc.ExtensionNotifyIndex.Value);
                offset += extensionSize - EXTENSION_SIZE;
            }
            else
            {
                offset += extensionSize;
            }

            return procHeaderDesc;
        }

        /// <summary>
        /// Get the type of the current platform, 64-bit or 32-bit
        /// </summary>
        /// <returns>Return the platform type</returns>
        public static RpceStubTargetPlatform GetPlatform()
        {
            if (IntPtr.Size == sizeof(Int64))
                return RpceStubTargetPlatform.Amd64;
            else if (IntPtr.Size == sizeof(Int32))
                return RpceStubTargetPlatform.X86;
            else
            {
                throw new NotSupportedException("Platform is neither 32 bits nor 64 bits.");
            }
        }
    }
}
