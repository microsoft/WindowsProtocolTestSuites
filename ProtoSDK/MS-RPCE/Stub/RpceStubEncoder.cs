// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;

namespace Microsoft.Protocols.TestTools.StackSdk.Networking.Rpce
{
    /// <summary>
    /// RpceStubEncoder provides NDR encode support for RPC stub.
    /// </summary>
    public class RpceStubEncoder : RpceStub
    {
        // We use datetime to avoid duplicate endpoint
        private static readonly string localRpcEndpoint = "MSFT.PET.StackSdk:" + Environment.TickCount.ToString("X8");


        // We need to fake a local RPC server because RPC-runtime will send bind PDU 
        // to a server to negotiate transfer syntax (NDR/NDR64/...) when calling NdrGetBuffer().
        // We implictly provide PRC binding handle of local RPC server to NdrGetBuffer, negotiate with ourselves.
        // The server is automatically started when created the instance of RpcBindOnlyServer.
        // Suppress fxcop CA1823.
        internal static readonly RpceBindOnlyServer RPCE_BIND_ONLY_SERVER = new RpceBindOnlyServer(localRpcEndpoint);


        // local PRC handle.
        private IntPtr localRpcHandle;

        // RPC_MESSAGE and MIDL_STUB_DESC
        private IntPtr pRpcMsg;
        private IntPtr pStubDesc;


        /// <summary>
        /// Initialize a RpceStubEncoder.
        /// </summary>
        /// <param name="runtimeTargetPlatform">Runtime platform, x86 or amd64.</param>
        /// <param name="typeFormatString">Type format string generated by MIDL.</param>
        /// <param name="exprEvalRoutines">ExprEvalRoutines generated by MIDL if exists.</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown when typeFormatString is null.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown when runtimeTargetPlatform doesn't match current platform at runtime.
        /// </exception>
        public RpceStubEncoder(
            RpceStubTargetPlatform runtimeTargetPlatform,
            byte[] typeFormatString,
            RpceStubExprEval[] exprEvalRoutines)
            : base(runtimeTargetPlatform, typeFormatString, exprEvalRoutines)
        {
            int status;
            IntPtr bindingString;

            status = NativeMethods.RpcStringBindingCompose(
                null,
                "ncalrpc",
                null,
                localRpcEndpoint,
                null,
                out bindingString);
            if (status != NativeMethods.RPC_S_OK)
            {
                throw new InvalidOperationException(
                    string.Format("RpcStringBindingCompose failed with error code {0}.", status));
            }

            status = NativeMethods.RpcBindingFromStringBinding(bindingString, out localRpcHandle);
            if (status != NativeMethods.RPC_S_OK)
            {
                throw new InvalidOperationException(
                    string.Format("RpcBindingFromStringBinding failed with error code {0}.", status));
            }

            status = NativeMethods.RpcStringFree(ref bindingString);
            if (status != NativeMethods.RPC_S_OK)
            {
                throw new InvalidOperationException(
                    string.Format("RpcStringFree failed with error code {0}.", status));
            }
        }


        /// <summary>
        /// Dispose method.
        /// </summary>
        /// <param name="disposing">
        /// True to release both managed and unmanaged resources.<para/>
        /// False to release unmanaged resources only.
        /// </param>
        //This is Dispose method, just ignore method return results.
        [SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults")]
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Release managed resources.
            }

            // Release unmanaged resources.
            if (pStubMsg != IntPtr.Zero)
            {
                NdrFreeBuffer();
            }
            if (pRpcMsg != IntPtr.Zero)
            {
                //Must call NdrFreeBuffer first.
                Marshal.FreeHGlobal(pRpcMsg);
                pRpcMsg = IntPtr.Zero;
            }
            if (pStubDesc != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(pStubDesc);
                pStubDesc = IntPtr.Zero;
            }
            if (pStubMsg != IntPtr.Zero)
            {
                Marshal.DestroyStructure(pStubMsg, typeof(NativeMethods.MIDL_STUB_MESSAGE));
                Marshal.FreeHGlobal(pStubMsg);
                pStubMsg = IntPtr.Zero;
            }

            if (localRpcHandle != IntPtr.Zero)
            {
                NativeMethods.RpcBindingFree(ref localRpcHandle);
                localRpcHandle = IntPtr.Zero;
            }

            base.Dispose(disposing);
        }


        /// <summary>
        /// Encode parameter list to byte array in one method call.
        /// </summary>
        /// <param name="runtimeTargetPlatform">Runtime platform, x86 or amd64.</param>
        /// <param name="typeFormatString">Type format string generated by MIDL.</param>
        /// <param name="exprEvalRoutines">ExprEvalRoutines generated by MIDL if exists.</param>
        /// <param name="procFormatString">Proc format string generated by MIDL.</param>
        /// <param name="procFormatStringOffset">Offset of the procedure in procFormatString.</param>
        /// <param name="isClient">Is client side.</param>
        /// <param name="parameters">Parameters.</param>
        /// <returns>The byte array contains encoded parameters.</returns>
        /// <exception cref="ArgumentNullException">
        /// Thrown when typeFormatString is null.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown when runtimeTargetPlatform doesn't match current platform at runtime.
        /// </exception>
        public static byte[] ToBytes(
            RpceStubTargetPlatform runtimeTargetPlatform,
            byte[] typeFormatString,
            RpceStubExprEval[] exprEvalRoutines,
            byte[] procFormatString,
            int procFormatStringOffset,
            bool isClient,
            params Int3264[] parameters)
        {
            using (RpceStubEncoder encoder = new RpceStubEncoder(
                runtimeTargetPlatform,
                typeFormatString,
                exprEvalRoutines))
            {
                encoder.NdrClientInitializeNew();

                encoder.NdrParametersBufferSize(procFormatString, procFormatStringOffset, isClient, parameters);

                encoder.NdrGetBuffer();

                encoder.NdrParametersMarshall(procFormatString, procFormatStringOffset, isClient, parameters);

                return encoder.ToBytes();
            }
        }


        /// <summary>
        /// Get parameters buffer size.
        /// </summary>
        /// <param name="procFormatString">Proc format string generated by MIDL.</param>
        /// <param name="offset">Offset of the procedure in procFormatString.</param>
        /// <param name="isClient">Is client side.</param>
        /// <param name="parameters">Parameters.</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        private void NdrParametersBufferSize(
            byte[] procFormatString,
            int offset,
            bool isClient,
            params Int3264[] parameters)
        {
            if (procFormatString == null)
            {
                throw new ArgumentNullException("procFormatString");
            }

            RpceProcedureHeaderDescriptor procHeaderInfo
                = RpceStubHelper.ParseProcedureHeaderDescriptor(procFormatString, ref offset);

            if (procHeaderInfo.NumberOfParams != parameters.Length)
            {
                throw new InvalidOperationException("Number of parameters doesn't match expectation.");
            }

            SaveParametersIntoStack(procFormatString, offset, procHeaderInfo.StackSize, parameters);

            if ((procHeaderInfo.ExtensionFlags2 & RpceInterpreterOptFlags2.HasConformanceRange) != 0)
            {
                SetCorrDespIncrement(RANGED_NDR_CORR_EXTENSION_SIZE);
            }
            else
            {
                SetCorrDespIncrement(NDR_CORR_EXTENSION_SIZE);
            }

            if (isClient)
            {
                SetBufferLength(procHeaderInfo.ClientBufferSize);
            }
            else
            {
                SetBufferLength(procHeaderInfo.ServerBufferSize);
            }

            for (int i = 0; i < parameters.Length; i++)
            {
                RpceParameterAttributes parameterFlags = (RpceParameterAttributes)BitConverter.ToUInt16(procFormatString, offset);
                offset += sizeof(RpceParameterAttributes);
                offset += sizeof(ushort); //skip stack size/top
                ushort parameterTypeFormatStringOffset = BitConverter.ToUInt16(procFormatString, offset);
                offset += sizeof(ushort); //move to next parameter.

                bool sameDirection = (isClient
                    ? (parameterFlags & RpceParameterAttributes.IsIn)
                    : (parameterFlags & RpceParameterAttributes.IsOut)) != 0;
                if (!sameDirection)
                {
                    continue;
                }
                if ((parameterFlags & RpceParameterAttributes.MustSize) == 0)
                {
                    continue;
                }
                if (isClient && (parameterFlags & RpceParameterAttributes.IsPartialIgnore) != 0)
                {
                    const int PTR_WIRE_SIZE = 4;
                    uint bufferLength = GetBufferLength();
                    bufferLength = (uint)RpceUtility.Align((int)bufferLength, PTR_WIRE_SIZE);
                    bufferLength += PTR_WIRE_SIZE;
                    SetBufferLength(bufferLength);
                    continue;
                }

                Int3264 arg = parameters[i];

                RpceFormatCharType formatChar;
                if ((parameterFlags & RpceParameterAttributes.IsBaseType) != 0)
                {
                    formatChar = (RpceFormatCharType)parameterTypeFormatStringOffset;
                }
                else
                {
                    formatChar = (RpceFormatCharType)Marshal.ReadByte(
                        stubDesc.pFormatTypes,
                        parameterTypeFormatStringOffset);
                }

                NdrBufferSizeRoutines(arg, parameterTypeFormatStringOffset, formatChar);
            }
        }


        /// <summary>
        /// Get buffer size of a parameter.
        /// </summary>
        /// <param name="arg">A parameter.</param>
        /// <param name="typeFormatStringOffset">Offset of a parameter in typeFormatString.</param>
        /// <param name="formatChar">Format char.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void NdrBufferSizeRoutines(
            Int3264 arg,
            int typeFormatStringOffset,
            RpceFormatCharType formatChar)
        {
            switch ((RpceFormatCharType)((int)formatChar & FORMAT_CHAR_ROUTINE_BITMASK))
            {
                case RpceFormatCharType.FC_ZERO:
                case RpceFormatCharType.FC_BYTE:
                case RpceFormatCharType.FC_CHAR:
                case RpceFormatCharType.FC_SMALL:
                case RpceFormatCharType.FC_USMALL:
                case RpceFormatCharType.FC_WCHAR:
                case RpceFormatCharType.FC_SHORT:
                case RpceFormatCharType.FC_USHORT:
                case RpceFormatCharType.FC_LONG:
                case RpceFormatCharType.FC_ULONG:
                case RpceFormatCharType.FC_FLOAT:
                case RpceFormatCharType.FC_HYPER:
                case RpceFormatCharType.FC_DOUBLE:
                case RpceFormatCharType.FC_ENUM16:
                case RpceFormatCharType.FC_ENUM32:
                case (RpceFormatCharType)0x0f:
                case RpceFormatCharType.FC_ERROR_STATUS_T:
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_INT3264 & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_UINT3264 & FORMAT_CHAR_ROUTINE_BITMASK):
                    NdrSimpleTypeBufferSize(formatChar);
                    break;

                case RpceFormatCharType.FC_RP:
                case RpceFormatCharType.FC_UP:
                case RpceFormatCharType.FC_OP:
                case RpceFormatCharType.FC_FP:
                    NdrPointerBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_STRUCT:
                case RpceFormatCharType.FC_PSTRUCT:
                    NdrSimpleStructBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CSTRUCT:
                case RpceFormatCharType.FC_CPSTRUCT:
                    NdrConformantStructBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CVSTRUCT:
                    NdrConformantVaryingStructBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BOGUS_STRUCT:
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_FORCED_BOGUS_STRUCT & FORMAT_CHAR_ROUTINE_BITMASK):
                    NdrComplexStructBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CARRAY:
                    NdrConformantArrayBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CVARRAY:
                    NdrConformantVaryingArrayBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_SMFARRAY:
                case RpceFormatCharType.FC_LGFARRAY:
                    NdrFixedArrayBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_SMVARRAY:
                case RpceFormatCharType.FC_LGVARRAY:
                    NdrVaryingArrayBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BOGUS_ARRAY:
                    NdrComplexArrayBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_C_CSTRING:
                case RpceFormatCharType.FC_C_BSTRING:
                case RpceFormatCharType.FC_C_SSTRING:
                case RpceFormatCharType.FC_C_WSTRING:
                    NdrConformantStringBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CSTRING:
                case RpceFormatCharType.FC_BSTRING:
                case RpceFormatCharType.FC_SSTRING:
                case RpceFormatCharType.FC_WSTRING:
                    NdrNonConformantStringBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_ENCAPSULATED_UNION:
                    NdrEncapsulatedUnionBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_NON_ENCAPSULATED_UNION:
                    NdrNonEncapsulatedUnionBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BYTE_COUNT_POINTER:
                    NdrByteCountPointerBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_IP:
                    NdrPointerBufferSize(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BIND_CONTEXT:
                    NdrContextHandleSize(arg, typeFormatStringOffset);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_SUPPLEMENT & FORMAT_CHAR_ROUTINE_BITMASK):
                    NdrSupplementBufferSize(arg, typeFormatStringOffset);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_RANGE & FORMAT_CHAR_ROUTINE_BITMASK):
                    NdrRangeBufferSize(typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_TRANSMIT_AS:
                case RpceFormatCharType.FC_REPRESENT_AS:
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_TRANSMIT_AS_PTR & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_REPRESENT_AS_PTR & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_USER_MARSHAL & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_PIPE & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_CSARRAY & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_CS_TAG & FORMAT_CHAR_ROUTINE_BITMASK):
                    throw new NotSupportedException(
                        "transmit_as, represent_as, user_marshal, pipe and csarray are not supported.");

                default:
                    throw new InvalidOperationException(
                        string.Format("Unsupported type format char {0}.", formatChar));
            }
        }


        /// <summary>
        /// Marshal parameters
        /// </summary>
        /// <param name="procFormatString">Proc format string generated by MIDL.</param>
        /// <param name="offset">Offset of the procedure in procFormatString.</param>
        /// <param name="isClient">Is client side.</param>
        /// <param name="parameters">Parameters.</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        private void NdrParametersMarshall(
            byte[] procFormatString,
            int offset,
            bool isClient,
            params Int3264[] parameters)
        {
            if (procFormatString == null)
            {
                throw new ArgumentNullException("procFormatString");
            }

            RpceProcedureHeaderDescriptor procHeaderInfo
                = RpceStubHelper.ParseProcedureHeaderDescriptor(procFormatString, ref offset);

            if (procHeaderInfo.NumberOfParams != parameters.Length)
            {
                throw new InvalidOperationException("Number of parameters doesn't match expectation.");
            }

            SaveParametersIntoStack(procFormatString, offset, procHeaderInfo.StackSize, parameters);

            if ((procHeaderInfo.ExtensionFlags2 & RpceInterpreterOptFlags2.HasConformanceRange) != 0)
            {
                SetCorrDespIncrement(RANGED_NDR_CORR_EXTENSION_SIZE);
            }
            else
            {
                SetCorrDespIncrement(NDR_CORR_EXTENSION_SIZE);
            }

            for (int i = 0; i < parameters.Length; i++)
            {
                RpceParameterAttributes parameterFlags = (RpceParameterAttributes)BitConverter.ToUInt16(procFormatString, offset);
                offset += sizeof(RpceParameterAttributes);
                offset += sizeof(ushort); //skip stack size/top
                ushort parameterTypeFormatStringOffset = BitConverter.ToUInt16(procFormatString, offset);
                offset += sizeof(ushort); //move to next parameter.

                bool sameDirection = (isClient
                    ? (parameterFlags & RpceParameterAttributes.IsIn)
                    : (parameterFlags & RpceParameterAttributes.IsOut)) != 0;
                if (!sameDirection)
                {
                    continue;
                }
                if ((parameterFlags & RpceParameterAttributes.IsPipe) != 0)
                {
                    continue;
                }
                if (isClient && (parameterFlags & RpceParameterAttributes.IsPartialIgnore) != 0)
                {
                    NdrInt32Marshal(Marshal.ReadIntPtr(parameters[i]) != IntPtr.Zero ? 1 : 0);
                    continue;
                }

                Int3264 arg = parameters[i];

                RpceFormatCharType formatChar;
                if ((parameterFlags & RpceParameterAttributes.IsBaseType) != 0)
                {
                    formatChar = (RpceFormatCharType)parameterTypeFormatStringOffset;
                    if ((parameterFlags & RpceParameterAttributes.IsSimpleRef) != 0)
                    {
                        //for simple type ref, the actual data is always 32bit maximum
                        arg = Marshal.ReadInt32(arg);
                    }
                }
                else
                {
                    formatChar = (RpceFormatCharType)Marshal.ReadByte(
                        stubDesc.pFormatTypes,
                        parameterTypeFormatStringOffset);
                }

                NdrMarshalRoutines(arg, parameterTypeFormatStringOffset, formatChar);
            }
        }


        /// <summary>
        /// Marshal a parameter.
        /// </summary>
        /// <param name="arg">A parameter.</param>
        /// <param name="typeFormatStringOffset">Offset of a parameter in typeFormatString.</param>
        /// <param name="formatChar">Format char.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void NdrMarshalRoutines(
            Int3264 arg,
            int typeFormatStringOffset,
            RpceFormatCharType formatChar)
        {
            switch ((RpceFormatCharType)((int)formatChar & FORMAT_CHAR_ROUTINE_BITMASK))
            {
                case RpceFormatCharType.FC_ZERO:
                    throw new InvalidOperationException("Bad format char: FC_ZERO.");

                case RpceFormatCharType.FC_BYTE:
                case RpceFormatCharType.FC_CHAR:
                case RpceFormatCharType.FC_SMALL:
                case RpceFormatCharType.FC_USMALL:
                    unchecked { NdrByteMarshal((byte)arg.ToInt32()); }
                    break;

                case RpceFormatCharType.FC_WCHAR:
                case RpceFormatCharType.FC_SHORT:
                case RpceFormatCharType.FC_USHORT:
                    unchecked { NdrInt16Marshal((short)arg.ToInt32()); }
                    break;

                case RpceFormatCharType.FC_LONG:
                case RpceFormatCharType.FC_ULONG:
                case RpceFormatCharType.FC_FLOAT:
                    unchecked { NdrInt32Marshal((int)arg.ToInt32()); }
                    break;

                case RpceFormatCharType.FC_HYPER:
                case RpceFormatCharType.FC_DOUBLE:
                    unchecked { NdrInt64Marshal((long)arg.ToInt64()); }
                    break;

                case RpceFormatCharType.FC_ENUM16:
                    unchecked { NdrInt16Marshal((short)arg.ToInt32()); }
                    break;

                case RpceFormatCharType.FC_ENUM32:
                    unchecked { NdrInt32Marshal((int)arg.ToInt32()); }
                    break;

                case RpceFormatCharType.FC_ERROR_STATUS_T:
                    unchecked { NdrInt32Marshal((int)arg.ToInt32()); }
                    break;

                case RpceFormatCharType.FC_RP:
                case RpceFormatCharType.FC_UP:
                case RpceFormatCharType.FC_OP:
                case RpceFormatCharType.FC_FP:
                    NdrPointerMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_STRUCT:
                case RpceFormatCharType.FC_PSTRUCT:
                    NdrSimpleStructMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CSTRUCT:
                case RpceFormatCharType.FC_CPSTRUCT:
                    NdrConformantStructMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CVSTRUCT:
                    NdrConformantVaryingStructMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BOGUS_STRUCT:
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_FORCED_BOGUS_STRUCT & FORMAT_CHAR_ROUTINE_BITMASK):
                    NdrComplexStructMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CARRAY:
                    NdrConformantArrayMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CVARRAY:
                    NdrConformantVaryingArrayMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_SMFARRAY:
                case RpceFormatCharType.FC_LGFARRAY:
                    NdrFixedArrayMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_SMVARRAY:
                case RpceFormatCharType.FC_LGVARRAY:
                    NdrVaryingArrayMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BOGUS_ARRAY:
                    NdrComplexArrayMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_C_CSTRING:
                case RpceFormatCharType.FC_C_BSTRING:
                case RpceFormatCharType.FC_C_SSTRING:
                case RpceFormatCharType.FC_C_WSTRING:
                    NdrConformantStringMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_CSTRING:
                case RpceFormatCharType.FC_BSTRING:
                case RpceFormatCharType.FC_SSTRING:
                case RpceFormatCharType.FC_WSTRING:
                    NdrNonConformantStringMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_ENCAPSULATED_UNION:
                    NdrEncapsulatedUnionMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_NON_ENCAPSULATED_UNION:
                    NdrNonEncapsulatedUnionMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BYTE_COUNT_POINTER:
                    NdrByteCountPointerMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_IP:
                    NdrPointerMarshall(arg, typeFormatStringOffset);
                    break;

                case RpceFormatCharType.FC_BIND_CONTEXT:
                    NdrContextHandleMarshall(arg, typeFormatStringOffset);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_SUPPLEMENT & FORMAT_CHAR_ROUTINE_BITMASK):
                    NdrSupplementMarshall(arg, typeFormatStringOffset);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_RANGE & FORMAT_CHAR_ROUTINE_BITMASK):
                    IntPtr p = Marshal.AllocHGlobal(sizeof(long));
                    Marshal.Copy(BitConverter.GetBytes(arg.ToInt64()), 0, p, sizeof(long));
                    NdrRangeMarshall(p, typeFormatStringOffset);
                    Marshal.FreeHGlobal(p);
                    break;

                case (RpceFormatCharType)((int)RpceFormatCharType.FC_INT3264 & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_UINT3264 & FORMAT_CHAR_ROUTINE_BITMASK):
                    if (IntPtr.Size == sizeof(int))
                    {
                        unchecked { NdrInt32Marshal(arg.ToInt32()); }
                    }
                    else if (IntPtr.Size == sizeof(long))
                    {
                        unchecked { NdrInt64Marshal(arg.ToInt64()); }
                    }
                    else
                    {
                        throw new InvalidOperationException("Unsupported platform.");
                    }
                    break;

                case (RpceFormatCharType)0x0f: // Ignore
                    break;

                case RpceFormatCharType.FC_TRANSMIT_AS:
                case RpceFormatCharType.FC_REPRESENT_AS:
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_TRANSMIT_AS_PTR & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)
                RpceFormatCharType.FC_REPRESENT_AS_PTR & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_USER_MARSHAL & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_PIPE & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_CSARRAY & FORMAT_CHAR_ROUTINE_BITMASK):
                case (RpceFormatCharType)((int)RpceFormatCharType.FC_CS_TAG & FORMAT_CHAR_ROUTINE_BITMASK):
                    throw new NotSupportedException(
                        "transmit_as, represent_as, user_marshal, pipe and csarray are not supported.");

                default:
                    throw new InvalidOperationException(
                        string.Format("Unsupported type format char {0}.", formatChar));
            }
        }


        /// <summary>
        /// Get bytes of encoded parameters.
        /// </summary>
        /// <returns>A byte array.</returns>
        public byte[] ToBytes()
        {
            IntPtr offset;

            offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "RpcMsg");
            pRpcMsg = Marshal.ReadIntPtr(pStubMsg, offset.ToInt32());

            offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "Buffer");
            IntPtr pBufferEnd = Marshal.ReadIntPtr(pStubMsg, offset.ToInt32());

            offset = Marshal.OffsetOf(typeof(NativeMethods.RPC_MESSAGE), "Buffer");
            IntPtr pBuffer = Marshal.ReadIntPtr(pRpcMsg, offset.ToInt32());

            uint bufferLength = (uint)IntPtrUtility.CalculateOffset(pBufferEnd, pBuffer).ToInt32();
            byte[] buf = new byte[bufferLength];
            Marshal.Copy(pBuffer, buf, 0, (int)bufferLength);

            return buf;
        }


        /// <summary>
        /// Initialize client NDR context.
        /// </summary>
        public void NdrClientInitializeNew()
        {
            NativeMethods.RPC_MESSAGE rpcMessage = new NativeMethods.RPC_MESSAGE();
            pRpcMsg = Marshal.AllocHGlobal(Marshal.SizeOf(rpcMessage));
            Marshal.StructureToPtr(rpcMessage, pRpcMsg, false);

            NativeMethods.MIDL_STUB_MESSAGE stubMsg = new NativeMethods.MIDL_STUB_MESSAGE();
            pStubMsg = Marshal.AllocHGlobal(Marshal.SizeOf(stubMsg));
            Marshal.StructureToPtr(stubMsg, pStubMsg, false);

            pStubDesc = Marshal.AllocHGlobal(Marshal.SizeOf(stubDesc));
            Marshal.StructureToPtr(stubDesc, pStubDesc, false);

            NativeMethods.NdrClientInitializeNew(pRpcMsg, pStubMsg, pStubDesc, 0);
        }


        /// <summary>
        /// Allocate buffer for NDR marshalling.
        /// </summary>
        public void NdrGetBuffer()
        {
            uint bufferLength = GetBufferLength();
            NativeMethods.NdrGetBuffer(pStubMsg, bufferLength, localRpcHandle);
        }


        /// <summary>
        /// NDR marshal simple types.
        /// </summary>
        /// <param name="type">The type to marshal.</param>
        /// <returns>A pointer to buffer.</returns>
        private IntPtr NdrMarshal(Type type)
        {
            int size = Marshal.SizeOf(type);
            int offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "Buffer").ToInt32();
            IntPtr ptr = Marshal.ReadIntPtr(pStubMsg, offset);
            ptr = IntPtrUtility.Align(ptr, size);
            Marshal.WriteIntPtr(
                pStubMsg,
                offset,
                IntPtrUtility.Add(ptr, size));
            return ptr;
        }


        /// <summary>
        /// Marshalls a byte.
        /// </summary>
        /// <param name="value">A byte value.</param>
        public void NdrByteMarshal(byte value)
        {
            Marshal.WriteByte(NdrMarshal(typeof(byte)), value);
        }


        /// <summary>
        /// Marshalls a 16-bits signed integer.
        /// </summary>
        /// <param name="value">A short value.</param>
        public void NdrInt16Marshal(short value)
        {
            Marshal.WriteInt16(NdrMarshal(typeof(short)), value);
        }


        /// <summary>
        /// Marshalls a 32-bits signed integer.
        /// </summary>
        /// <param name="value">An int value.</param>
        public void NdrInt32Marshal(int value)
        {
            Marshal.WriteInt32(NdrMarshal(typeof(int)), value);
        }


        /// <summary>
        /// Marshalls a 64-bits signed integer.
        /// </summary>
        /// <param name="value">A long value.</param>
        public void NdrInt64Marshal(long value)
        {
            Marshal.WriteInt64(NdrMarshal(typeof(long)), value);
        }


        /// <summary>
        /// Computes the buffer size needed for a pointer.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrPointerBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrPointerBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a pointer.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrPointerMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrPointerMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a simple structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrSimpleStructBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrSimpleStructBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a simple structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrSimpleStructMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrSimpleStructMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a complex structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrComplexStructBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrComplexStructBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a complex structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrComplexStructMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrComplexStructMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a simple type.
        /// </summary>
        /// <param name="formatChar">A format char of the simple type.</param>
        public void NdrSimpleTypeBufferSize(RpceFormatCharType formatChar)
        {
            byte size = NativeMethods.NdrGetSimpleTypeBufferSize((byte)formatChar);
            uint bufferLength = GetBufferLength();
            bufferLength = (uint)RpceUtility.Align((int)bufferLength, size);
            bufferLength += size;
            SetBufferLength(bufferLength);
        }


        /// <summary>
        /// Marshalls a simple type.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatChar">A format char of the simple type.</param>
        public void NdrSimpleTypeMarshall(IntPtr pMemory, RpceFormatCharType formatChar)
        {
            NativeMethods.NdrSimpleTypeMarshall(pStubMsg, pMemory, (byte)formatChar);
        }


        /// <summary>
        /// Computes the buffer size needed for a non encapsulated union.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrNonEncapsulatedUnionBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrNonEncapsulatedUnionBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a non encapsulated union.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrNonEncapsulatedUnionMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrNonEncapsulatedUnionMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a conformant string.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantStringBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantStringBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a conformant string.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantStringMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantStringMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a conformant array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantArrayBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantArrayBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a conformant array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantArrayMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantArrayMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a fixed array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrFixedArrayBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrFixedArrayBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a fixed array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrFixedArrayMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrFixedArrayMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a range.
        /// </summary>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        public void NdrRangeBufferSize(int formatStringOffset)
        {
            // offset + 1 is the place of real format string of this parameter.
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset + 1);
            RpceFormatCharType formatChar = (RpceFormatCharType)(
                Marshal.ReadByte(pFormat) & FORMAT_CHAR_SIMPLE_TYPE_BITMASK);

            NdrSimpleTypeBufferSize(formatChar);
        }


        /// <summary>
        /// Marshalls a range.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        public void NdrRangeMarshall(IntPtr pMemory, int formatStringOffset)
        {
            // offset + 1 is the place of real format string of this parameter.
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset + 1);
            RpceFormatCharType formatChar = (RpceFormatCharType)(
                Marshal.ReadByte(pFormat) & FORMAT_CHAR_SIMPLE_TYPE_BITMASK);

            NdrSimpleTypeMarshall(pMemory, formatChar);
        }


        /// <summary>
        /// Computes the buffer size needed for a supplement.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        public void NdrSupplementBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            // offset + 2 is the size of supplement header size (ushort), skip the size.
            formatStringOffset += 2;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            int supplementOffset = Marshal.ReadInt16(pFormat);
            formatStringOffset += supplementOffset;
            pFormat = IntPtrUtility.Add(pFormat, supplementOffset);
            RpceFormatCharType formatChar = (RpceFormatCharType)Marshal.ReadByte(pFormat);

            NdrBufferSizeRoutines(pMemory, formatStringOffset, formatChar);
        }


        /// <summary>
        /// Marshalls a supplement.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        public void NdrSupplementMarshall(IntPtr pMemory, int formatStringOffset)
        {
            // offset + 2 is the size of supplement header size (ushort), skip the size.
            formatStringOffset += 2;
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            int supplementOffset = Marshal.ReadInt16(pFormat);
            formatStringOffset += supplementOffset;
            pFormat = IntPtrUtility.Add(pFormat, supplementOffset);
            RpceFormatCharType formatChar = (RpceFormatCharType)Marshal.ReadByte(pFormat);

            NdrMarshalRoutines(pMemory, formatStringOffset, formatChar);
        }


        /*/// <summary>
        /// Computes the buffer size needed for a user marshal object.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrUserMarshalBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrUserMarshalBufferSize(pStubMsg, pMemory, pFormat);
        }*/


        /*/// <summary>
        /// Marshalls a user marshal object.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrUserMarshalMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrUserMarshalMarshall(pStubMsg, pMemory, pFormat);
        }*/


        /// <summary>
        /// Computes the buffer size needed for a context handle.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrContextHandleSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrContextHandleSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a context handle.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow")]
        public void NdrContextHandleMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr contextHandle = pMemory;

            // offset + 1 contains the flag of isHandlePtr.
            // offset + 3 contains the flag of isHandleComplex.
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset + 1);
            bool isHandlePtr = (Marshal.ReadByte(pFormat) & 0x80) != 0;
            pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset + 3);
            bool isHandleComplex = (Marshal.ReadByte(pFormat) & 0x80) != 0;

            if ((isHandleComplex || isHandlePtr) && contextHandle != IntPtr.Zero)
            {
                contextHandle = Marshal.ReadIntPtr(contextHandle);
            }

            int offset = Marshal.OffsetOf(typeof(NativeMethods.MIDL_STUB_MESSAGE), "Buffer").ToInt32();
            IntPtr ptr = Marshal.ReadIntPtr(pStubMsg, offset);
            ptr = IntPtrUtility.Align(ptr, CONTEXT_HANDLE_ALIGNMENT);
            Marshal.WriteIntPtr(
                pStubMsg,
                offset,
                IntPtrUtility.Add(ptr, CONTEXT_HANDLE_WIRE_SIZE));

            if (contextHandle == IntPtr.Zero)
            {
                // Set all zero.
                Marshal.Copy(new byte[CONTEXT_HANDLE_WIRE_SIZE], 0, ptr, CONTEXT_HANDLE_WIRE_SIZE);
            }
            else
            {
                NativeMethods.RtlMoveMemory(ptr, contextHandle, CONTEXT_HANDLE_WIRE_SIZE);
            }
        }


        /*/// <summary>
        /// Computes the buffer size needed for a transmit as or represent as argument.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrXmitOrRepAsBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrXmitOrRepAsBufferSize(pStubMsg, pMemory, pFormat);
        }*/


        /*/// <summary>
        /// Marshalls a transmit as or represent as argument.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrXmitOrRepAsMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrXmitOrRepAsMarshall(pStubMsg, pMemory, pFormat);
        }*/


        /// <summary>
        /// Computes the buffer size needed for a byte count pointer.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrByteCountPointerBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrByteCountPointerBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a byte count pointer.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrByteCountPointerMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrByteCountPointerMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for an encapsulated union.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrEncapsulatedUnionBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrEncapsulatedUnionBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls an encapsulated union.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrEncapsulatedUnionMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrEncapsulatedUnionMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a non conformant string.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrNonConformantStringBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrNonConformantStringBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a non conformant string.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrNonConformantStringMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrNonConformantStringMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a complex array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrComplexArrayBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrComplexArrayBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a complex array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrComplexArrayMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrComplexArrayMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a varying array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrVaryingArrayBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrVaryingArrayBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a varying array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrVaryingArrayMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrVaryingArrayMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a conformant varying array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantVaryingArrayBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantVaryingArrayBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a conformant varying array.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantVaryingArrayMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantVaryingArrayMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a conformant varying structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantVaryingStructBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantVaryingStructBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a conformant varying structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantVaryingStructMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantVaryingStructMarshall(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Computes the buffer size needed for a conformant structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantStructBufferSize(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantStructBufferSize(pStubMsg, pMemory, pFormat);
        }


        /// <summary>
        /// Marshalls a conformant structure.
        /// </summary>
        /// <param name="pMemory">Pointer to the parameter.</param>
        /// <param name="formatStringOffset">Offset of the type format string.</param>
        public void NdrConformantStructMarshall(IntPtr pMemory, int formatStringOffset)
        {
            IntPtr pFormat = IntPtrUtility.Add(stubDesc.pFormatTypes, formatStringOffset);
            NativeMethods.NdrConformantStructMarshall(pStubMsg, pMemory, pFormat);
        }
    }
}
