// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
using System;
using System.Security.Cryptography;
using System.Text;

using Microsoft.Protocols.TestTools.StackSdk.Security.Cryptographic;

namespace Microsoft.Protocols.TestTools.StackSdk.RemoteDesktop.Rdpbcgr
{
    /// <summary>
    /// Support Standard RDP Security
    /// </summary>   
    public class EncryptionAlgorithm : IDisposable
    {
        #region members
        private bool disposed;
        private EncryptionMethods encryptionMethod;
        private byte[] macKey;
        private byte[] initialClientDecryptKey;
        private byte[] initialClientEncryptKey;
        private byte[] currentClientDecryptKey;
        private byte[] currentClientEncryptKey;
        private byte[] initialServerEncryptKey;
        private byte[] initialServerDecryptKey;
        private byte[] currentServerEncryptKey;
        private byte[] currentServerDecryptKey;

        /// <summary>
        /// The cumulative encryption count indicating how many encryptions have been carried out.
        /// </summary>
        private Int32 encryptionCount;

        /// <summary>
        /// The cumulative decryption count indicating how many decryptions have been carried out.
        /// </summary>
        private Int32 decryptionCount;
        private ICryptoTransform rc4Encrypt;
        private ICryptoTransform rc4Decrypt;
        private ICryptoTransform rc4EncryptServer;
        private ICryptoTransform rc4DecryptServer;
        private TripleDESCryptoServiceProvider desEncrypt;
        private TripleDESCryptoServiceProvider desDecrypt;
        private TripleDESCryptoServiceProvider desEncryptServer;
        private TripleDESCryptoServiceProvider desDecryptServer;

        #endregion members

        #region properties
        internal byte[] CurrentClientDecryptKey
        {
            get
            {
                return currentClientDecryptKey;
            }
        }

        internal byte[] CurrentClientEncryptKey
        {
            get
            {
                return currentClientEncryptKey;
            }
        }

        internal byte[] CurrentServerDecryptKey
        {
            get
            {
                return currentServerDecryptKey;
            }
        }

        internal byte[] CurrentServerEncryptKey
        {
            get
            {
                return currentServerEncryptKey;
            }
        }
        #endregion properties


        #region constructor
        /// <summary>
        /// Create an EncryptionAlgorithm for specified encryption level and encryption method.
        /// </summary>
        /// <param name="method">Specify the encryption method.</param>
        public EncryptionAlgorithm(EncryptionMethods method)
        {
            encryptionMethod = method;
        }
        #endregion constructor


        #region encryption methods
        /// <summary>
        /// Generate the session key according to section 5.3.5 Initial Session Key Generation.
        /// </summary>
        /// <param name="clientRandom">The client random generated by client. This argument can not be null.</param>
        /// <param name="serverRandom">The server random received from server. This argument can not be null.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security.Cryptography", "CA5353:TripleDESCannotBeUsed")]
        internal void GenerateSessionKey(byte[] clientRandom, byte[] serverRandom)
        {
            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                byte[] mackey = null;
                byte[] clientEncKey = null;
                byte[] clientDecKey = null;

                GenerateNonFIPSSessionKey(clientRandom, serverRandom, out mackey, out clientEncKey, out clientDecKey);
                if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT)
                {
                    // MACKey40 = 0xD1269E + Last40Bits(First64Bits(MACKey128))
                    byte[] salt = ConstValue.NON_FIPS_SALT_40BIT;
                    byte[] first = GetFirstNBits(64, mackey);
                    byte[] last = GetLastNBits(40, first);
                    macKey = RdpbcgrUtility.ConcatenateArrays(salt, last);

                    // InitialClientEncryptKey40 = 0xD1269E + Last40Bits(First64Bits(InitialClientEncryptKey128))
                    first = GetFirstNBits(64, clientEncKey);
                    last = GetLastNBits(40, first);
                    currentClientEncryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);
                    currentServerDecryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);

                    // InitialClientDecryptKey40 = 0xD1269E + Last40Bits(First64Bits(InitialClientDecryptKey128))
                    first = GetFirstNBits(64, clientDecKey);
                    last = GetLastNBits(40, first);
                    currentClientDecryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);
                    currentServerEncryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);
                }
                else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT)
                {
                    // MACKey56 = 0xD1 + Last56Bits(First64Bits(MACKey128))
                    byte[] salt = ConstValue.NON_FIPS_SALT_56BIT;
                    byte[] first = GetFirstNBits(64, mackey);
                    byte[] last = GetLastNBits(56, first);
                    macKey = RdpbcgrUtility.ConcatenateArrays(salt, last);

                    // InitialClientEncryptKey56 = 0xD1 + Last56Bits(First64Bits(InitialClientEncryptKey128))
                    first = GetFirstNBits(64, clientEncKey);
                    last = GetLastNBits(56, first);
                    currentClientEncryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);
                    currentServerDecryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);

                    // InitialClientDecryptKey56 = 0xD1 + Last56Bits(First64Bits(InitialClientDecryptKey128))
                    first = GetFirstNBits(64, clientDecKey);
                    last = GetLastNBits(56, first);
                    currentClientDecryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);
                    currentServerEncryptKey = RdpbcgrUtility.ConcatenateArrays(salt, last);
                }
                else // encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT
                {
                    macKey = mackey;
                    currentClientEncryptKey = clientEncKey;
                    currentServerDecryptKey = clientEncKey;
                    currentClientDecryptKey = clientDecKey;
                    currentServerEncryptKey = clientDecKey;
                }

                initialClientDecryptKey = currentClientDecryptKey;
                initialClientEncryptKey = currentClientEncryptKey;
                initialServerEncryptKey = currentServerEncryptKey;
                initialServerDecryptKey = currentServerDecryptKey;
                RC4CryptoServiceProvider rc4Enc = new RC4CryptoServiceProvider();
                rc4Encrypt = rc4Enc.CreateEncryptor(currentClientEncryptKey, null);
                rc4EncryptServer = rc4Enc.CreateEncryptor(currentServerEncryptKey, null);
                RC4CryptoServiceProvider rc4Dec = new RC4CryptoServiceProvider();
                rc4Decrypt = rc4Dec.CreateDecryptor(currentClientDecryptKey, null);
                rc4DecryptServer = rc4Dec.CreateDecryptor(currentServerDecryptKey, null);
            }
            else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_FIPS)
            {
                GenerateFIPSSessionKey(clientRandom, serverRandom, out macKey,
                                       out currentClientEncryptKey, out currentClientDecryptKey,
                                       out currentServerEncryptKey, out currentServerDecryptKey);
                initialClientDecryptKey = currentClientDecryptKey;
                initialClientEncryptKey = currentClientEncryptKey;
                initialServerDecryptKey = currentServerDecryptKey;
                initialServerEncryptKey = currentServerEncryptKey;

                // suppress "CA5353:TripleDESCannotBeUsed" message, since TripleDES is used according protocol definition in MS-RDPBCGR
                desEncrypt = new TripleDESCryptoServiceProvider();
                desEncrypt.IV = ConstValue.TRPLE_DES_IV;
                desEncrypt.Key = currentClientEncryptKey;
                desEncrypt.Mode = CipherMode.CBC;

                desDecrypt = new TripleDESCryptoServiceProvider();
                desDecrypt.IV = ConstValue.TRPLE_DES_IV;
                desDecrypt.Key = currentClientDecryptKey;
                desDecrypt.Mode = CipherMode.CBC;

                desEncryptServer = new TripleDESCryptoServiceProvider();
                desEncryptServer.IV = ConstValue.TRPLE_DES_IV;
                desEncryptServer.Key = currentServerEncryptKey;
                desEncryptServer.Mode = CipherMode.CBC;

                desDecryptServer = new TripleDESCryptoServiceProvider();
                desDecryptServer.IV = ConstValue.TRPLE_DES_IV;
                desDecryptServer.Key = currentServerDecryptKey;
                desDecryptServer.Mode = CipherMode.CBC;
            }
            else  // the encryption method is ENCRYPTION_METHOD_NONE or error
            {
                macKey = null;
                initialClientEncryptKey = null;
                initialClientDecryptKey = null;
                currentClientEncryptKey = null;
                currentClientDecryptKey = null;
                initialServerEncryptKey = null;
                initialServerDecryptKey = null;
                currentServerEncryptKey = null;
                currentServerDecryptKey = null;
                rc4Encrypt = null;
                rc4Decrypt = null;
                rc4EncryptServer = null;
                rc4DecryptServer = null;
                desEncrypt = null;
                desDecrypt = null;
                desEncryptServer = null;
                desDecryptServer = null;
            }

            // the cumulative encryption/decryption count
            // indicating how many encryptions/decryptions have been carried out.
            encryptionCount = 0;  // the first encryption start with 0
            decryptionCount = -1; // after the first decryption, decryptionCount++ up to 0
        }


        /// <summary>
        /// Update session key according to section 5.3.7 Session Key Updates.
        /// </summary>
        internal void UpdateSessionKey()
        {
            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                currentClientEncryptKey = UpdateKey(initialClientEncryptKey,
                                                    currentClientEncryptKey,
                                                    encryptionMethod);

                currentClientDecryptKey = UpdateKey(initialClientDecryptKey,
                                                    currentClientDecryptKey,
                                                    encryptionMethod);

                currentServerEncryptKey = UpdateKey(initialServerEncryptKey,
                                                    currentServerEncryptKey,
                                                    encryptionMethod);

                currentServerDecryptKey = UpdateKey(initialServerDecryptKey,
                                                    currentServerDecryptKey,
                                                    encryptionMethod);

                RC4CryptoServiceProvider rc4Enc = new RC4CryptoServiceProvider();
                rc4Encrypt = rc4Enc.CreateEncryptor(currentClientEncryptKey, null);
                rc4EncryptServer = rc4Enc.CreateEncryptor(currentServerEncryptKey, null);

                RC4CryptoServiceProvider rc4Dec = new RC4CryptoServiceProvider();
                rc4Decrypt = rc4Dec.CreateDecryptor(currentClientDecryptKey, null);
                rc4DecryptServer = rc4Dec.CreateDecryptor(currentServerDecryptKey, null);
            }
            // else in other cases we don't need to update session key
        }


        /// <summary>
        /// Generate data signature according to section 5.3.6.1 Non-FIPS and 5.3.6.2 FIPS.
        /// </summary>
        /// <param name="data">Data to be computed. This argument can be null.</param>
        /// <param name="isSalted">Specify if data signature generated with salted MAC.</param>
        /// <returns>The data signature.</returns>
        internal byte[] GenerateDataSignature(byte[] data, bool isSalted)
        {
            if (data == null)
            {
                return null;
            }

            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                if (isSalted)
                {
                    return GenerateSaltedDataSignature(macKey, data, encryptionCount);
                }
                else
                {
                    return GenerateNonFIPSDataSignature(macKey, data);
                }
            }
            else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_FIPS)
            {
                return GenerateFIPSDataSignature(macKey, data, encryptionCount);
            }
            // else do nothing

            return null;
        }


        /// <summary>
        /// Validate data signature for received PDUs.
        /// </summary>
        /// <param name="dataSignature">The data signature to be validate. This argument can be null.</param>
        /// <param name="data">Data generates the signature. This argument can be null.</param>
        /// <param name="isSalted">Specify if data signature generated with salted MAC.</param>
        /// <returns>If the data signature is valid.</returns>
        internal bool ValidateDataSignature(byte[] dataSignature, byte[] data, bool isSalted)
        {
            byte[] signature = null;

            if (data != null)
            {
                if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                    || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                    || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
                {
                    if (isSalted)
                    {
                        signature = GenerateSaltedDataSignature(macKey, data, decryptionCount);
                    }
                    else
                    {
                        signature = GenerateNonFIPSDataSignature(macKey, data);
                    }
                }
                else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_FIPS)
                {
                    signature = GenerateFIPSDataSignature(macKey, data, decryptionCount);
                }
                // else do nothing
            }

            return RdpbcgrUtility.AreEqual(signature, dataSignature);
        }


        /// <summary>
        /// Encrypt I/O data stream according to section 5.3.6.1 Non-FIPS and 5.3.6.2 FIPS.
        /// </summary>
        /// <param name="data">Data to be encrypted. This argument can be null.</param>
        /// <returns>The encrypted data.</returns>
        public byte[] Encrypt(byte[] data)
        {
            if (data == null)
            {
                return null;
            }

            byte[] result = null;

            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                result = new byte[data.Length];
                encryptionCount++;
                rc4Encrypt.TransformBlock(data, 0, data.Length, result, 0);
            }
            else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_FIPS)
            {
                encryptionCount++;
                result = desEncrypt.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
                // TripleDESCryptoServiceProvider will add paddings to result if it's shorter than 8 bytes in CBC mode.
                // So the length of result must longer than (or equal to) 8 bytes.
                desEncrypt.IV = GetLastNBits(desEncrypt.IV.Length * 8, result);
            }
            else  // do nothing
            {
                result = data;
            }

            return result;
        }


        /// <summary>
        /// Encrypt I/O data stream by the server according to section 5.3.6.1 Non-FIPS and 5.3.6.2 FIPS.
        /// </summary>
        /// <param name="data">Data to be encrypted. This argument can be null.</param>
        /// <returns>The encrypted data.</returns>
        public byte[] ServerEncrypt(byte[] data)
        {
            if (data == null)
            {
                return null;
            }

            byte[] result = null;

            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                result = new byte[data.Length];
                encryptionCount++;
                rc4EncryptServer.TransformBlock(data, 0, data.Length, result, 0);
            }
            else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_FIPS)
            {
                encryptionCount++;
                result = desEncryptServer.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
                // TripleDESCryptoServiceProvider will add paddings to result if it's shorter than 8 bytes in CBC mode.
                // So the length of result must longer than (or equal to) 8 bytes.
                desEncryptServer.IV = GetLastNBits(desEncryptServer.IV.Length * 8, result);
            }
            else  // do nothing
            {
                result = data;
            }

            return result;
        }


        /// <summary>
        /// Decrypt I/O data stream according to section 5.3.6.1 Non-FIPS and 5.3.6.2 FIPS.
        /// </summary>
        /// <param name="data">Data to be decrypted. This argument can be null.</param>
        /// <returns>The decrypted data.</returns>
        public byte[] Decrypt(byte[] data)
        {
            if (data == null)
            {
                return null;
            }

            byte[] result = null;

            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                result = new byte[data.Length];
                decryptionCount++;
                rc4Decrypt.TransformBlock(data, 0, data.Length, result, 0);
            }
            else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_FIPS)
            {
                decryptionCount++;
                result = desDecrypt.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
                // TripleDESCryptoServiceProvider will add paddings to data if it's shorter than 8 bytes in CBC mode.
                // So the length of data must longer than (or equal to) 8 bytes.
                desDecrypt.IV = GetLastNBits(desDecrypt.IV.Length * 8, data);
            }
            else // do nothing
            {
                result = data;
            }

            return result;
        }


        /// <summary>
        /// Decrypt I/O data stream by the server according to section 5.3.6.1 Non-FIPS and 5.3.6.2 FIPS.
        /// </summary>
        /// <param name="data">Data to be decrypted. This argument can be null.</param>
        /// <returns>The decrypted data.</returns>
        public byte[] ServerDecrypt(byte[] data)
        {
            if (data == null)
            {
                return null;
            }

            byte[] result = null;

            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT
                || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                result = new byte[data.Length];
                decryptionCount++;
                rc4DecryptServer.TransformBlock(data, 0, data.Length, result, 0);
            }
            else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_FIPS)
            {
                decryptionCount++;
                result = desDecryptServer.CreateDecryptor().TransformFinalBlock(data, 0, data.Length);
                // TripleDESCryptoServiceProvider will add paddings to data if it's shorter than 8 bytes in CBC mode.
                // So the length of data must longer than (or equal to) 8 bytes.
                desDecryptServer.IV = GetLastNBits(desDecryptServer.IV.Length * 8, data);
            }
            else // do nothing
            {
                result = data;
            }

            return result;
        }

        #endregion encryption methods


        #region private methods
        /// <summary>
        /// Generate the session key for Non-FIPS according to section 5.3.5 Initial Session Key Generation.
        /// </summary>
        /// <param name="clientRandom">The client random generated by client.</param>
        /// <param name="serverRandom">The server random received from server.</param>
        /// <param name="macKey">The computed MACKey.</param>
        /// <param name="clientEncKey">The computed client encrypt key.</param>
        /// <param name="clientDecKey">The computed client decrypt key.</param>
        private static void GenerateNonFIPSSessionKey(byte[] clientRandom,
                                                      byte[] serverRandom,
                                                      out byte[] macKey,
                                                      out byte[] clientEncKey,
                                                      out byte[] clientDecKey)
        {
            // PreMasterSecret = First192Bits(ClientRandom) + First192Bits(ServerRandom)
            byte[] preMasterSecret = RdpbcgrUtility.ConcatenateArrays(GetFirstNBits(192, clientRandom),
                                                               GetFirstNBits(192, serverRandom));

            // SaltedHash(S, I) = MD5(S + SHA(I + S + ClientRandom + ServerRandom))
            // PreMasterHash(I) = SaltedHash(PremasterSecret, I)
            // MasterSecret = PreMasterHash('A') + PreMasterHash('BB') + PreMasterHash('CCC')
            byte[] Salt1 = SaltedHash(preMasterSecret,
                                      Encoding.ASCII.GetBytes(ConstValue.NON_FIPS_MASTER_SECRET_A),
                                      clientRandom,
                                      serverRandom);
            byte[] Salt2 = SaltedHash(preMasterSecret,
                                      Encoding.ASCII.GetBytes(ConstValue.NON_FIPS_MASTER_SECRET_BB),
                                      clientRandom,
                                      serverRandom);
            byte[] Salt3 = SaltedHash(preMasterSecret,
                                      Encoding.ASCII.GetBytes(ConstValue.NON_FIPS_MASTER_SECRET_CCC),
                                      clientRandom,
                                      serverRandom);
            byte[] masterSecret = RdpbcgrUtility.ConcatenateArrays(Salt1, Salt2, Salt3);

            // MasterHash(I) = SaltedHash(MasterSecret, I)
            // SessionKeyBlob = MasterHash('X') + MasterHash('YY') + MasterHash('ZZZ')
            byte[] Salt11 = SaltedHash(masterSecret,
                                       Encoding.ASCII.GetBytes(ConstValue.NON_FIPS_MASTER_SECRET_X),
                                       clientRandom,
                                       serverRandom);
            byte[] Salt21 = SaltedHash(masterSecret,
                                       Encoding.ASCII.GetBytes(ConstValue.NON_FIPS_MASTER_SECRET_YY),
                                       clientRandom,
                                       serverRandom);
            byte[] Salt31 = SaltedHash(masterSecret,
                                       Encoding.ASCII.GetBytes(ConstValue.NON_FIPS_MASTER_SECRET_ZZZ),
                                       clientRandom,
                                       serverRandom);
            byte[] sessionKey = RdpbcgrUtility.ConcatenateArrays(Salt11, Salt21, Salt31);

            // MACKey128 = First128Bits(SessionKeyBlob)
            macKey = GetFirstNBits(128, sessionKey);

            // FinalHash(K) = MD5(K + ClientRandom + ServerRandom)
            // InitialClientDecryptKey128 = FinalHash(Second128Bits(SessionKeyBlob))
            byte[] tempKey = GetLastNBits(128, GetFirstNBits(128 * 2, sessionKey));
            clientDecKey = FinalHash(tempKey, clientRandom, serverRandom);

            // FinalHash(K) = MD5(K + ClientRandom + ServerRandom)
            // InitialClientEncryptKey128 = FinalHash(Third128Bits(SessionKeyBlob))
            tempKey = GetLastNBits(128, GetFirstNBits(128 * 3, sessionKey));
            clientEncKey = FinalHash(tempKey, clientRandom, serverRandom);
        }


        /// <summary>
        /// Generate the session key for FIPS according to section 5.3.5 Initial Session Key Generation.
        /// </summary>
        /// <param name="clientRandom">The client random generated by client.</param>
        /// <param name="serverRandom">The server random received from server.</param>
        /// <param name="macKey">The computed MACKey.</param>
        /// <param name="clientEncKey">The computed client encrypt key.</param>
        /// <param name="clientDecKey">The computed client decrypt key.</param>
        private static void GenerateFIPSSessionKey(byte[] clientRandom,
                                                   byte[] serverRandom,
                                                   out byte[] macKey,
                                                   out byte[] clientEncKey,
                                                   out byte[] clientDecKey,
                                                   out byte[] serverEncKey,
                                                   out byte[] serverDecKey)
        {
            // ClientEncryptKeyT = SHA(Last128Bits(ClientRandom) + Last128Bits(ServerRandom))
            byte[] clientKeyT = RdpbcgrUtility.ConcatenateArrays(GetLastNBits(128, clientRandom), GetLastNBits(128, serverRandom));
            byte[] clientEncryptKeyT = ShaHash(clientKeyT);

            // ClientDecryptKeyT = SHA(First128Bits(ClientRandom) + First128Bits(ServerRandom))
            clientKeyT = RdpbcgrUtility.ConcatenateArrays(GetFirstNBits(128, clientRandom), GetFirstNBits(128, serverRandom));
            byte[] clientDecryptKeyT = ShaHash(clientKeyT);

            // ClientEncryptKey = ClientEncryptKeyT + First8Bits(ClientEncryptKeyT)
            clientEncKey = RdpbcgrUtility.ConcatenateArrays(clientEncryptKeyT, GetFirstNBits(8, clientEncryptKeyT));
            serverDecKey = RdpbcgrUtility.ConcatenateArrays(clientEncryptKeyT, GetFirstNBits(8, clientEncryptKeyT));

            // ClientDecryptKey = ClientDecryptKeyT + First8Bits(ClientDecryptKeyT)
            clientDecKey = RdpbcgrUtility.ConcatenateArrays(clientDecryptKeyT, GetFirstNBits(8, clientDecryptKeyT));
            serverEncKey = RdpbcgrUtility.ConcatenateArrays(clientDecryptKeyT, GetFirstNBits(8, clientDecryptKeyT));

            ReverseEveryByte(clientEncKey);
            InsertZeroBit(ref clientEncKey);
            ReverseEveryByte(clientEncKey);
            FillOddParity(clientEncKey);

            ReverseEveryByte(clientDecKey);
            InsertZeroBit(ref clientDecKey);
            ReverseEveryByte(clientDecKey);
            FillOddParity(clientDecKey);

            ReverseEveryByte(serverEncKey);
            InsertZeroBit(ref serverEncKey);
            ReverseEveryByte(serverEncKey);
            FillOddParity(serverEncKey);

            ReverseEveryByte(serverDecKey);
            InsertZeroBit(ref serverDecKey);
            ReverseEveryByte(serverDecKey);
            FillOddParity(serverDecKey);

            byte[] temp = RdpbcgrUtility.ConcatenateArrays(clientDecryptKeyT, clientEncryptKeyT);
            macKey = ShaHash(temp);
        }


        /// <summary>
        /// Get the first N bits of the specified data. N should be divided by 8.
        /// </summary>
        /// <param name="n">The number of bits to get.</param>
        /// <param name="data">The specified data.</param>
        /// <returns>The first N bits data.</returns>
        private static byte[] GetFirstNBits(int n, byte[] data)
        {
            int nBytes = n / 8;
            if (nBytes > data.Length)
            {
                return null;
            }

            byte[] firstNBytes = new byte[nBytes];
            Buffer.BlockCopy(data, 0, firstNBytes, 0, nBytes);
            return firstNBytes;
        }

        /// <summary>
        /// Get the last N bits of the specified data. N should be divided by 8.
        /// </summary>
        /// <param name="n">The number of bits to get.</param>
        /// <param name="data">The specified data.</param>
        /// <returns>The first N bits data.</returns>
        private static byte[] GetLastNBits(int n, byte[] data)
        {
            int nBytes = n / 8;
            if (nBytes > data.Length)
            {
                return null;
            }

            byte[] lastNBytes = new byte[nBytes];
            Buffer.BlockCopy(data, data.Length - nBytes, lastNBytes, 0, nBytes);
            return lastNBytes;
        }


        /// <summary>
        /// Compute SaltedHash(S, I) = MD5(S + SHA(I + S + ClientRandom + ServerRandom))
        /// </summary>
        /// <param name="parameterS">Argument S in the formula above.</param>
        /// <param name="parameterI">Argument I in the formula above.</param>
        /// <param name="clientRandom">Argument ClientRandom in the formula above.</param>
        /// <param name="serverRandom">Argument ServerRandom in the formula above.</param>
        /// <returns>The computed result.</returns>
        private static byte[] SaltedHash(byte[] parameterS,
                                         byte[] parameterI,
                                         byte[] clientRandom,
                                         byte[] serverRandom)
        {
            // I + S + ClientRandom + ServerRandom
            byte[] shaData = RdpbcgrUtility.ConcatenateArrays(parameterI, parameterS, clientRandom, serverRandom);

            //Computing the ShaHash of (I + S + ClientRandom + ServerRandom)
            byte[] shaHash = ShaHash(shaData);

            // S + SHA(I + S + ClientRandom + ServerRandom)
            byte[] md5Data = RdpbcgrUtility.ConcatenateArrays(parameterS, shaHash);

            // Computing the MD5Hash of (S + SHA(I + S + ClientRandom + ServerRandom))            
            return MD5Hash(md5Data);
        }


        /// <summary>
        /// Compute FinalHash(K) = MD5(K + ClientRandom + ServerRandom)
        /// </summary>
        /// <param name="parameterK">Argument K in the formula above.</param>
        /// <param name="clientRandom">Argument ClientRandom in the formula above.</param>
        /// <param name="serverRandom">Argument ServerRandom in the formula above.</param>
        /// <returns>The computed result.</returns>
        private static byte[] FinalHash(byte[] parameterK, byte[] clientRandom, byte[] serverRandom)
        {
            byte[] temp = RdpbcgrUtility.ConcatenateArrays(parameterK, clientRandom, serverRandom);
            return MD5Hash(temp);
        }


        /// <summary>
        /// Compute MD5.
        /// </summary>
        /// <param name="data">The data to be computed.</param>
        /// <returns>The computed result.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security.Cryptography", "CA5350:MD5CannotBeUsed")]
        private static byte[] MD5Hash(byte[] data)
        {
            // Suppress "CA5350:MD5CannotBeUsed" message since MD5 is used according protocol definition of MS-RDPBCGR 
            MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();
            return md5.ComputeHash(data);
        }


        /// <summary>
        /// Compute SHA.
        /// </summary>
        /// <param name="data">The data to be computed.</param>
        /// <returns>The computed result.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security.Cryptography", "CA5354:SHA1CannotBeUsed")]
        private static byte[] ShaHash(byte[] data)
        {
            // Suppress "CA5354:SHA1CannotBeUsed" message since SHA1 is used according protocol definition of MS-RDPBCGR 
            SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();
            return sha.ComputeHash(data);
        }

        /// <summary>
        /// Generate the Non-FIPS MAC signature with salt for the given data.
        /// </summary>
        /// <param name="macKey">MAC key used for generating MAC signature.</param>       
        /// <param name="data">The given Data</param>
        /// <param name="count">The cumulative encryption count, indicating how many 
        /// encryptions have been carried out.</param>
        /// <returns>The MAC signature.</returns>
        private static byte[] GenerateSaltedDataSignature(byte[] macKey, byte[] data, int count)
        {
            byte[] pad1 = ConstValue.NON_FIPS_PAD1;
            byte[] pad2 = ConstValue.NON_FIPS_PAD2;

            // SHAComponent = SHA(MACKeyN + Pad1 + DataLength + Data + EncryptionCount)
            byte[] temp = RdpbcgrUtility.ConcatenateArrays(macKey,
                                                    pad1,
                                                    BitConverter.GetBytes(data.Length),
                                                    data,
                                                    BitConverter.GetBytes(count));
            byte[] shaData = ShaHash(temp);

            // MACSignature = First64Bits(MD5(MACKeyN + Pad2 + SHAComponent))
            byte[] md5Temp = RdpbcgrUtility.ConcatenateArrays(macKey, pad2, shaData);
            temp = MD5Hash(md5Temp);
            return GetFirstNBits(64, temp);
        }

        /// <summary>
        /// Generate the Non-FIPS MAC signature for the given data.
        /// </summary>
        /// <param name="macKey">MAC key used for generating MAC signature.</param>       
        /// <param name="data">The given Data</param>
        /// <returns>The MAC signature.</returns>
        private static byte[] GenerateNonFIPSDataSignature(byte[] macKey, byte[] data)
        {
            byte[] pad1 = ConstValue.NON_FIPS_PAD1;
            byte[] pad2 = ConstValue.NON_FIPS_PAD2;

            // SHAComponent = SHA(MACKeyN + Pad1 + DataLength + Data)
            byte[] temp = RdpbcgrUtility.ConcatenateArrays(macKey, pad1, BitConverter.GetBytes(data.Length), data);
            byte[] shaData = ShaHash(temp);

            // MACSignature = First64Bits(MD5(MACKeyN + Pad2 + SHAComponent))
            byte[] md5Temp = RdpbcgrUtility.ConcatenateArrays(macKey, pad2, shaData);
            temp = MD5Hash(md5Temp);
            return GetFirstNBits(64, temp);
        }


        /// <summary>
        /// Generate the FIPS MAC signature for the given data.
        /// </summary>
        /// <param name="macKey">MAC key used for generating MAC signature.</param>       
        /// <param name="data">The given Data</param>
        /// <param name="count">The cumulative encryption count, indicating how many encryptions have been
        /// carried out.</param>
        /// <returns>The MAC signature.</returns>
        private static byte[] GenerateFIPSDataSignature(byte[] macKey, byte[] data, Int32 count)
        {
            // MACSignature = First64Bits(HMAC(HMACKey, Data + EncryptionCount))
            byte[] temp = RdpbcgrUtility.ConcatenateArrays(data, BitConverter.GetBytes(count));
            HMACSHA1 hmac = new HMACSHA1(macKey);
            return GetFirstNBits(64, hmac.ComputeHash(temp));
        }


        /// <summary>
        /// Reverse all bits of every byte for all bytes of a buffer.
        /// </summary>
        /// <param name="buffer">The buffer to be reversed.</param>
        private static void ReverseEveryByte(byte[] buffer)
        {
            for (int i = 0; i < buffer.Length; ++i)
            {
                buffer[i] = RdpbcgrUtility.ReverseByte(buffer[i]);
            }
        }


        /// <summary>
        /// Insert a zero-bit bit after every seventh bit.
        /// </summary>
        /// <param name="buffer">The buffer to be expanded. The length of the buffer should be divided by 7.
        /// Otherwise ArgumentException should be thrown.</param>
        /// <exception>ArgumentException</exception>
        private static void InsertZeroBit(ref byte[] buffer)
        {
            if ((buffer.Length % 7) != 0)
            {
                throw new ArgumentException("The length of the buffer should be divided by 7.");
            }

            byte[] newBuf = new byte[buffer.Length * 8 / 7];
            byte mask;
            byte redundance;
            int multiple = 0;
            int j = 0;
            while (j < newBuf.Length)
            {
                mask = 0x01;
                redundance = 0;

                // Adding a zero-bit after each group of seven bits
                for (int i = 0; i < 7; ++i)
                {
                    // every 7 bits make a new byte
                    newBuf[j++] = (byte)(((buffer[i + multiple * 7] >> i) | redundance) & 0xFE);
                    redundance = (byte)((buffer[i + multiple * 7] & mask) << (7 - i));
                    mask = (byte)((mask << 1) | mask);
                }

                newBuf[j++] = redundance;
                multiple++;
            }

            buffer = newBuf;
        }


        /// <summary>
        /// Alter the least significant bit in the byte so that the entire byte has odd parity.
        /// </summary>
        /// <param name="aByte">The byte to be computed odd parity.</param>
        private static void FillOddParity(ref byte aByte)
        {
            byte someByte = (byte)(aByte & 0xFE);
            int count = 0;

            // compute the number of 1 in someByte
            if (someByte != 0)
            {
                while ((someByte &= (byte)(someByte - 1)) != 0)
                {
                    count++;
                }

                count++;
            }

            if (count % 2 == 0)
            {
                aByte |= 0x01;
            }
            else
            {
                aByte &= 0xFE;
            }
        }


        /// <summary>
        /// For each byte in a byte array compute its odd parity. 
        /// </summary>
        /// <param name="buffer">The buffer to be computed odd parity.</param>
        private static void FillOddParity(byte[] buffer)
        {
            for (int i = 0; i < buffer.Length; ++i)
            {
                FillOddParity(ref buffer[i]);
            }
        }


        /// <summary>
        /// Update session key for Non-FIPS according to section 5.3.7 Session Key Updates.
        /// </summary>
        /// <param name="initialKey">The initial session key.</param>
        /// <param name="currentKey">The current session key.</param>
        /// <param name="encryptionMethod">The current encryption method.</param>
        /// <returns>The new session key.</returns>
        private static byte[] UpdateKey(byte[] initialKey, byte[] currentKey, EncryptionMethods encryptionMethod)
        {
            byte[] pad1 = ConstValue.NON_FIPS_PAD1;
            byte[] pad2 = ConstValue.NON_FIPS_PAD2;
            byte[] newKey = null;

            // SHAComponent = SHA(InitialEncryptKey + Pad1 + CurrentEncryptKey)
            byte[] shaComponentBuffer = RdpbcgrUtility.ConcatenateArrays(initialKey, pad1, currentKey);
            byte[] shaComponent = ShaHash(shaComponentBuffer);

            // TempKey128 = MD5(InitialEncryptKey + Pad2 + SHAComponent)
            byte[] tempKey128Buffer = RdpbcgrUtility.ConcatenateArrays(initialKey, pad2, shaComponent);
            byte[] tempKey128 = MD5Hash(tempKey128Buffer);

            if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_128BIT)
            {
                // S-TableEncrypt = InitRC4(TempKey128)
                RC4CryptoServiceProvider rc4 = new RC4CryptoServiceProvider();
                ICryptoTransform ict = rc4.CreateEncryptor(tempKey128, null);

                // NewEncryptKey128 = RC4(TempKey128, S-TableEncrypt)
                newKey = ict.TransformFinalBlock(tempKey128, 0, tempKey128.Length);
            }
            else if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT
                     || encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_56BIT)
            {
                // TempKey64 = First64Bits(TempKey128)                
                byte[] tempKey64 = GetFirstNBits(64, tempKey128);

                // S-TableEncrypt = InitRC4(TempKey64)
                RC4CryptoServiceProvider rc4 = new RC4CryptoServiceProvider();
                ICryptoTransform ict = rc4.CreateEncryptor(tempKey64, null);

                // PreSaltKey = RC4(TempKey64, S-TableEncrypt)
                byte[] preSaltKey = ict.TransformFinalBlock(tempKey64, 0, tempKey64.Length);

                if (encryptionMethod == EncryptionMethods.ENCRYPTION_METHOD_40BIT)
                {
                    // NewEncryptKey40 = 0xD1269E + Last40Bits(PreSaltKey)
                    newKey = RdpbcgrUtility.ConcatenateArrays(ConstValue.NON_FIPS_SALT_40BIT, GetLastNBits(40, preSaltKey));
                }
                else
                {
                    // NewEncryptKey56 = 0xD1 + Last56Bits(PreSaltKey)
                    newKey = RdpbcgrUtility.ConcatenateArrays(ConstValue.NON_FIPS_SALT_56BIT, GetLastNBits(56, preSaltKey));
                }
            }
            // else do nothing

            return newKey;
        }
        #endregion private methods


        #region IDisposable
        /// <summary>
        /// Release the managed and unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }


        /// <summary>
        /// Release resources.
        /// </summary>
        /// <param name="disposing">If disposing equals true, Managed and unmanaged resources are disposed.
        /// if false, Only unmanaged resources can be disposed.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    //Release managed resource.
                    if (rc4Encrypt != null)
                    {
                        rc4Encrypt.Dispose();
                        rc4Encrypt = null;
                    }

                    if (rc4Decrypt != null)
                    {
                        rc4Decrypt.Dispose();
                        rc4Decrypt = null;
                    }

                    if (rc4EncryptServer != null)
                    {
                        rc4EncryptServer.Dispose();
                        rc4EncryptServer = null;
                    }

                    if (rc4DecryptServer != null)
                    {
                        rc4DecryptServer.Dispose();
                        rc4DecryptServer = null;
                    }

                    if (desEncrypt != null)
                    {
                        desEncrypt.Clear();
                        desEncrypt = null;
                    }

                    if (desDecrypt != null)
                    {
                        desDecrypt.Clear();
                        desDecrypt = null;
                    }

                    if (desEncryptServer != null)
                    {
                        desEncryptServer.Clear();
                        desEncryptServer = null;
                    }

                    if (desDecryptServer != null)
                    {
                        desDecryptServer.Clear();
                        desDecryptServer = null;
                    }
                }

                //Note disposing has been done.
                disposed = true;
            }
        }


        /// <summary>
        /// Destruct this instance.
        /// </summary>
        ~EncryptionAlgorithm()
        {
            Dispose(false);
        }
        #endregion
    }
}
