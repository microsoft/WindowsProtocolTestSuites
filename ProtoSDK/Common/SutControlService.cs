// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4016
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.Protocols.TestTools.StackSdk
{
    /// <summary>
    /// SutControlService Interface
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(ConfigurationName = "ISutControlService")]
    public interface ISutControlService
    {

        /// <summary>
        /// Start a process
        /// </summary>
        /// <param name="command">The executable file path</param>
        /// <param name="arguments">The arguments passed to the process</param>
        /// <param name="userName">The userName who start the process</param>
        /// <param name="password">The password of the user</param>
        /// <param name="domain">The domain of the user</param>
        /// <returns>The started process id</returns>
        [System.ServiceModel.OperationContractAttribute(Action = "http://tempuri.org/ISutControlService/StartProcess", ReplyAction = "http://tempuri.org/ISutControlService/StartProcessResponse")]
        int StartProcess(string command, string arguments, string userName, string password, string domain);

        /// <summary>
        /// Start the process and wait for it finish its job
        /// </summary>
        /// <param name="command">The executable file path</param>
        /// <param name="arguments">The arguments passed to the process</param>
        /// <param name="userName">The userName who start the process</param>
        /// <param name="password">The password of the user</param>
        /// <param name="domain">The domain of the user</param>
        /// <param name="timeout">The waiting time it will wait</param>
        /// <param name="exitCode">The exit code of the process</param>
        /// <param name="standardOutput">The output of the process</param>
        /// <param name="standardError">The error of the process</param>
        /// <returns>The process id</returns>
        [System.ServiceModel.OperationContractAttribute(Action = "http://tempuri.org/ISutControlService/StartProcessWaitForExit", ReplyAction = "http://tempuri.org/ISutControlService/StartProcessWaitForExitResponse")]
        int StartProcessWaitForExit(string command, string arguments, string userName, string password, string domain, System.TimeSpan timeout, out int exitCode, out string standardOutput, out string standardError);


        /// <summary>
        /// Get execution results of the process specified by processId
        /// This method executes asynchronously.
        /// If the process has exited, this method returns true, with valid exitCode.
        /// If the process is still running, this method returns false.
        /// standardOutput and standardError will always been output
        /// as long as process outputs stream, no matter the process is running or exited.
        /// </summary>
        /// <param name="processId">the unique identifier for the process</param>
        /// <param name="exitCode">exit code of the process if process has exited.
        /// Note: if this method returns false, this parameter is assigned zero
        /// which means process has not exited, thus has not provided exit code yet.</param>
        /// <param name="standardOutput">
        /// content that the process generates to the standard output stream,
        /// since last query time.
        /// Empty string returns if no content generated.</param>
        /// <param name="standardError">
        /// content that the process generates to the standard error stream,
        /// since last query time.
        /// Empty string returns if no content generated.</param>
        /// <returns>true if process has exited, otherwise returns false.</returns>
        [System.ServiceModel.OperationContractAttribute(Action = "http://tempuri.org/ISutControlService/GetExecutionResults", ReplyAction = "http://tempuri.org/ISutControlService/GetExecutionResultsResponse")]
        bool GetExecutionResults(int processId, out int exitCode, out string standardOutput, out string standardError);


        /// <summary>
        /// Kill the process specified by processId.
        /// Perform no action if the process has already exited.
        /// This method executes synchronously, blocks current thread till process exits or timeouts.
        /// </summary>
        /// <param name="processId">the unique identifier for the process</param>
        /// <param name="timeout">if the process doesn't exit after waiting specified time span,
        /// a TimeoutException is thrown.
        /// timeout should either be 
        /// (1) TimeSpan.MaxValue which presents infinity, or
        /// (2) its total milliseconds is greater than 0 and less than or equals to Int32.MaxValue.
        /// </param>
        [System.ServiceModel.OperationContractAttribute(Action = "http://tempuri.org/ISutControlService/KillProcess", ReplyAction = "http://tempuri.org/ISutControlService/KillProcessResponse")]
        void KillProcess(int processId, System.TimeSpan timeout);


        /// <summary>
        /// Clear information proxy collected for process of specified processId,
        /// so the unused memory can be recycled.
        /// After calling this method, the processId is disposed and not valid to use any more.
        /// It's safe to call this method more than once.
        /// </summary>
        /// <param name="processId">the unused process Id</param>
        [System.ServiceModel.OperationContractAttribute(Action = "http://tempuri.org/ISutControlService/ClearProcess", ReplyAction = "http://tempuri.org/ISutControlService/ClearProcessResponse")]
        void ClearProcess(int processId);
    }

    /// <summary>
    /// SutControlServiceChannel interface
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface ISutControlServiceChannel : ISutControlService, System.ServiceModel.IClientChannel
    {
    }

    /// <summary>
    /// The client side of Sut control service
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class SutControlServiceClient : System.ServiceModel.ClientBase<ISutControlService>, ISutControlService
    {
        /// <summary>
        /// Constructor
        /// </summary>
        public SutControlServiceClient()
        {
        }


        /// <summary>
        /// Constructor with specified endpointConfigurationName
        /// </summary>
        /// <param name="endpointConfigurationName">Then endpoint name of the service</param>
        public SutControlServiceClient(string endpointConfigurationName) :
            base(endpointConfigurationName)
        {
        }


        /// <summary>
        /// Constructor with specified endpointConfigurationName and remoteAddress
        /// </summary>
        /// <param name="endpointConfigurationName">Then endpoint name of the service</param>
        /// <param name="remoteAddress">The remote address name</param>
        public SutControlServiceClient(string endpointConfigurationName, string remoteAddress) :
            base(endpointConfigurationName, remoteAddress)
        {
        }


        /// <summary>
        /// Constructor with specified endpointConfigurationName and remoteAddress
        /// </summary>
        /// <param name="endpointConfigurationName">Then endpoint name of the service</param>
        /// <param name="remoteAddress">The remote address name</param>
        public SutControlServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
            base(endpointConfigurationName, remoteAddress)
        {
        }


        /// <summary>
        /// Constructor with specified Binding information and remoteAddress
        /// </summary>
        /// <param name="binding">Then binding information</param>
        /// <param name="remoteAddress">The remote address name</param>
        public SutControlServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
            base(binding, remoteAddress)
        {
        }


        /// <summary>
        /// Start a process
        /// </summary>
        /// <param name="command">The executable file path</param>
        /// <param name="arguments">The arguments passed to the process</param>
        /// <param name="userName">The userName who start the process</param>
        /// <param name="password">The password of the user</param>
        /// <param name="domain">The domain of the user</param>
        /// <returns>The started process id</returns>
        public int StartProcess(string command, string arguments, string userName, string password, string domain)
        {
            return base.Channel.StartProcess(command, arguments, userName, password, domain);
        }


        /// <summary>
        /// Start the process and wait for it finish its job
        /// </summary>
        /// <param name="command">The executable file path</param>
        /// <param name="arguments">The arguments passed to the process</param>
        /// <param name="userName">The userName who start the process</param>
        /// <param name="password">The password of the user</param>
        /// <param name="domain">The domain of the user</param>
        /// <param name="timeout">The waiting time it will wait</param>
        /// <param name="exitCode">The exit code of the process</param>
        /// <param name="standardOutput">The output of the process</param>
        /// <param name="standardError">The error of the process</param>
        /// <returns>The process id</returns>
        public int StartProcessWaitForExit(string command, string arguments, string userName, string password, string domain, System.TimeSpan timeout, out int exitCode, out string standardOutput, out string standardError)
        {
            return base.Channel.StartProcessWaitForExit(command, arguments, userName, password, domain, timeout, out exitCode, out standardOutput, out standardError);
        }


        /// <summary>
        /// Get execution results of the process specified by processId
        /// This method executes asynchronously.
        /// If the process has exited, this method returns true, with valid exitCode.
        /// If the process is still running, this method returns false.
        /// standardOutput and standardError will always been output
        /// as long as process outputs stream, no matter the process is running or exited.
        /// </summary>
        /// <param name="processId">the unique identifier for the process</param>
        /// <param name="exitCode">exit code of the process if process has exited.
        /// Note: if this method returns false, this parameter is assigned zero
        /// which means process has not exited, thus has not provided exit code yet.</param>
        /// <param name="standardOutput">
        /// content that the process generates to the standard output stream,
        /// since last query time.
        /// Empty string returns if no content generated.</param>
        /// <param name="standardError">
        /// content that the process generates to the standard error stream,
        /// since last query time.
        /// Empty string returns if no content generated.</param>
        /// <returns>true if process has exited, otherwise returns false.</returns>
        public bool GetExecutionResults(int processId, out int exitCode, out string standardOutput, out string standardError)
        {
            return base.Channel.GetExecutionResults(processId, out exitCode, out standardOutput, out standardError);
        }


        /// <summary>
        /// Kill the process specified by processId.
        /// Perform no action if the process has already exited.
        /// This method executes synchronously, blocks current thread till process exits or timeouts.
        /// </summary>
        /// <param name="processId">the unique identifier for the process</param>
        /// <param name="timeout">if the process doesn't exit after waiting specified time span,
        /// a TimeoutException is thrown.
        /// timeout should either be 
        /// (1) TimeSpan.MaxValue which presents infinity, or
        /// (2) its total milliseconds is greater than 0 and less than or equals to Int32.MaxValue.
        /// </param>
        public void KillProcess(int processId, System.TimeSpan timeout)
        {
            base.Channel.KillProcess(processId, timeout);
        }


        /// <summary>
        /// Clear information proxy collected for process of specified processId,
        /// so the unused memory can be recycled.
        /// After calling this method, the processId is disposed and not valid to use any more.
        /// It's safe to call this method more than once.
        /// </summary>
        /// <param name="processId">the unused process Id</param>
        public void ClearProcess(int processId)
        {
            base.Channel.ClearProcess(processId);
        }
    }
}